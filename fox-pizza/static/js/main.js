/*!
 * jQuery JavaScript Library v3.1.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2016-09-22T22:30Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.1.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			resolve.call( undefined, value );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.call( undefined, value );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

function manipulationTarget( elem, content ) {
	if ( jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE <=9 only
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;

	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? "border" : "content" ) ) {
		i = 4;

	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === "width" ? 1 : 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val,
		valueIsBorderBox = true,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE <=11 only
	// Running getBoundingClientRect on a disconnected node
	// in IE throws an error.
	if ( elem.getClientRects().length ) {
		val = elem.getBoundingClientRect()[ name ];
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function raf() {
	if ( timerId ) {
		window.requestAnimationFrame( raf );
		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off or if document is hidden
	if ( jQuery.fx.off || document.hidden ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.requestAnimationFrame ?
			window.requestAnimationFrame( raf ) :
			window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	if ( window.cancelAnimationFrame ) {
		window.cancelAnimationFrame( timerId );
	} else {
		window.clearInterval( timerId );
	}

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( jQuery.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win, rect, doc,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		// Make sure element is not hidden (display: none)
		if ( rect.width || rect.height ) {
			doc = elem.ownerDocument;
			win = getWindow( doc );
			docElem = doc.documentElement;

			return {
				top: rect.top + win.pageYOffset - docElem.clientTop,
				left: rect.left + win.pageXOffset - docElem.clientLeft
			};
		}

		// Return zeros for disconnected and hidden elements (gh-2310)
		return rect;
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.parseJSON = JSON.parse;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}





return jQuery;
} );

/*
 * Input Mask Core
 * http://github.com/RobinHerbots/jquery.inputmask
 * Copyright (c) 2010 -	Robin Herbots
 * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
 * Version: 0.0.0-dev
 */
(function (factory) {
    if (typeof define === "function" && define.amd) {
        define(["./dependencyLibs/inputmask.dependencyLib", "./global/window", "./global/document"], factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require("./dependencyLibs/inputmask.dependencyLib"), require("./global/window"), require("./global/document"));
    } else {
        window.Inputmask = factory(window.dependencyLib || jQuery, window, document);
    }
}
(function ($, window, document, undefined) {
    var ua = navigator.userAgent,
        mobile = /mobile/i.test(ua),
        iemobile = /iemobile/i.test(ua),
        iphone = /iphone/i.test(ua) && !iemobile,
        android = /android/i.test(ua) && !iemobile;

    function Inputmask(alias, options, internal) {
        //allow instanciating without new
        if (!(this instanceof Inputmask)) {
            return new Inputmask(alias, options, internal);
        }

        this.el = undefined;
        this.events = {};
        this.maskset = undefined;
        this.refreshValue = false; //indicate a refresh from the inputvalue is needed (form.reset)

        if (internal !== true) {
            //init options
            if ($.isPlainObject(alias)) {
                options = alias;
            } else {
                options = options || {};
                options.alias = alias;
            }
            this.opts = $.extend(true, {}, this.defaults, options);
            this.noMasksCache = options && options.definitions !== undefined;
            this.userOptions = options || {}; //user passed options
            this.isRTL = this.opts.numericInput;
            resolveAlias(this.opts.alias, options, this.opts);
        }
    }

    Inputmask.prototype = {
        dataAttribute: "data-inputmask", //data attribute prefix used for attribute binding
        //options default
        defaults: {
            placeholder: "_",
            optionalmarker: {
                start: "[",
                end: "]"
            },
            quantifiermarker: {
                start: "{",
                end: "}"
            },
            groupmarker: {
                start: "(",
                end: ")"
            },
            alternatormarker: "|",
            escapeChar: "\\",
            mask: null, //needs tobe null instead of undefined as the extend method does not consider props with the undefined value
            regex: null, //regular expression as a mask
            oncomplete: $.noop, //executes when the mask is complete
            onincomplete: $.noop, //executes when the mask is incomplete and focus is lost
            oncleared: $.noop, //executes when the mask is cleared
            repeat: 0, //repetitions of the mask: * ~ forever, otherwise specify an integer
            greedy: true, //true: allocated buffer for the mask and repetitions - false: allocate only if needed
            autoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor
            removeMaskOnSubmit: false, //remove the mask before submitting the form.
            clearMaskOnLostFocus: true,
            insertMode: true, //insert the input or overwrite the input
            clearIncomplete: false, //clear the incomplete input on blur
            alias: null,
            onKeyDown: $.noop, //callback to implement autocomplete on certain keys for example. args => event, buffer, caretPos, opts
            onBeforeMask: null, //executes before masking the initial value to allow preprocessing of the initial value.	args => initialValue, opts => return processedValue
            onBeforePaste: function (pastedValue, opts) {
                return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;
            }, //executes before masking the pasted value to allow preprocessing of the pasted value.	args => pastedValue, opts => return processedValue
            onBeforeWrite: null, //executes before writing to the masked element. args => event, opts
            onUnMask: null, //executes after unmasking to allow postprocessing of the unmaskedvalue.	args => maskedValue, unmaskedValue, opts
            showMaskOnFocus: true, //show the mask-placeholder when the input has focus
            showMaskOnHover: true, //show the mask-placeholder when hovering the empty input
            onKeyValidation: $.noop, //executes on every key-press with the result of isValid. Params: key, result, opts
            skipOptionalPartCharacter: " ", //a character which can be used to skip an optional part of a mask
            numericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)
            rightAlign: false, //align to the right
            undoOnEscape: true, //pressing escape reverts the value to the value before focus
            //numeric basic properties
            radixPoint: "", //".", // | ","
            radixPointDefinitionSymbol: undefined, //set the radixPoint definitionSymbol ~ used for awareness of the radixpoint
            groupSeparator: "", //",", // | "."
            //numeric basic properties
            keepStatic: null, //try to keep the mask static while typing. Decisions to alter the mask will be posponed if possible - null see auto selection for multi masks
            positionCaretOnTab: true, //when enabled the caret position is set after the latest valid position on TAB
            tabThrough: false, //allows for tabbing through the different parts of the masked field
            supportsInputType: ["text", "tel", "password"], //list with the supported input types
            //specify keyCodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF
            ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],
            isComplete: null, //override for isComplete - args => buffer, opts - return true || false
            canClearPosition: $.noop, //hook to alter the clear behavior in the stripValidPositions args => maskset, position, lastValidPosition, opts => return true|false/command object
            preValidation: null, //hook to preValidate the input.  Usefull for validating regardless the definition.	args => buffer, pos, char, isSelection, opts => return true/false/command object
            postValidation: null, //hook to postValidate the result from isValid.	Usefull for validating the entry as a whole.	args => buffer, currentResult, opts => return true/false/json
            staticDefinitionSymbol: undefined, //specify a definitionSymbol for static content, used to make matches for alternators
            jitMasking: false, //just in time masking ~ only mask while typing, can n (number), true or false
            nullable: true, //return nothing instead of the buffertemplate when the user hasn't entered anything.
            inputEventOnly: false, //dev option - testing inputfallback behavior
            noValuePatching: false, //disable value property patching
            positionCaretOnClick: "lvp", //none, lvp (based on the last valid position (default), radixFocus (position caret to radixpoint on initial click)
            casing: null, //mask-level casing. Options: null, "upper", "lower" or "title" or callback args => elem, test, pos, validPositions return charValue
            inputmode: "verbatim", //specify the inputmode  - already in place for when browsers will support it
            colorMask: false, //enable css styleable mask
            androidHack: false, //see README_android.md
            importDataAttributes: true //import data-inputmask attributes
        },
        definitions: {
            "9": { //\uFF11-\uFF19 #1606
                validator: "[0-9\uFF11-\uFF19]",
                cardinality: 1,
                definitionSymbol: "*"
            },
            "a": { //\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5 #76
                validator: "[A-Za-z\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5]",
                cardinality: 1,
                definitionSymbol: "*"
            },
            "*": {
                validator: "[0-9\uFF11-\uFF19A-Za-z\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5]",
                cardinality: 1
            }
        },
        aliases: {}, //aliases definitions => see jquery.inputmask.extensions.js
        masksCache: {},
        mask: function (elems) {
            var that = this;

            function importAttributeOptions(npt, opts, userOptions, dataAttribute) {
                if (opts.importDataAttributes === true) {
                    var attrOptions = npt.getAttribute(dataAttribute),
                        option, dataoptions, optionData, p;

                    function importOption(option, optionData) {
                        optionData = optionData !== undefined ? optionData : npt.getAttribute(dataAttribute + "-" + option);
                        if (optionData !== null) {
                            if (typeof optionData === "string") {
                                if (option.indexOf("on") === 0) optionData = window[optionData]; //get function definition
                                else if (optionData === "false") optionData = false;
                                else if (optionData === "true") optionData = true;
                            }
                            userOptions[option] = optionData;
                        }
                    }

                    if (attrOptions && attrOptions !== "") {
                        attrOptions = attrOptions.replace(new RegExp("'", "g"), '"');
                        dataoptions = JSON.parse("{" + attrOptions + "}");
                    }

                    //resolve aliases
                    if (dataoptions) { //pickup alias from dataAttribute
                        optionData = undefined;
                        for (p in dataoptions) {
                            if (p.toLowerCase() === "alias") {
                                optionData = dataoptions[p];
                                break;
                            }
                        }
                    }
                    importOption("alias", optionData); //pickup alias from dataAttribute-alias
                    if (userOptions.alias) {
                        resolveAlias(userOptions.alias, userOptions, opts);
                    }

                    for (option in opts) {
                        if (dataoptions) {
                            optionData = undefined;
                            for (p in dataoptions) {
                                if (p.toLowerCase() === option.toLowerCase()) {
                                    optionData = dataoptions[p];
                                    break;
                                }
                            }
                        }
                        importOption(option, optionData);
                    }
                }
                $.extend(true, opts, userOptions);

                //handle dir=rtl
                if (npt.dir === "rtl" || opts.rightAlign) {
                    npt.style.textAlign = "right";
                }

                if (npt.dir === "rtl" || opts.numericInput) {
                    npt.dir = "ltr";
                    npt.removeAttribute("dir");
                    opts.isRTL = true;
                }

                return opts;
            }

            if (typeof elems === "string") {
                elems = document.getElementById(elems) || document.querySelectorAll(elems);
            }
            elems = elems.nodeName ? [elems] : elems;
            $.each(elems, function (ndx, el) {
                var scopedOpts = $.extend(true, {}, that.opts);
                importAttributeOptions(el, scopedOpts, $.extend(true, {}, that.userOptions), that.dataAttribute);
                var maskset = generateMaskSet(scopedOpts, that.noMasksCache);
                if (maskset !== undefined) {
                    if (el.inputmask !== undefined) {
                        el.inputmask.opts.autoUnmask = true; //force autounmasking when remasking
                        el.inputmask.remove();
                    }
                    //store inputmask instance on the input with element reference
                    el.inputmask = new Inputmask(undefined, undefined, true);
                    el.inputmask.opts = scopedOpts;
                    el.inputmask.noMasksCache = that.noMasksCache;
                    el.inputmask.userOptions = $.extend(true, {}, that.userOptions);
                    el.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput;
                    el.inputmask.el = el;
                    el.inputmask.maskset = maskset;

                    $.data(el, "_inputmask_opts", scopedOpts);

                    maskScope.call(el.inputmask, {
                        "action": "mask"
                    });
                }
            });
            return elems && elems[0] ? (elems[0].inputmask || this) : this;
        },
        option: function (options, noremask) { //set extra options || retrieve value of a current option
            if (typeof options === "string") {
                return this.opts[options];
            } else if (typeof options === "object") {
                $.extend(this.userOptions, options); //user passed options
                //remask
                if (this.el && noremask !== true) {
                    this.mask(this.el);
                }
                return this;
            }
        },
        unmaskedvalue: function (value) {
            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
                "action": "unmaskedvalue",
                "value": value
            });
        },
        remove: function () {
            return maskScope.call(this, {
                "action": "remove"
            });
        },
        getemptymask: function () { //return the default (empty) mask value, usefull for setting the default value in validation
            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
                "action": "getemptymask"
            });
        },
        hasMaskedValue: function () { //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value
            return !this.opts.autoUnmask;
        },
        isComplete: function () {
            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
                "action": "isComplete"
            });
        },
        getmetadata: function () { //return mask metadata if exists
            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
                "action": "getmetadata"
            });
        },
        isValid: function (value) {
            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
                "action": "isValid",
                "value": value
            });
        },
        format: function (value, metadata) {
            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
                "action": "format",
                "value": value,
                "metadata": metadata //true/false getmetadata
            });
        },
        analyseMask: function (mask, regexMask, opts) {
            var tokenizer = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g,
                //Thx to https://github.com/slevithan/regex-colorizer for the regexTokenizer regex
                regexTokenizer = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
                escaped = false,
                currentToken = new MaskToken(),
                match,
                m,
                openenings = [],
                maskTokens = [],
                openingToken,
                currentOpeningToken,
                alternator,
                lastMatch,
                groupToken;

            function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {
                this.matches = [];
                this.openGroup = isGroup || false;
                this.alternatorGroup = false;
                this.isGroup = isGroup || false;
                this.isOptional = isOptional || false;
                this.isQuantifier = isQuantifier || false;
                this.isAlternator = isAlternator || false;
                this.quantifier = {
                    min: 1,
                    max: 1
                };
            }

            //test definition => {fn: RegExp/function, cardinality: int, optionality: bool, newBlockMarker: bool, casing: null/upper/lower, def: definitionSymbol, placeholder: placeholder, mask: real maskDefinition}
            function insertTestDefinition(mtoken, element, position) {
                position = position !== undefined ? position : mtoken.matches.length;
                var prevMatch = mtoken.matches[position - 1];
                if (regexMask) {
                    if (element.indexOf("[") === 0 || (escaped && /\\d|\\s|\\w]/i.test(element)) || element === ".") {
                        mtoken.matches.splice(position++, 0, {
                            fn: new RegExp(element, opts.casing ? "i" : ""),
                            cardinality: 1,
                            optionality: mtoken.isOptional,
                            newBlockMarker: prevMatch === undefined || prevMatch.def !== element,
                            casing: null,
                            def: element,
                            placeholder: undefined,
                            nativeDef: element
                        });
                    } else {
                        if (escaped) element = element[element.length - 1];
                        $.each(element.split(""), function (ndx, lmnt) {
                            prevMatch = mtoken.matches[position - 1];
                            mtoken.matches.splice(position++, 0, {
                                fn: null,
                                cardinality: 0,
                                optionality: mtoken.isOptional,
                                newBlockMarker: prevMatch === undefined || (prevMatch.def !== lmnt && prevMatch.fn !== null),
                                casing: null,
                                def: opts.staticDefinitionSymbol || lmnt,
                                placeholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,
                                nativeDef: lmnt
                            });
                        });
                    }
                    escaped = false;
                } else {
                    var maskdef = (opts.definitions ? opts.definitions[element] : undefined) || Inputmask.prototype.definitions[element];
                    if (maskdef && !escaped) {
                        var prevalidators = maskdef.prevalidator,
                            prevalidatorsL = prevalidators ? prevalidators.length : 0;
                        //handle prevalidators
                        for (var i = 1; i < maskdef.cardinality; i++) {
                            var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [],
                                validator = prevalidator.validator,
                                cardinality = prevalidator.cardinality;
                            mtoken.matches.splice(position++, 0, {
                                fn: validator ? typeof validator === "string" ? new RegExp(validator, opts.casing ? "i" : "") : new function () {
                                    this.test = validator;
                                } : new RegExp("."),
                                cardinality: cardinality ? cardinality : 1,
                                optionality: mtoken.isOptional,
                                newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),
                                casing: maskdef.casing,
                                def: maskdef.definitionSymbol || element,
                                placeholder: maskdef.placeholder,
                                nativeDef: element
                            });
                            prevMatch = mtoken.matches[position - 1];
                        }
                        mtoken.matches.splice(position++, 0, {
                            fn: maskdef.validator ? typeof maskdef.validator == "string" ? new RegExp(maskdef.validator, opts.casing ? "i" : "") : new function () {
                                this.test = maskdef.validator;
                            } : new RegExp("."),
                            cardinality: maskdef.cardinality,
                            optionality: mtoken.isOptional,
                            newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),
                            casing: maskdef.casing,
                            def: maskdef.definitionSymbol || element,
                            placeholder: maskdef.placeholder,
                            nativeDef: element
                        });
                    } else {
                        mtoken.matches.splice(position++, 0, {
                            fn: null,
                            cardinality: 0,
                            optionality: mtoken.isOptional,
                            newBlockMarker: prevMatch === undefined || (prevMatch.def !== element && prevMatch.fn !== null),
                            casing: null,
                            def: opts.staticDefinitionSymbol || element,
                            placeholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,
                            nativeDef: element
                        });
                        escaped = false;
                    }
                }
            }

            function verifyGroupMarker(maskToken) {
                if (maskToken && maskToken.matches) {
                    $.each(maskToken.matches, function (ndx, token) {
                            var nextToken = maskToken.matches[ndx + 1];
                            if ((nextToken === undefined || (nextToken.matches === undefined || nextToken.isQuantifier === false)) && token && token.isGroup) { //this is not a group but a normal mask => convert
                                token.isGroup = false;
                                if (!regexMask) {
                                    insertTestDefinition(token, opts.groupmarker.start, 0);
                                    if (token.openGroup !== true) {
                                        insertTestDefinition(token, opts.groupmarker.end);
                                    }
                                }
                            }
                            verifyGroupMarker(token);
                        }
                    );
                }
            }

            function defaultCase() {
                if (openenings.length > 0) {
                    currentOpeningToken = openenings[openenings.length - 1];
                    insertTestDefinition(currentOpeningToken, m);
                    if (currentOpeningToken.isAlternator) { //handle alternator a | b case
                        alternator = openenings.pop();
                        for (var mndx = 0; mndx < alternator.matches.length; mndx++) {
                            alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group
                        }
                        if (openenings.length > 0) {
                            currentOpeningToken = openenings[openenings.length - 1];
                            currentOpeningToken.matches.push(alternator);
                        } else {
                            currentToken.matches.push(alternator);
                        }
                    }
                } else {
                    insertTestDefinition(currentToken, m);
                }
            }

            function reverseTokens(maskToken) {
                function reverseStatic(st) {
                    if (st === opts.optionalmarker.start) st = opts.optionalmarker.end;
                    else if (st === opts.optionalmarker.end) st = opts.optionalmarker.start;
                    else if (st === opts.groupmarker.start) st = opts.groupmarker.end;
                    else if (st === opts.groupmarker.end) st = opts.groupmarker.start;

                    return st;
                }

                maskToken.matches = maskToken.matches.reverse();
                for (var match in maskToken.matches) {
                    if (maskToken.matches.hasOwnProperty(match)) {
                        var intMatch = parseInt(match);
                        if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) { //reposition quantifier
                            var qt = maskToken.matches[match];
                            maskToken.matches.splice(match, 1);
                            maskToken.matches.splice(intMatch + 1, 0, qt);
                        }
                        if (maskToken.matches[match].matches !== undefined) {
                            maskToken.matches[match] = reverseTokens(maskToken.matches[match]);
                        } else {
                            maskToken.matches[match] = reverseStatic(maskToken.matches[match]);
                        }
                    }
                }

                return maskToken;
            }

            if (regexMask) {
                opts.optionalmarker.start = undefined;
                opts.optionalmarker.end = undefined;
            }
            while (match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask)) {
                m = match[0];

                if (regexMask) {
                    switch (m.charAt(0)) {
                        //Quantifier
                        case "?":
                            m = "{0,1}";
                            break;
                        case "+":
                        case "*":
                            m = "{" + m + "}";
                            break;
                    }
                }

                if (escaped) {
                    defaultCase();
                    continue;
                }
                switch (m.charAt(0)) {
                    case opts.escapeChar:
                        escaped = true;
                        if (regexMask) {
                            defaultCase();
                        }
                        break;
                    case opts.optionalmarker.end:
                    // optional closing
                    case opts.groupmarker.end:
                        // Group closing
                        openingToken = openenings.pop();
                        openingToken.openGroup = false; //mark group as complete
                        if (openingToken !== undefined) {
                            if (openenings.length > 0) {
                                currentOpeningToken = openenings[openenings.length - 1];
                                currentOpeningToken.matches.push(openingToken);
                                if (currentOpeningToken.isAlternator) { //handle alternator (a) | (b) case
                                    alternator = openenings.pop();
                                    for (var mndx = 0; mndx < alternator.matches.length; mndx++) {
                                        alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group
                                        alternator.matches[mndx].alternatorGroup = false;
                                    }
                                    if (openenings.length > 0) {
                                        currentOpeningToken = openenings[openenings.length - 1];
                                        currentOpeningToken.matches.push(alternator);
                                    } else {
                                        currentToken.matches.push(alternator);
                                    }
                                }
                            } else {
                                currentToken.matches.push(openingToken);
                            }
                        } else defaultCase();
                        break;
                    case opts.optionalmarker.start:
                        // optional opening
                        openenings.push(new MaskToken(false, true));
                        break;
                    case opts.groupmarker.start:
                        // Group opening
                        openenings.push(new MaskToken(true));
                        break;
                    case opts.quantifiermarker.start:
                        //Quantifier
                        var quantifier = new MaskToken(false, false, true);

                        m = m.replace(/[{}]/g, "");
                        var mq = m.split(","),
                            mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
                            mq1 = mq.length === 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1]));
                        if (mq1 === "*" || mq1 === "+") {
                            mq0 = mq1 === "*" ? 0 : 1;
                        }
                        quantifier.quantifier = {
                            min: mq0,
                            max: mq1
                        };
                        if (openenings.length > 0) {
                            var matches = openenings[openenings.length - 1].matches;
                            match = matches.pop();
                            if (!match.isGroup) {
                                groupToken = new MaskToken(true);
                                groupToken.matches.push(match);
                                match = groupToken;
                            }
                            matches.push(match);
                            matches.push(quantifier);
                        } else {
                            match = currentToken.matches.pop();
                            if (!match.isGroup) {
                                if (regexMask && match.fn === null) {
                                    if (match.def === ".") match.fn = new RegExp(match.def, opts.casing ? "i" : "");
                                }

                                groupToken = new MaskToken(true);
                                groupToken.matches.push(match);
                                match = groupToken;
                            }
                            currentToken.matches.push(match);
                            currentToken.matches.push(quantifier);
                        }
                        break;
                    case opts.alternatormarker:
                        if (openenings.length > 0) {
                            currentOpeningToken = openenings[openenings.length - 1];
                            var subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];
                            if (currentOpeningToken.openGroup && //regexp alt syntax
                                (subToken.matches === undefined || (subToken.isGroup === false && subToken.isAlternator === false))) { //alternations within group
                                lastMatch = openenings.pop();
                            } else {
                                lastMatch = currentOpeningToken.matches.pop();
                            }
                        } else {
                            lastMatch = currentToken.matches.pop();
                        }
                        if (lastMatch.isAlternator) {
                            openenings.push(lastMatch);
                        } else {
                            if (lastMatch.alternatorGroup) {
                                alternator = openenings.pop();
                                lastMatch.alternatorGroup = false;
                            } else {
                                alternator = new MaskToken(false, false, false, true);
                            }
                            alternator.matches.push(lastMatch);
                            openenings.push(alternator);
                            if (lastMatch.openGroup) { //regexp alt syntax
                                lastMatch.openGroup = false;
                                var alternatorGroup = new MaskToken(true);
                                alternatorGroup.alternatorGroup = true;
                                openenings.push(alternatorGroup);
                            }
                        }
                        break;
                    default:
                        defaultCase();
                }
            }

            while (openenings.length > 0) {
                openingToken = openenings.pop();
                currentToken.matches.push(openingToken);
            }
            if (currentToken.matches.length > 0) {
                verifyGroupMarker(currentToken);
                maskTokens.push(currentToken);
            }

            if (opts.numericInput || opts.isRTL) {
                reverseTokens(maskTokens[0]);
            }
            // console.log(JSON.stringify(maskTokens));
            return maskTokens;
        }
    };

    //apply defaults, definitions, aliases
    Inputmask.extendDefaults = function (options) {
        $.extend(true, Inputmask.prototype.defaults, options);
    };
    Inputmask.extendDefinitions = function (definition) {
        $.extend(true, Inputmask.prototype.definitions, definition);
    };
    Inputmask.extendAliases = function (alias) {
        $.extend(true, Inputmask.prototype.aliases, alias);
    };
    //static fn on inputmask
    Inputmask.format = function (value, options, metadata) {
        return Inputmask(options).format(value, metadata);
    };
    Inputmask.unmask = function (value, options) {
        return Inputmask(options).unmaskedvalue(value);
    };
    Inputmask.isValid = function (value, options) {
        return Inputmask(options).isValid(value);
    };
    Inputmask.remove = function (elems) {
        $.each(elems, function (ndx, el) {
            if (el.inputmask) el.inputmask.remove();
        });
    };
    Inputmask.escapeRegex = function (str) {
        var specials = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"];
        return str.replace(new RegExp("(\\" + specials.join("|\\") + ")", "gim"), "\\$1");
    };
    Inputmask.keyCode = {
        ALT: 18,
        BACKSPACE: 8,
        BACKSPACE_SAFARI: 127,
        CAPS_LOCK: 20,
        COMMA: 188,
        COMMAND: 91,
        COMMAND_LEFT: 91,
        COMMAND_RIGHT: 93,
        CONTROL: 17,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        INSERT: 45,
        LEFT: 37,
        MENU: 93,
        NUMPAD_ADD: 107,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        NUMPAD_ENTER: 108,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_SUBTRACT: 109,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SHIFT: 16,
        SPACE: 32,
        TAB: 9,
        UP: 38,
        WINDOWS: 91,
        X: 88
    };

    function resolveAlias(aliasStr, options, opts) {
        var aliasDefinition = Inputmask.prototype.aliases[aliasStr];
        if (aliasDefinition) {
            if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts); //alias is another alias
            $.extend(true, opts, aliasDefinition); //merge alias definition in the options
            $.extend(true, opts, options); //reapply extra given options
            return true;
        } else //alias not found - try as mask
        if (opts.mask === null) {
            opts.mask = aliasStr;
        }

        return false;
    }

    function generateMaskSet(opts, nocache) {
        function generateMask(mask, metadata, opts) {
            var regexMask = false;
            if (mask === null || mask === "") {
                regexMask = opts.regex !== null;
                if (regexMask) {
                    mask = opts.regex;
                    mask = mask.replace(/^(\^)(.*)(\$)$/, "$2");
                } else {
                    regexMask = true;
                    mask = ".*";
                }
            }
            if (mask.length === 1 && opts.greedy === false && opts.repeat !== 0) {
                opts.placeholder = "";
            } //hide placeholder with single non-greedy mask
            if (opts.repeat > 0 || opts.repeat === "*" || opts.repeat === "+") {
                var repeatStart = opts.repeat === "*" ? 0 : (opts.repeat === "+" ? 1 : opts.repeat);
                mask = opts.groupmarker.start + mask + opts.groupmarker.end + opts.quantifiermarker.start + repeatStart + "," + opts.repeat + opts.quantifiermarker.end;
            }

            // console.log(mask);
            var masksetDefinition,
                maskdefKey = regexMask ? "regex_" + opts.regex : (opts.numericInput ? mask.split("").reverse().join("") : mask);
            if (Inputmask.prototype.masksCache[maskdefKey] === undefined || nocache === true) {
                masksetDefinition = {
                    "mask": mask,
                    "maskToken": Inputmask.prototype.analyseMask(mask, regexMask, opts),
                    "validPositions": {},
                    "_buffer": undefined,
                    "buffer": undefined,
                    "tests": {},
                    "metadata": metadata,
                    maskLength: undefined
                };
                if (nocache !== true) {
                    Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition;
                    masksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);
                }
            } else masksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);

            return masksetDefinition;
        }

        var ms;

        if ($.isFunction(opts.mask)) { //allow mask to be a preprocessing fn - should return a valid mask
            opts.mask = opts.mask(opts);
        }
        if ($.isArray(opts.mask)) {
            if (opts.mask.length > 1) {
                opts.keepStatic = opts.keepStatic === null ? true : opts.keepStatic; //enable by default when passing multiple masks when the option is not explicitly specified
                var altMask = opts.groupmarker.start;
                $.each(opts.numericInput ? opts.mask.reverse() : opts.mask, function (ndx, msk) {
                    if (altMask.length > 1) {
                        altMask += opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start;
                    }
                    if (msk.mask !== undefined && !$.isFunction(msk.mask)) {
                        altMask += msk.mask;
                    } else {
                        altMask += msk;
                    }
                });
                altMask += opts.groupmarker.end;
                // console.log(altMask);
                return generateMask(altMask, opts.mask, opts);
            } else opts.mask = opts.mask.pop();
        }

        if (opts.mask && opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask)) {
            ms = generateMask(opts.mask.mask, opts.mask, opts);
        } else {
            ms = generateMask(opts.mask, opts.mask, opts);
        }

        return ms;
    };


    //masking scope
    //actionObj definition see below
    function maskScope(actionObj, maskset, opts) {
        maskset = maskset || this.maskset;
        opts = opts || this.opts;
        var inputmask = this,
            el = this.el,
            isRTL = this.isRTL,
            undoValue,
            $el,
            skipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround
            skipInputEvent = false, //skip when triggered from within inputmask
            ignorable = false,
            maxLength,
            mouseEnter = false,
            colorMask;

        //maskset helperfunctions
        function getMaskTemplate(baseOnInput, minimalPos, includeMode) {
            //includeMode true => input, undefined => placeholder, false => mask
            minimalPos = minimalPos || 0;
            var maskTemplate = [],
                ndxIntlzr, pos = 0,
                test, testPos, lvp = getLastValidPosition();
            do {
                if (baseOnInput === true && getMaskSet().validPositions[pos]) {
                    testPos = getMaskSet().validPositions[pos];
                    test = testPos.match;
                    ndxIntlzr = testPos.locator.slice();
                    maskTemplate.push(includeMode === true ? testPos.input : includeMode === false ? test.nativeDef : getPlaceholder(pos, test));
                } else {
                    testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
                    test = testPos.match;
                    ndxIntlzr = testPos.locator.slice();
                    if (opts.jitMasking === false || pos < lvp || (typeof opts.jitMasking === "number" && isFinite(opts.jitMasking) && opts.jitMasking > pos)) {
                        maskTemplate.push(includeMode === false ? test.nativeDef : getPlaceholder(pos, test));
                    }
                }
                pos++;
            } while ((maxLength === undefined || pos < maxLength) && (test.fn !== null || test.def !== "") || minimalPos > pos);
            if (maskTemplate[maskTemplate.length - 1] === "") {
                maskTemplate.pop(); //drop the last one which is empty
            }

            getMaskSet().maskLength = pos + 1;
            return maskTemplate;
        }

        function getMaskSet() {
            return maskset;
        }

        function resetMaskSet(soft) {
            var maskset = getMaskSet();
            maskset.buffer = undefined;
            if (soft !== true) {
                // maskset._buffer = undefined;
                maskset.validPositions = {};
                maskset.p = 0;
            }
        }

        function getLastValidPosition(closestTo, strict, validPositions) {
            var before = -1,
                after = -1,
                valids = validPositions || getMaskSet().validPositions; //for use in valhook ~ context switch
            if (closestTo === undefined) closestTo = -1;
            for (var posNdx in valids) {
                var psNdx = parseInt(posNdx);
                if (valids[psNdx] && (strict || valids[psNdx].generatedInput !== true)) {
                    if (psNdx <= closestTo) before = psNdx;
                    if (psNdx >= closestTo) after = psNdx;
                }
            }
            return (before !== -1 && (closestTo - before) > 1) || after < closestTo ? before : after;
        }

        function stripValidPositions(start, end, nocheck, strict) {
            function IsEnclosedStatic(pos) {
                var posMatch = getMaskSet().validPositions[pos];
                if (posMatch !== undefined && posMatch.match.fn === null) {
                    var prevMatch = getMaskSet().validPositions[pos - 1],
                        nextMatch = getMaskSet().validPositions[pos + 1];
                    return prevMatch !== undefined && nextMatch !== undefined;
                }
                return false;
            }

            var i, startPos = start,
                positionsClone = $.extend(true, {}, getMaskSet().validPositions), needsValidation = false;
            getMaskSet().p = start; //needed for alternated position after overtype selection

            for (i = end - 1; i >= startPos; i--) { //clear selection
                if (getMaskSet().validPositions[i] !== undefined) {
                    if (nocheck === true ||
                        ((getMaskSet().validPositions[i].match.optionality || !IsEnclosedStatic(i)) && opts.canClearPosition(getMaskSet(), i, getLastValidPosition(), strict, opts) !== false)) {
                        delete getMaskSet().validPositions[i];
                    }
                }
            }

            //clear buffer
            resetMaskSet(true);
            for (i = startPos + 1; i <= getLastValidPosition();) {
                while (getMaskSet().validPositions[startPos] !== undefined) startPos++;
                if (i < startPos) i = startPos + 1;
                if (getMaskSet().validPositions[i] !== undefined || !isMask(i)) {
                    var t = getTestTemplate(i);
                    if (needsValidation === false && positionsClone[startPos] && positionsClone[startPos].match.def === t.match.def) { //obvious match
                        getMaskSet().validPositions[startPos] = $.extend(true, {}, positionsClone[startPos]);
                        getMaskSet().validPositions[startPos].input = t.input;
                        delete getMaskSet().validPositions[i];
                        i++;
                    } else if (positionCanMatchDefinition(startPos, t.match.def)) {
                        if (isValid(startPos, t.input || getPlaceholder(i), true) !== false) {
                            delete getMaskSet().validPositions[i];
                            i++;
                            needsValidation = true;
                        }
                    } else if (!isMask(i)) {
                        i++;
                        startPos--;
                    }
                    startPos++;
                } else i++;
            }

            resetMaskSet(true);
        }

        function determineTestTemplate(tests, guessNextBest) {
            var testPos,
                testPositions = tests,
                lvp = getLastValidPosition(),
                lvTest = getMaskSet().validPositions[lvp] || getTests(0)[0],
                lvTestAltArr = (lvTest.alternation !== undefined) ? lvTest.locator[lvTest.alternation].toString().split(",") : [];
            for (var ndx = 0; ndx < testPositions.length; ndx++) {
                testPos = testPositions[ndx];

                if (testPos.match &&
                    (((opts.greedy && testPos.match.optionalQuantifier !== true) || (testPos.match.optionality === false || testPos.match.newBlockMarker === false) && testPos.match.optionalQuantifier !== true) &&
                        ((lvTest.alternation === undefined || lvTest.alternation !== testPos.alternation) ||
                            (testPos.locator[lvTest.alternation] !== undefined && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAltArr))))) {

                    if (guessNextBest !== true || (testPos.match.fn === null && !/[0-9a-bA-Z]/.test(testPos.match.def))) {
                        break;
                    }
                }
            }

            return testPos;
        }

        function getTestTemplate(pos, ndxIntlzr, tstPs) {
            return getMaskSet().validPositions[pos] || determineTestTemplate(getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));
        }

        function getTest(pos) {
            if (getMaskSet().validPositions[pos]) {
                return getMaskSet().validPositions[pos];
            }
            return getTests(pos)[0];
        }

        function positionCanMatchDefinition(pos, def) {
            var valid = false,
                tests = getTests(pos);
            for (var tndx = 0; tndx < tests.length; tndx++) {
                if (tests[tndx].match && tests[tndx].match.def === def) {
                    valid = true;
                    break;
                }
            }
            return valid;
        }


        function getTests(pos, ndxIntlzr, tstPs) {
            var maskTokens = getMaskSet().maskToken,
                testPos = ndxIntlzr ? tstPs : 0,
                ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],
                matches = [],
                insertStop = false,
                latestMatch,
                cacheDependency = ndxIntlzr ? ndxIntlzr.join("") : "";

            function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) { //ndxInitializer contains a set of indexes to speedup searches in the mtokens
                function handleMatch(match, loopNdx, quantifierRecurse) {
                    function isFirstMatch(latestMatch, tokenGroup) {
                        var firstMatch = $.inArray(latestMatch, tokenGroup.matches) === 0;
                        if (!firstMatch) {
                            $.each(tokenGroup.matches, function (ndx, match) {
                                if (match.isQuantifier === true) {
                                    firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]);
                                    if (firstMatch) return false;
                                }
                            });
                        }
                        return firstMatch;
                    }

                    function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {
                        var bestMatch, indexPos;

                        if (getMaskSet().validPositions[pos - 1] && targetAlternation && getMaskSet().tests[pos]) { //detect altarnation offset
                            var vpAlternation = getMaskSet().validPositions[pos - 1].locator;
                            var tpAlternation = getMaskSet().tests[pos][0].locator;
                            for (var i = 0; i < targetAlternation; i++) {
                                if (vpAlternation[i] !== tpAlternation[i]) {
                                    return vpAlternation.slice(targetAlternation + 1);
                                }
                            }
                        }

                        if (getMaskSet().tests[pos] || getMaskSet().validPositions[pos]) {
                            $.each(getMaskSet().tests[pos] || [getMaskSet().validPositions[pos]], function (ndx, lmnt) {
                                var alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation,
                                    ndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;
                                if ((indexPos === undefined || ndxPos < indexPos) && ndxPos !== -1) {
                                    bestMatch = lmnt;
                                    indexPos = ndxPos;
                                }
                            });
                        }
                        return bestMatch ?
                            bestMatch.locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1) :
                            targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;
                    }

                    function definitionCanMatchDefinition(source, target) {
                        return source.match.nativeDef === target.match.nativeDef || source.match.def === target.match.nativeDef || source.match.nativeDef === target.match.def;
                    }

                    function isSubsetOf(source, target) {
                        if (source.match.fn !== null && target.match.fn !== null) {//is regex a subset
                            //do we need a dfa for this?
                            //currently only a simplistic approach
                            return target.match.fn.test(source.match.def.replace(/[\[\]]/g, ""), getMaskSet(), pos, false, opts, false);
                        }
                        return false;
                    }

                    function staticCanMatchDefinition(source, target) {
                        return source.match.fn === null && target.match.fn !== null ? target.match.fn.test(source.match.def, getMaskSet(), pos, false, opts, false) : false;
                    }

                    if (testPos > 10000) {
                        throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + getMaskSet().mask;
                    }
                    if (testPos === pos && match.matches === undefined) {
                        matches.push({
                            "match": match,
                            "locator": loopNdx.reverse(),
                            "cd": cacheDependency
                        });
                        return true;
                    } else if (match.matches !== undefined) {
                        if (match.isGroup && quantifierRecurse !== match) { //when a group pass along to the quantifier
                            match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx);
                            if (match) return true;
                        } else if (match.isOptional) {
                            var optionalToken = match;
                            match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);
                            if (match) {
                                latestMatch = matches[matches.length - 1].match;
                                if (isFirstMatch(latestMatch, optionalToken)) {
                                    insertStop = true; //insert a stop
                                    testPos = pos; //match the position after the group
                                } else return true;
                            }
                        } else if (match.isAlternator) {
                            var alternateToken = match,
                                malternateMatches = [],
                                maltMatches,
                                currentMatches = matches.slice(),
                                loopNdxCnt = loopNdx.length;
                            var altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;
                            if (altIndex === -1 || typeof altIndex === "string") {
                                var currentPos = testPos,
                                    ndxInitializerClone = ndxInitializer.slice(),
                                    altIndexArr = [],
                                    amndx;
                                if (typeof altIndex == "string") {
                                    altIndexArr = altIndex.split(",");
                                } else {
                                    for (amndx = 0; amndx < alternateToken.matches.length; amndx++) {
                                        altIndexArr.push(amndx);
                                    }
                                }
                                for (var ndx = 0; ndx < altIndexArr.length; ndx++) {
                                    amndx = parseInt(altIndexArr[ndx]);
                                    matches = [];
                                    //set the correct ndxInitializer
                                    ndxInitializer = resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice();
                                    match = handleMatch(alternateToken.matches[amndx] || maskToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse) || match;
                                    if (match !== true && match !== undefined && (altIndexArr[altIndexArr.length - 1] < alternateToken.matches.length)) { //no match in the alternations (length mismatch) => look further
                                        var ntndx = $.inArray(match, maskToken.matches) + 1;
                                        if (maskToken.matches.length > ntndx) {
                                            match = handleMatch(maskToken.matches[ntndx], [ntndx].concat(loopNdx.slice(1, loopNdx.length)), quantifierRecurse);
                                            if (match) {
                                                altIndexArr.push(ntndx.toString());
                                                $.each(matches, function (ndx, lmnt) {
                                                    lmnt.alternation = loopNdx.length - 1;
                                                });
                                            }
                                        }
                                    }
                                    maltMatches = matches.slice();
                                    testPos = currentPos;
                                    matches = [];

                                    //fuzzy merge matches
                                    for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
                                        var altMatch = maltMatches[ndx1], dropMatch = false;
                                        altMatch.alternation = altMatch.alternation || loopNdxCnt;
                                        for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {
                                            var altMatch2 = malternateMatches[ndx2];
                                            //verify equality
                                            if (typeof altIndex !== "string" || $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr) !== -1) {
                                                if (definitionCanMatchDefinition(altMatch, altMatch2)) {
                                                    dropMatch = true;
                                                    if (altMatch.alternation === altMatch2.alternation &&
                                                        altMatch2.locator[altMatch2.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) === -1) {
                                                        altMatch2.locator[altMatch2.alternation] = altMatch2.locator[altMatch2.alternation] + "," + altMatch.locator[altMatch.alternation];
                                                        altMatch2.alternation = altMatch.alternation; //we pass the alternation index => used in determineLastRequiredPosition
                                                    }
                                                    if (altMatch.match.nativeDef === altMatch2.match.def) {
                                                        altMatch.locator[altMatch.alternation] = altMatch2.locator[altMatch2.alternation];
                                                        malternateMatches.splice(malternateMatches.indexOf(altMatch2), 1, altMatch);
                                                    }
                                                    break;
                                                } else if (altMatch.match.def === altMatch2.match.def) {
                                                    dropMatch = false;
                                                    break;
                                                } else if (staticCanMatchDefinition(altMatch, altMatch2) || isSubsetOf(altMatch, altMatch2)) {
                                                    // console.log("case 5");
                                                    if (altMatch.alternation === altMatch2.alternation &&
                                                        altMatch.locator[altMatch.alternation].toString().indexOf(altMatch2.locator[altMatch2.alternation].toString().split("")[0]) === -1) {

                                                        //no alternation marker
                                                        altMatch.na = altMatch.na || altMatch.locator[altMatch.alternation].toString();
                                                        if (altMatch.na.indexOf(altMatch.locator[altMatch.alternation].toString().split("")[0]) === -1) {
                                                            altMatch.na = altMatch.na + "," + altMatch.locator[altMatch2.alternation].toString().split("")[0];
                                                        }
                                                        //insert match above general match
                                                        dropMatch = true;
                                                        altMatch.locator[altMatch.alternation] = altMatch2.locator[altMatch2.alternation].toString().split("")[0] + "," + altMatch.locator[altMatch.alternation];
                                                        malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);
                                                    }
                                                    break;
                                                }
                                            }
                                        }
                                        if (!dropMatch) {
                                            malternateMatches.push(altMatch);
                                        }
                                    }
                                }
                                if (typeof altIndex == "string") { //filter matches
                                    malternateMatches = $.map(malternateMatches, function (lmnt, ndx) {
                                        if (isFinite(ndx)) {
                                            var mamatch,
                                                alternation = lmnt.alternation,
                                                altLocArr = lmnt.locator[alternation].toString().split(",");
                                            lmnt.locator[alternation] = undefined;
                                            lmnt.alternation = undefined;

                                            for (var alndx = 0; alndx < altLocArr.length; alndx++) {
                                                mamatch = $.inArray(altLocArr[alndx], altIndexArr) !== -1;
                                                if (mamatch) { //rebuild the locator with valid entries
                                                    if (lmnt.locator[alternation] !== undefined) {
                                                        lmnt.locator[alternation] += ",";
                                                        lmnt.locator[alternation] += altLocArr[alndx];
                                                    } else lmnt.locator[alternation] = parseInt(altLocArr[alndx]);

                                                    lmnt.alternation = alternation;
                                                }
                                            }

                                            if (lmnt.locator[alternation] !== undefined) return lmnt;
                                        }
                                    });
                                }

                                matches = currentMatches.concat(malternateMatches);
                                testPos = pos;
                                insertStop = matches.length > 0; //insert a stopelemnt when there is an alternate - needed for non-greedy option
                                match = malternateMatches.length > 0; //set correct match state

                                //cloneback
                                ndxInitializer = ndxInitializerClone.slice();
                            } else {
                                // if (alternateToken.matches[altIndex]) { //if not in the initial alternation => look further
                                match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);
                                // } else match = false;
                            }
                            if (match) return true;
                        } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) {
                            var qt = match;
                            for (var qndx = (ndxInitializer.length > 0) ? ndxInitializer.shift() : 0; (qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max)) && testPos <= pos; qndx++) {
                                var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];
                                match = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup); //set the tokenGroup as quantifierRecurse marker
                                if (match) {
                                    //get latest match
                                    latestMatch = matches[matches.length - 1].match;
                                    latestMatch.optionalQuantifier = qndx > (qt.quantifier.min - 1);
                                    if (isFirstMatch(latestMatch, tokenGroup)) { //search for next possible match
                                        if (qndx > (qt.quantifier.min - 1)) {
                                            insertStop = true;
                                            testPos = pos; //match the position after the group
                                            break; //stop quantifierloop
                                        } else return true;
                                    } else {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);
                            if (match) return true;
                        }
                    }

                    else {
                        testPos++;
                    }
                }

                for (var tndx = (ndxInitializer.length > 0 ? ndxInitializer.shift() : 0); tndx < maskToken.matches.length; tndx++) {
                    if (maskToken.matches[tndx].isQuantifier !== true) {
                        var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);
                        if (match && testPos === pos) {
                            return match;
                        } else if (testPos > pos) {
                            break;
                        }
                    }
                }
            }

            function mergeLocators(tests) {
                var locator = [];
                if (!$.isArray(tests)) tests = [tests];
                if (tests.length > 0) {
                    if (tests[0].alternation === undefined) {
                        locator = determineTestTemplate(tests.slice()).locator.slice();
                        if (locator.length === 0) locator = tests[0].locator.slice();
                    }
                    else {
                        $.each(tests, function (ndx, tst) {
                            if (tst.def !== "") {
                                if (locator.length === 0) locator = tst.locator.slice();
                                else {
                                    for (var i = 0; i < locator.length; i++) {
                                        if (tst.locator[i] && locator[i].toString().indexOf(tst.locator[i]) === -1) {
                                            locator[i] += "," + tst.locator[i];
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                return locator;
            }

            function filterTests(tests) {
                if (opts.keepStatic && pos > 0) {
                    if (tests.length > 1 + (tests[tests.length - 1].match.def === "" ? 1 : 0)) {
                        if (tests[0].match.optionality !== true &&
                            tests[0].match.optionalQuantifier !== true &&
                            tests[0].match.fn === null && !/[0-9a-bA-Z]/.test(tests[0].match.def)) {
                            if (getMaskSet().validPositions[pos - 1] === undefined) {
                                return [determineTestTemplate(tests)];
                            }
                            else if (getMaskSet().validPositions[pos - 1].alternation === tests[0].alternation) {
                                return [determineTestTemplate(tests)];
                            } else if (getMaskSet().validPositions[pos - 1]) {
                                return [determineTestTemplate(tests)];
                            }
                        }
                    }
                }

                return tests;
            }

            if (pos > -1) {
                if (ndxIntlzr === undefined) { //determine index initializer
                    var previousPos = pos - 1,
                        test;
                    while ((test = getMaskSet().validPositions[previousPos] || getMaskSet().tests[previousPos]) === undefined && previousPos > -1) {
                        previousPos--;
                    }
                    if (test !== undefined && previousPos > -1) {
                        ndxInitializer = mergeLocators(test);
                        cacheDependency = ndxInitializer.join("");
                        testPos = previousPos;
                    }
                }
                if (getMaskSet().tests[pos] && getMaskSet().tests[pos][0].cd === cacheDependency) { //cacheDependency is set on all tests, just check on the first
                    //console.log("cache hit " + pos + " - " + ndxIntlzr);
                    return filterTests(getMaskSet().tests[pos]);
                }
                for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {
                    var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);
                    if ((match && testPos === pos) || testPos > pos) {
                        break;
                    }
                }
            }
            if (matches.length === 0 || insertStop) {
                matches.push({
                    match: {
                        fn: null,
                        cardinality: 0,
                        optionality: true,
                        casing: null,
                        def: "",
                        placeholder: ""
                    },
                    locator: [],
                    cd: cacheDependency
                });
            }

            if (ndxIntlzr !== undefined && getMaskSet().tests[pos]) { //prioritize full tests for caching
                return filterTests($.extend(true, [], matches));
            }
            getMaskSet().tests[pos] = $.extend(true, [], matches); //set a clone to prevent overwriting some props
            // console.log(pos + " - " + JSON.stringify(matches));
            return filterTests(getMaskSet().tests[pos]);
        }

        function getBufferTemplate() {
            if (getMaskSet()._buffer === undefined) {
                //generate template
                getMaskSet()._buffer = getMaskTemplate(false, 1);
                if (getMaskSet().buffer === undefined) {
                    getMaskSet().buffer = getMaskSet()._buffer.slice();
                }
            }
            return getMaskSet()._buffer;
        }

        function getBuffer(noCache) {
            if (getMaskSet().buffer === undefined || noCache === true) {
                getMaskSet().buffer = getMaskTemplate(true, getLastValidPosition(), true);
            }
            return getMaskSet().buffer;
        }

        function refreshFromBuffer(start, end, buffer) {
            var i, p;
            if (start === true) {
                resetMaskSet();
                start = 0;
                end = buffer.length;
            } else {
                for (i = start; i < end; i++) {
                    delete getMaskSet().validPositions[i];
                }
            }
            p = start;
            for (i = start; i < end; i++) {
                resetMaskSet(true); //prevents clobber from the buffer
                if (buffer[i] !== opts.skipOptionalPartCharacter) {
                    var valResult = isValid(p, buffer[i], true, true);
                    if (valResult !== false) {
                        resetMaskSet(true);
                        p = valResult.caret !== undefined ? valResult.caret : valResult.pos + 1;
                    }
                }
            }
        }

        function casing(elem, test, pos) {
            switch (opts.casing || test.casing) {
                case "upper":
                    elem = elem.toUpperCase();
                    break;
                case "lower":
                    elem = elem.toLowerCase();
                    break;
                case "title":
                    var posBefore = getMaskSet().validPositions[pos - 1];
                    if (pos === 0 || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE)) {
                        elem = elem.toUpperCase();
                    } else {
                        elem = elem.toLowerCase();
                    }
                    break;
                default:
                    if ($.isFunction(opts.casing)) {
                        var args = Array.prototype.slice.call(arguments);
                        args.push(getMaskSet().validPositions);
                        elem = opts.casing.apply(this, args);
                    }
            }

            return elem;
        }

        function checkAlternationMatch(altArr1, altArr2, na) {
            var altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1),
                isMatch = false, naArr = na !== undefined ? na.split(",") : [],
                naNdx;

            //remove no alternate indexes from alternation array
            for (var i = 0; i < naArr.length; i++) {
                if ((naNdx = altArr1.indexOf(naArr[i])) !== -1) {
                    altArr1.splice(naNdx, 1);
                }
            }

            for (var alndx = 0; alndx < altArr1.length; alndx++) {
                if ($.inArray(altArr1[alndx], altArrC) !== -1) {
                    isMatch = true;
                    break;
                }
            }
            return isMatch;
        }

        function isValid(pos, c, strict, fromSetValid, fromAlternate, validateOnly) { //strict true ~ no correction or autofill
            function isSelection(posObj) {
                var selection = isRTL ? (posObj.begin - posObj.end) > 1 || ((posObj.begin - posObj.end) === 1) :
                    (posObj.end - posObj.begin) > 1 || ((posObj.end - posObj.begin) === 1);

                return selection && posObj.begin === 0 && posObj.end === getMaskSet().maskLength ? "full" : selection;
            }

            strict = strict === true; //always set a value to strict to prevent possible strange behavior in the extensions

            var maskPos = pos;
            if (pos.begin !== undefined) { //position was a position object - used to handle a delete by typing over a selection
                maskPos = isRTL && !isSelection(pos) ? pos.end : pos.begin;
            }

            function _isValid(position, c, strict) {
                var rslt = false;
                $.each(getTests(position), function (ndx, tst) {
                        var test = tst.match,
                            loopend = c ? 1 : 0,
                            chrs = "";
                        for (var i = test.cardinality; i > loopend; i--) {
                            chrs += getBufferElement(position - (i - 1));
                        }
                        if (c) {
                            chrs += c;
                        }

                        //make sure the buffer is set and correct
                        getBuffer(true);
                        //return is false or a json object => { pos: ??, c: ??} or true
                        rslt = test.fn != null ?
                            test.fn.test(chrs, getMaskSet(), position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && test.def !== "" ? //non mask
                                {
                                    c: getPlaceholder(position, test, true) || test.def,
                                    pos: position
                                } : false;

                        if (rslt !== false) {
                            var elem = rslt.c !== undefined ? rslt.c : c;
                            elem = (elem === opts.skipOptionalPartCharacter && test.fn === null) ?
                                (getPlaceholder(position, test, true) || test.def) : elem;

                            var validatedPos = position,
                                possibleModifiedBuffer = getBuffer();

                            if (rslt.remove !== undefined) { //remove position(s)
                                if (!$.isArray(rslt.remove)) rslt.remove = [rslt.remove];
                                $.each(rslt.remove.sort(function (a, b) {
                                    return b - a;
                                }), function (ndx, lmnt) {
                                    stripValidPositions(lmnt, lmnt + 1, true);
                                });
                            }
                            if (rslt.insert !== undefined) { //insert position(s)
                                if (!$.isArray(rslt.insert)) rslt.insert = [rslt.insert];
                                $.each(rslt.insert.sort(function (a, b) {
                                    return a - b;
                                }), function (ndx, lmnt) {
                                    isValid(lmnt.pos, lmnt.c, true, fromSetValid);
                                });
                            }

                            if (rslt.refreshFromBuffer) {
                                var refresh = rslt.refreshFromBuffer;
                                // strict = true;
                                refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, possibleModifiedBuffer);
                                if (rslt.pos === undefined && rslt.c === undefined) {
                                    rslt.pos = getLastValidPosition();
                                    return false; //breakout if refreshFromBuffer && nothing to insert
                                }
                                validatedPos = rslt.pos !== undefined ? rslt.pos : position;
                                if (validatedPos !== position) {
                                    rslt = $.extend(rslt, isValid(validatedPos, elem, true, fromSetValid)); //revalidate new position strict
                                    return false;
                                }

                            } else if (rslt !== true && rslt.pos !== undefined && rslt.pos !== position) { //their is a position offset
                                validatedPos = rslt.pos;
                                refreshFromBuffer(position, validatedPos, getBuffer().slice());
                                if (validatedPos !== position) {
                                    rslt = $.extend(rslt, isValid(validatedPos, elem, true)); //revalidate new position strict
                                    return false;
                                }
                            }

                            if (rslt !== true && rslt.pos === undefined && rslt.c === undefined) {
                                return false; //breakout if nothing to insert
                            }

                            if (ndx > 0) {
                                resetMaskSet(true);
                            }

                            if (!setValidPosition(validatedPos, $.extend({}, tst, {
                                    "input": casing(elem, test, validatedPos)
                                }), fromSetValid, isSelection(pos))) {
                                rslt = false;
                            }
                            return false; //break from $.each
                        }
                    }
                );
                return rslt;
            }

            function alternate(pos, c, strict) {
                var validPsClone = $.extend(true, {}, getMaskSet().validPositions),
                    lastAlt,
                    alternation,
                    isValidRslt = false,
                    altPos, prevAltPos, i, validPos, lAltPos = getLastValidPosition(), altNdxs, decisionPos;
                //find last modified alternation
                prevAltPos = getMaskSet().validPositions[lAltPos];
                for (; lAltPos >= 0; lAltPos--) {
                    altPos = getMaskSet().validPositions[lAltPos];
                    if (altPos && altPos.alternation !== undefined) {
                        lastAlt = lAltPos;
                        alternation = getMaskSet().validPositions[lastAlt].alternation;
                        if (prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) {
                            break;
                        }
                        prevAltPos = altPos;
                    }
                }
                if (alternation !== undefined) {
                    decisionPos = parseInt(lastAlt);
                    var decisionTaker = prevAltPos.locator[prevAltPos.alternation || alternation] !== undefined ? prevAltPos.locator[prevAltPos.alternation || alternation] : altNdxs[0]; //no match in the alternations (length mismatch)
                    if (decisionTaker.length > 0) { //no decision taken ~ take first one as decider
                        decisionTaker = decisionTaker.split(",")[0];
                    }
                    var possibilityPos = getMaskSet().validPositions[decisionPos],
                        prevPos = getMaskSet().validPositions[decisionPos - 1];
                    $.each(getTests(decisionPos, prevPos ? prevPos.locator : undefined, decisionPos - 1), function (ndx, test) {
                        altNdxs = test.locator[alternation] ? test.locator[alternation].toString().split(",") : [];
                        for (var mndx = 0; mndx < altNdxs.length; mndx++) {
                            var validInputs = [],
                                staticInputsBeforePos = 0,
                                staticInputsBeforePosAlternate = 0,
                                verifyValidInput = false;
                            if (decisionTaker < altNdxs[mndx] && (test.na === undefined || ($.inArray(altNdxs[mndx], test.na.split(",")) === -1 || $.inArray(decisionTaker.toString(), altNdxs) === -1))) {
                                getMaskSet().validPositions[decisionPos] = $.extend(true, {}, test);
                                var possibilities = getMaskSet().validPositions[decisionPos].locator;
                                getMaskSet().validPositions[decisionPos].locator[alternation] = parseInt(altNdxs[mndx]); //set forced decision
                                if (test.match.fn == null) {
                                    if (possibilityPos.input !== test.match.def) {
                                        verifyValidInput = true; //verify that the new definition matches the input
                                        if (possibilityPos.generatedInput !== true) {
                                            validInputs.push(possibilityPos.input);
                                        }
                                    }
                                    staticInputsBeforePosAlternate++;
                                    getMaskSet().validPositions[decisionPos].generatedInput = !/[0-9a-bA-Z]/.test(test.match.def);
                                    getMaskSet().validPositions[decisionPos].input = test.match.def;
                                } else {
                                    getMaskSet().validPositions[decisionPos].input = possibilityPos.input;
                                }
                                for (i = decisionPos + 1; i < getLastValidPosition(undefined, true) + 1; i++) {
                                    validPos = getMaskSet().validPositions[i];
                                    if (validPos && validPos.generatedInput !== true && /[0-9a-bA-Z]/.test(validPos.input)) {
                                        validInputs.push(validPos.input);
                                    } else if (i < pos) staticInputsBeforePos++;
                                    delete getMaskSet().validPositions[i];
                                }
                                if (verifyValidInput && validInputs[0] === test.match.def) {
                                    validInputs.shift();
                                }
                                resetMaskSet(true); //clear getbuffer
                                isValidRslt = true;
                                while (validInputs.length > 0) {
                                    var input = validInputs.shift();
                                    if (input !== opts.skipOptionalPartCharacter) {
                                        if (!(isValidRslt = isValid(getLastValidPosition(undefined, true) + 1, input, false, fromSetValid, true))) {
                                            break;
                                        }
                                    }
                                }

                                if (isValidRslt) {
                                    getMaskSet().validPositions[decisionPos].locator = possibilities; //reset forceddecision ~ needed for proper delete
                                    var targetLvp = getLastValidPosition(pos) + 1;
                                    for (i = decisionPos + 1; i < getLastValidPosition() + 1; i++) {
                                        validPos = getMaskSet().validPositions[i];
                                        if ((validPos === undefined || validPos.match.fn == null) && i < (pos + (staticInputsBeforePosAlternate - staticInputsBeforePos))) {
                                            staticInputsBeforePosAlternate++;
                                        }
                                    }
                                    pos = pos + (staticInputsBeforePosAlternate - staticInputsBeforePos);
                                    isValidRslt = isValid(pos > targetLvp ? targetLvp : pos, c, strict, fromSetValid, true);
                                }
                                if (!isValidRslt) {
                                    resetMaskSet();
                                    getMaskSet().validPositions = $.extend(true, {}, validPsClone);
                                } else return false; //exit $.each
                            }
                        }
                    });
                }

                return isValidRslt;
            }

            //set alternator choice on previous skipped placeholder positions
            function trackbackAlternations(originalPos, newPos) {
                var vp = getMaskSet().validPositions[newPos];
                if (vp) {
                    var targetLocator = vp.locator,
                        tll = targetLocator.length;

                    for (var ps = originalPos; ps < newPos; ps++) {
                        if (getMaskSet().validPositions[ps] === undefined && !isMask(ps, true)) {
                            var tests = getTests(ps).slice(),
                                bestMatch = determineTestTemplate(tests, true),
                                equality = -1;
                            if (tests[tests.length - 1].match.def === "") tests.pop();
                            $.each(tests, function (ndx, tst) { //find best matching
                                for (var i = 0; i < tll; i++) {
                                    if (tst.locator[i] !== undefined && checkAlternationMatch(tst.locator[i].toString().split(","), targetLocator[i].toString().split(","), tst.na)) {
                                        if (equality < i) {
                                            equality = i;
                                            bestMatch = tst;
                                        }
                                    } else {
                                        //check if alternationIndex is closer then the current bestmatch
                                        var targetAI = targetLocator[i],
                                            bestMatchAI = bestMatch.locator[i],
                                            tstAI = tst.locator[i];
                                        if ((targetAI - bestMatchAI) > Math.abs(targetAI - tstAI)) {
                                            bestMatch = tst;
                                        }
                                        break;
                                    }
                                }
                            });
                            bestMatch = $.extend({}, bestMatch, {
                                "input": getPlaceholder(ps, bestMatch.match, true) || bestMatch.match.def
                            });
                            bestMatch.generatedInput = true;
                            setValidPosition(ps, bestMatch, true);
                            //revalidate the new position to update the locator value
                            getMaskSet().validPositions[newPos] = undefined;
                            _isValid(newPos, vp.input, true);
                        }
                    }
                }
            }

            function setValidPosition(pos, validTest, fromSetValid, isSelection) {
                if (isSelection || (opts.insertMode && getMaskSet().validPositions[pos] !== undefined && fromSetValid === undefined)) {
                    //reposition & revalidate others
                    var positionsClone = $.extend(true, {}, getMaskSet().validPositions),
                        lvp = getLastValidPosition(undefined, true),
                        i;
                    for (i = pos; i <= lvp; i++) { //clear selection
                        delete getMaskSet().validPositions[i];
                    }
                    getMaskSet().validPositions[pos] = $.extend(true, {}, validTest);
                    var valid = true,
                        j, vps = getMaskSet().validPositions, needsValidation = false,
                        initialLength = getMaskSet().maskLength;
                    for (i = (j = pos); i <= lvp; i++) {
                        var t = positionsClone[i];
                        if (t !== undefined /*&& (t.generatedInput !== true || t.match.fn === null)*/) {
                            var posMatch = j;
                            while (posMatch < getMaskSet().maskLength && ((t.match.fn === null && vps[i] && (vps[i].match.optionalQuantifier === true || vps[i].match.optionality === true)) || t.match.fn != null)) {
                                posMatch++;
                                if (needsValidation === false && positionsClone[posMatch] && positionsClone[posMatch].match.def === t.match.def) { //obvious match
                                    getMaskSet().validPositions[posMatch] = $.extend(true, {}, positionsClone[posMatch]);
                                    getMaskSet().validPositions[posMatch].input = t.input;
                                    fillMissingNonMask(posMatch);
                                    j = posMatch;
                                    valid = true;
                                } else if (positionCanMatchDefinition(posMatch, t.match.def)) { //validated match
                                    var result = isValid(posMatch, t.input, true, true);
                                    valid = result !== false;
                                    j = (result.caret || result.insert) ? getLastValidPosition() : posMatch;
                                    needsValidation = true;
                                } else {
                                    valid = t.generatedInput === true;
                                    if (!valid && posMatch >= getMaskSet().maskLength - 1) break;
                                }
                                if (getMaskSet().maskLength < initialLength) getMaskSet().maskLength = initialLength; //a bit hacky but the masklength is corrected later on
                                if (valid) break;
                            }
                        }
                        if (!valid) break;
                    }

                    if (!valid) {
                        getMaskSet().validPositions = $.extend(true, {}, positionsClone);
                        resetMaskSet(true);
                        return false;
                    }
                }

                else {
                    getMaskSet().validPositions[pos] = $.extend(true, {}, validTest);
                }


                resetMaskSet(true);
                return true;
            }

            var result = true,
                positionsClone = $.extend(true, {}, getMaskSet().validPositions); //clone the currentPositions


            function fillMissingNonMask(maskPos) {
                //Check for a nonmask before the pos
                //find previous valid
                for (var pndx = maskPos - 1; pndx > -1; pndx--) {
                    if (getMaskSet().validPositions[pndx]) break;
                }
                ////fill missing nonmask and valid placeholders
                var testTemplate, testsFromPos;
                for (pndx++; pndx < maskPos; pndx++) {
                    if (getMaskSet().validPositions[pndx] === undefined && (opts.jitMasking === false || opts.jitMasking > pndx)) {
                        testsFromPos = getTests(pndx, getTestTemplate(pndx - 1).locator, pndx - 1).slice();
                        if (testsFromPos[testsFromPos.length - 1].match.def === "") testsFromPos.pop();
                        testTemplate = determineTestTemplate(testsFromPos);
                        if (testTemplate && (testTemplate.match.def === opts.radixPointDefinitionSymbol || !isMask(pndx, true) ||
                                ($.inArray(opts.radixPoint, getBuffer()) < pndx && testTemplate.match.fn && testTemplate.match.fn.test(getPlaceholder(pndx), getMaskSet(), pndx, false, opts)))) {
                            result = _isValid(pndx, getPlaceholder(pndx, testTemplate.match, true) || (testTemplate.match.fn == null ? testTemplate.match.def : (getPlaceholder(pndx) !== "" ? getPlaceholder(pndx) : getBuffer()[pndx])), true);
                            if (result !== false) {
                                getMaskSet().validPositions[result.pos || pndx].generatedInput = true;
                            }
                        }
                    }
                }
            }

            if ($.isFunction(opts.preValidation) && !strict && fromSetValid !== true && validateOnly !== true) {
                result = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts);
            }
            if (result === true) {
                fillMissingNonMask(maskPos);

                if (isSelection(pos)) {
                    handleRemove(undefined, Inputmask.keyCode.DELETE, pos, true, true);
                    maskPos = getMaskSet().p;
                }

                if (maskPos < getMaskSet().maskLength && (maxLength === undefined || maskPos < maxLength)) {
                    result = _isValid(maskPos, c, strict);
                    if ((!strict || fromSetValid === true) && result === false && validateOnly !== true) {
                        var currentPosValid = getMaskSet().validPositions[maskPos];
                        if (currentPosValid && currentPosValid.match.fn === null && (currentPosValid.match.def === c || c === opts.skipOptionalPartCharacter)) {
                            result = {
                                "caret": seekNext(maskPos)
                            };
                        } else if ((opts.insertMode || getMaskSet().validPositions[seekNext(maskPos)] === undefined) && !isMask(maskPos, true)) { //does the input match on a further position?
                            for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) {
                                // if (!isMask(nPos, true)) {
                                // 	continue;
                                // }
                                result = _isValid(nPos, c, strict);
                                if (result !== false) {
                                    trackbackAlternations(maskPos, result.pos !== undefined ? result.pos : nPos);
                                    maskPos = nPos;
                                    break;
                                }
                            }
                        }
                    }
                }
                if (result === false && opts.keepStatic && !strict && fromAlternate !== true) { //try fuzzy alternator logic
                    result = alternate(maskPos, c, strict);
                }
                if (result === true) {
                    result = {
                        "pos": maskPos
                    };
                }
            }
            if ($.isFunction(opts.postValidation) && result !== false && !strict && fromSetValid !== true && validateOnly !== true) {
                var postResult = opts.postValidation(getBuffer(true), result, opts);
                if (postResult.refreshFromBuffer && postResult.buffer) {
                    var refresh = postResult.refreshFromBuffer;
                    refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, postResult.buffer);
                }
                result = postResult === true ? result : postResult;
            }

            if (result && result.pos === undefined) {
                result.pos = maskPos;
            }

            if (result === false || validateOnly === true) {
                resetMaskSet(true);
                getMaskSet().validPositions = $.extend(true, {}, positionsClone); //revert validation changes
            }

            return result;
        }

        function isMask(pos, strict) {
            var test = getTestTemplate(pos).match;
            if (test.def === "") test = getTest(pos).match;

            if (test.fn != null) {
                return test.fn;
            }
            if (strict !== true && pos > -1) {
                var tests = getTests(pos);
                return tests.length > 1 + (tests[tests.length - 1].match.def === "" ? 1 : 0);
            }
            return false;
        }

        function seekNext(pos, newBlock) {
            var maskL = getMaskSet().maskLength;
            if (pos >= maskL) return maskL;
            var position = pos;
            if (getTests(maskL + 1).length > 1) {
                getMaskTemplate(true, maskL + 1, true);
                maskL = getMaskSet().maskLength;
            }
            while (++position < maskL &&
            ((newBlock === true && (getTest(position).match.newBlockMarker !== true || !isMask(position))) ||
                (newBlock !== true && !isMask(position)))) {
            }
            return position;
        }

        function seekPrevious(pos, newBlock) {
            var position = pos, tests;
            if (position <= 0) return 0;

            while (--position > 0 &&
            ((newBlock === true && getTest(position).match.newBlockMarker !== true) ||
                (newBlock !== true && !isMask(position) &&
                    (tests = getTests(position), tests.length < 2 || (tests.length === 2 && tests[1].match.def === ""))))) {
            }

            return position;
        }

        function getBufferElement(position) {
            return getMaskSet().validPositions[position] === undefined ? getPlaceholder(position) : getMaskSet().validPositions[position].input;
        }

        function writeBuffer(input, buffer, caretPos, event, triggerInputEvent) {
            if (event && $.isFunction(opts.onBeforeWrite)) {
                //    buffer = buffer.slice(); //prevent uncontrolled manipulation of the internal buffer
                var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);
                if (result) {
                    if (result.refreshFromBuffer) {
                        var refresh = result.refreshFromBuffer;
                        refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, result.buffer || buffer);
                        buffer = getBuffer(true);
                    }
                    //only alter when intented !== undefined
                    if (caretPos !== undefined) caretPos = result.caret !== undefined ? result.caret : caretPos;
                }
            }
            if (input !== undefined) {
                input.inputmask._valueSet(buffer.join(""));
                if (caretPos !== undefined && (event === undefined || event.type !== "blur")) {
                    if (android && event && event.type === "input") {
                        setTimeout(function () {
                            caret(input, caretPos);
                        }, 0);
                    } else caret(input, caretPos);
                } else renderColorMask(input, caretPos, buffer.length === 0);
                if (triggerInputEvent === true) {
                    skipInputEvent = true;
                    $(input).trigger("input");
                }
            }
        }

        function getPlaceholder(pos, test, returnPL) {
            test = test || getTest(pos).match;
            if (test.placeholder !== undefined || returnPL === true) {
                return $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;
            } else if (test.fn === null) {
                if (pos > -1 && getMaskSet().validPositions[pos] === undefined) {
                    var tests = getTests(pos),
                        staticAlternations = [],
                        prevTest;
                    if (tests.length > 1 + (tests[tests.length - 1].match.def === "" ? 1 : 0)) {
                        for (var i = 0; i < tests.length; i++) {
                            if (tests[i].match.optionality !== true && tests[i].match.optionalQuantifier !== true &&
                                (tests[i].match.fn === null || (prevTest === undefined || tests[i].match.fn.test(prevTest.match.def, getMaskSet(), pos, true, opts) !== false))) {
                                staticAlternations.push(tests[i]);
                                if (tests[i].match.fn === null) prevTest = tests[i];
                                if (staticAlternations.length > 1) {
                                    if (/[0-9a-bA-Z]/.test(staticAlternations[0].match.def)) {
                                        return opts.placeholder.charAt(pos % opts.placeholder.length);
                                    }
                                }
                            }
                        }
                    }
                }
                return test.def;
            }

            return opts.placeholder.charAt(pos % opts.placeholder.length);
        }

        var EventRuler = {
            on: function (input, eventName, eventHandler) {
                var ev = function (e) {
                    // console.log("triggered " + e.type);

                    if (this.inputmask === undefined && this.nodeName !== "FORM") { //happens when cloning an object with jquery.clone
                        var imOpts = $.data(this, "_inputmask_opts");
                        if (imOpts) (new Inputmask(imOpts)).mask(this);
                        else EventRuler.off(this);
                    } else if (e.type !== "setvalue" && this.nodeName !== "FORM" && (this.disabled || (this.readOnly && !(e.type === "keydown" && (e.ctrlKey && e.keyCode === 67) || (opts.tabThrough === false && e.keyCode === Inputmask.keyCode.TAB))))) {
                        e.preventDefault();
                    } else {
                        switch (e.type) {
                            case "input":
                                if (skipInputEvent === true) {
                                    skipInputEvent = false;
                                    return e.preventDefault();
                                }
                                break;
                            case "keydown":
                                //Safari 5.1.x - modal dialog fires keypress twice workaround
                                skipKeyPressEvent = false;
                                skipInputEvent = false;
                                break;
                            case "keypress":
                                if (skipKeyPressEvent === true) {
                                    return e.preventDefault();
                                }
                                skipKeyPressEvent = true;
                                break;
                            case "click":
                                if (iemobile || iphone) {
                                    var that = this, args = arguments;
                                    setTimeout(function () {
                                        eventHandler.apply(that, args);
                                    }, 0);
                                    return false;
                                }
                                break;
                        }
                        // console.log("executed " + e.type);
                        var returnVal = eventHandler.apply(this, arguments);
                        if (returnVal === false) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        return returnVal;
                    }
                };
                //keep instance of the event
                input.inputmask.events[eventName] = input.inputmask.events[eventName] || [];
                input.inputmask.events[eventName].push(ev);

                if ($.inArray(eventName, ["submit", "reset"]) !== -1) {
                    if (input.form !== null) $(input.form).on(eventName, ev);
                } else {
                    $(input).on(eventName, ev);
                }
            },
            off: function (input, event) {
                if (input.inputmask && input.inputmask.events) {
                    var events;
                    if (event) {
                        events = [];
                        events[event] = input.inputmask.events[event];
                    } else {
                        events = input.inputmask.events;
                    }
                    $.each(events, function (eventName, evArr) {
                        while (evArr.length > 0) {
                            var ev = evArr.pop();
                            if ($.inArray(eventName, ["submit", "reset"]) !== -1) {
                                if (input.form !== null) $(input.form).off(eventName, ev);
                            } else {
                                $(input).off(eventName, ev);
                            }
                        }
                        delete input.inputmask.events[eventName];
                    });
                }
            }
        };
        var EventHandlers = {
            keydownEvent: function (e) {
                function isInputEventSupported(eventName) {
                    var el = document.createElement("input"),
                        evName = "on" + eventName,
                        isSupported = (evName in el);
                    if (!isSupported) {
                        el.setAttribute(evName, "return;");
                        isSupported = typeof el[evName] === "function";
                    }
                    el = null;
                    return isSupported;
                }

                var input = this,
                    $input = $(input),
                    k = e.keyCode,
                    pos = caret(input);

                //backspace, delete, and escape get special treatment
                if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || (iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI) || (e.ctrlKey && k === Inputmask.keyCode.X && !isInputEventSupported("cut"))) { //backspace/delete
                    e.preventDefault(); //stop default action but allow propagation
                    handleRemove(input, k, pos);
                    writeBuffer(input, getBuffer(true), getMaskSet().p, e, input.inputmask._valueGet() !== getBuffer().join(""));
                    if (input.inputmask._valueGet() === getBufferTemplate().join("")) {
                        $input.trigger("cleared");
                    } else if (isComplete(getBuffer()) === true) {
                        $input.trigger("complete");
                    }
                } else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch
                    e.preventDefault();
                    var caretPos = seekNext(getLastValidPosition());
                    if (!opts.insertMode && caretPos === getMaskSet().maskLength && !e.shiftKey) caretPos--;
                    caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, true);
                } else if ((k === Inputmask.keyCode.HOME && !e.shiftKey) || k === Inputmask.keyCode.PAGE_UP) { //Home or page_up
                    e.preventDefault();
                    caret(input, 0, e.shiftKey ? pos.begin : 0, true);
                } else if (((opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE) || (k === 90 && e.ctrlKey)) && e.altKey !== true) { //escape && undo && #762
                    checkVal(input, true, false, undoValue.split(""));
                    $input.trigger("click");
                } else if (k === Inputmask.keyCode.INSERT && !(e.shiftKey || e.ctrlKey)) { //insert
                    opts.insertMode = !opts.insertMode;
                    caret(input, !opts.insertMode && pos.begin === getMaskSet().maskLength ? pos.begin - 1 : pos.begin);
                } else if (opts.tabThrough === true && k === Inputmask.keyCode.TAB) {
                    if (e.shiftKey === true) {
                        if (getTest(pos.begin).match.fn === null) {
                            pos.begin = seekNext(pos.begin);
                        }
                        pos.end = seekPrevious(pos.begin, true);
                        pos.begin = seekPrevious(pos.end, true);
                    } else {
                        pos.begin = seekNext(pos.begin, true);
                        pos.end = seekNext(pos.begin, true);
                        if (pos.end < getMaskSet().maskLength) pos.end--;
                    }
                    if (pos.begin < getMaskSet().maskLength) {
                        e.preventDefault();
                        caret(input, pos.begin, pos.end);
                    }
                } else if (!e.shiftKey) {
                    if (opts.insertMode === false) {
                        if (k === Inputmask.keyCode.RIGHT) {
                            setTimeout(function () {
                                var caretPos = caret(input);
                                caret(input, caretPos.begin);
                            }, 0);
                        } else if (k === Inputmask.keyCode.LEFT) {
                            setTimeout(function () {
                                var caretPos = caret(input);
                                caret(input, isRTL ? caretPos.begin + 1 : caretPos.begin - 1);
                            }, 0);
                        }
                    }
                }
                opts.onKeyDown.call(this, e, getBuffer(), caret(input).begin, opts);
                ignorable = $.inArray(k, opts.ignorables) !== -1;
            },
            keypressEvent: function (e, checkval, writeOut, strict, ndx) {
                var input = this,
                    $input = $(input),
                    k = e.which || e.charCode || e.keyCode;

                if (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {
                    if (k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join("")) {
                        undoValue = getBuffer().join("");
                        // e.preventDefault();
                        setTimeout(function () {
                            $input.trigger("change");
                        }, 0);
                    }
                    return true;
                } else {
                    if (k) {
                        //special treat the decimal separator
                        if (k === 46 && e.shiftKey === false && opts.radixPoint !== "") k = opts.radixPoint.charCodeAt(0);
                        var pos = checkval ? {
                                begin: ndx,
                                end: ndx
                            } : caret(input),
                            forwardPosition, c = String.fromCharCode(k);

                        getMaskSet().writeOutBuffer = true;
                        var valResult = isValid(pos, c, strict);
                        if (valResult !== false) {
                            resetMaskSet(true);
                            forwardPosition = valResult.caret !== undefined ? valResult.caret : checkval ? valResult.pos + 1 : seekNext(valResult.pos);
                            getMaskSet().p = forwardPosition; //needed for checkval
                        }

                        if (writeOut !== false) {
                            setTimeout(function () {
                                opts.onKeyValidation.call(input, k, valResult, opts);
                            }, 0);
                            if (getMaskSet().writeOutBuffer && valResult !== false) {
                                var buffer = getBuffer();
                                writeBuffer(input, buffer, (opts.numericInput && valResult.caret === undefined) ? seekPrevious(forwardPosition) : forwardPosition, e, checkval !== true);
                                if (checkval !== true) {
                                    setTimeout(function () { //timeout needed for IE
                                        if (isComplete(buffer) === true) $input.trigger("complete");
                                    }, 0);
                                }
                            }
                        }

                        e.preventDefault();

                        if (checkval) {
                            if (valResult !== false) valResult.forwardPosition = forwardPosition;
                            return valResult;
                        }
                    }
                }
            },
            pasteEvent: function (e) {
                var input = this,
                    ev = e.originalEvent || e,
                    $input = $(input),
                    inputValue = input.inputmask._valueGet(true),
                    caretPos = caret(input),
                    tempValue;

                // console.log(inputValue);

                if (isRTL) {
                    tempValue = caretPos.end;
                    caretPos.end = caretPos.begin;
                    caretPos.begin = tempValue;
                }

                var valueBeforeCaret = inputValue.substr(0, caretPos.begin),
                    valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);

                if (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join("")) valueBeforeCaret = "";
                if (valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join("")) valueAfterCaret = "";
                if (isRTL) {
                    tempValue = valueBeforeCaret;
                    valueBeforeCaret = valueAfterCaret;
                    valueAfterCaret = tempValue;
                }

                if (window.clipboardData && window.clipboardData.getData) { // IE
                    inputValue = valueBeforeCaret + window.clipboardData.getData("Text") + valueAfterCaret;
                } else if (ev.clipboardData && ev.clipboardData.getData) {
                    inputValue = valueBeforeCaret + ev.clipboardData.getData("text/plain") + valueAfterCaret;
                } else return true; //allow native paste event as fallback ~ masking will continue by inputfallback

                var pasteValue = inputValue;
                // console.log(inputValue);
                if ($.isFunction(opts.onBeforePaste)) {
                    pasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts);
                    if (pasteValue === false) {
                        return e.preventDefault();
                    }
                    if (!pasteValue) {
                        pasteValue = inputValue;
                    }
                }
                checkVal(input, false, false, isRTL ? pasteValue.split("").reverse() : pasteValue.toString().split(""));
                writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join(""));
                if (isComplete(getBuffer()) === true) {
                    $input.trigger("complete");
                }

                return e.preventDefault();
            },
            inputFallBackEvent: function (e) { //fallback when keypress is not triggered
                function repositionCaret(input, frontPart, backPart) {
                    var targetPos = caret(input).begin, currentValue = input.inputmask._valueGet(),
                        pos = currentValue.indexOf(frontPart), currentPos = targetPos;
                    if (pos === 0 && targetPos !== frontPart.length) {
                        targetPos = frontPart.length;
                    } else {
                        while (currentValue.match(Inputmask.escapeRegex(backPart) + "$") === null) {
                            backPart = backPart.substr(1);
                        }
                        var pos2 = currentValue.indexOf(backPart);
                        if (pos2 !== -1 && backPart !== "" && targetPos > pos2 && pos2 > pos) {
                            targetPos = pos2;
                        }
                    }

                    if (!isMask(targetPos)) targetPos = seekNext(targetPos);
                    if (currentPos !== targetPos) {
                        caret(input, targetPos);
                        if (android) { //caret is set by android after inputevent
                            setTimeout(function () {
                                caret(input, targetPos);
                            }, 0);
                        }
                    }
                }

                function radixPointHandler(input, inputValue, caretPos) {
                    //radixpoint tweak
                    if (inputValue.charAt(caretPos.begin - 1) === "." && opts.radixPoint !== "") {
                        inputValue = inputValue.split("");
                        inputValue[caretPos.begin - 1] = opts.radixPoint.charAt(0);
                        inputValue = inputValue.join("");
                    }

                    if (inputValue.charAt(caretPos.begin - 1) === opts.radixPoint && inputValue.length > getBuffer().length) {
                        var keypress = new $.Event("keypress");
                        keypress.which = opts.radixPoint.charCodeAt(0);
                        EventHandlers.keypressEvent.call(input, keypress, true, true, false, caretPos.begin - 1);
                        return false;

                    }
                }

                function ieMobileHandler(input, inputValue, caretPos) {
                    if (iemobile) { //iemobile just set the character at the end althought the caret position is correctly set
                        var inputChar = inputValue.replace(getBuffer().join(""), "");
                        if (inputChar.length === 1) {
                            var keypress = new $.Event("keypress");
                            keypress.which = inputChar.charCodeAt(0);
                            EventHandlers.keypressEvent.call(input, keypress, true, true, false, getMaskSet().validPositions[caretPos.begin - 1] ? caretPos.begin : caretPos.begin - 1);
                            return false;
                        }
                    }
                }

                var input = this,
                    inputValue = input.inputmask._valueGet();

                if (getBuffer().join("") !== inputValue) {
                    var caretPos = caret(input);
                    if (radixPointHandler(input, inputValue, caretPos) === false) return false;
                    inputValue = inputValue.replace(new RegExp("(" + Inputmask.escapeRegex(getBufferTemplate().join("")) + ")*"), "");
                    if (ieMobileHandler(input, inputValue, caretPos) === false) return false;

                    if (caretPos.begin > inputValue.length) {
                        caret(input, inputValue.length);
                        caretPos = caret(input);
                    }

                    var buffer = getBuffer().join(""),
                        frontPart = inputValue.substr(0, caretPos.begin),
                        backPart = inputValue.substr(caretPos.begin),
                        frontBufferPart = buffer.substr(0, caretPos.begin),
                        backBufferPart = buffer.substr(caretPos.begin);

                    //check if thare was a selection
                    var selection = caretPos, entries = "", isEntry = false;
                    if (frontPart !== frontBufferPart) {
                        selection.begin = 0;
                        var fpl = (isEntry = frontPart.length >= frontBufferPart.length) ? frontPart.length : frontBufferPart.length
                        for (var i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < fpl; i++) {
                            selection.begin++;
                        }
                        if (isEntry) {
                            entries += frontPart.slice(selection.begin, selection.end);
                        }
                    }
                    if (backPart !== backBufferPart) {
                        if (backPart.length > backBufferPart.length) {
                            if (isEntry) {
                                selection.end = selection.begin;
                            }
                        } else {
                            if (backPart.length < backBufferPart.length) {
                                selection.end += backBufferPart.length - backPart.length;
                            }
                            else if (backPart.charAt(0) !== backBufferPart.charAt(0)) {
                                selection.end++;
                            }
                        }
                    }

                    writeBuffer(input, getBuffer(), selection);
                    if (entries.length > 0) {
                        $.each(entries.split(""), function (ndx, entry) {
                            var keypress = new $.Event("keypress");
                            keypress.which = entry.charCodeAt(0);
                            ignorable = false; //make sure ignorable is ignored ;-)
                            EventHandlers.keypressEvent.call(input, keypress);
                        });
                    } else {
                        if (selection.begin === selection.end - 1) {
                            caret(input, seekPrevious(selection.begin + 1), selection.end);
                        }
                        e.keyCode = Inputmask.keyCode.DELETE;
                        EventHandlers.keydownEvent.call(input, e);
                    }

                    e.preventDefault();
                }
            },
            setValueEvent: function (e) {
                this.inputmask.refreshValue = false;
                var input = this,
                    value = input.inputmask._valueGet(true);

                if ($.isFunction(opts.onBeforeMask)) value = opts.onBeforeMask.call(inputmask, value, opts) || value;
                value = value.split("");
                checkVal(input, true, false, isRTL ? value.reverse() : value);
                undoValue = getBuffer().join("");
                if ((opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join("")) {
                    input.inputmask._valueSet("");
                }
            }

            ,
            focusEvent: function (e) {
                var input = this,
                    nptValue = input.inputmask._valueGet();
                if (opts.showMaskOnFocus && (!opts.showMaskOnHover || (opts.showMaskOnHover && nptValue === ""))) {
                    if (input.inputmask._valueGet() !== getBuffer().join("")) {
                        writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()));
                    } else if (mouseEnter === false) { //only executed on focus without mouseenter
                        caret(input, seekNext(getLastValidPosition()));
                    }
                }
                if (opts.positionCaretOnTab === true && mouseEnter === false && nptValue !== "") {
                    writeBuffer(input, getBuffer(), caret(input));
                    EventHandlers.clickEvent.apply(input, [e, true]);
                }
                undoValue = getBuffer().join("");
            }
            ,
            mouseleaveEvent: function (e) {
                var input = this;
                mouseEnter = false;
                if (opts.clearMaskOnLostFocus && document.activeElement !== input) {
                    var buffer = getBuffer().slice(),
                        nptValue = input.inputmask._valueGet();
                    if (nptValue !== input.getAttribute("placeholder") && nptValue !== "") {
                        if (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join("")) {
                            buffer = [];
                        } else { //clearout optional tail of the mask
                            clearOptionalTail(buffer);
                        }
                        writeBuffer(input, buffer);
                    }
                }
            }
            ,
            clickEvent: function (e, tabbed) {
                function doRadixFocus(clickPos) {
                    if (opts.radixPoint !== "") {
                        var vps = getMaskSet().validPositions;
                        if (vps[clickPos] === undefined || (vps[clickPos].input === getPlaceholder(clickPos))) {
                            if (clickPos < seekNext(-1)) return true;
                            var radixPos = $.inArray(opts.radixPoint, getBuffer());
                            if (radixPos !== -1) {
                                for (var vp in vps) {
                                    if (radixPos < vp && vps[vp].input !== getPlaceholder(vp)) {
                                        return false;
                                    }
                                }
                                return true;
                            }
                        }
                    }
                    return false;
                }

                var input = this;
                setTimeout(function () { //needed for Chrome ~ initial selection clears after the clickevent
                    if (document.activeElement === input) {
                        var selectedCaret = caret(input);
                        if (tabbed) {
                            if (isRTL) {
                                selectedCaret.end = selectedCaret.begin;
                            }
                            else {
                                selectedCaret.begin = selectedCaret.end;
                            }
                        }
                        if (selectedCaret.begin === selectedCaret.end) {
                            switch (opts.positionCaretOnClick) {
                                case "none":
                                    break;
                                case "radixFocus":
                                    if (doRadixFocus(selectedCaret.begin)) {
                                        var radixPos = getBuffer().join("").indexOf(opts.radixPoint);
                                        caret(input, opts.numericInput ? seekNext(radixPos) : radixPos);
                                        break;
                                    }
                                default: //lvp:
                                    var clickPosition = selectedCaret.begin,
                                        lvclickPosition = getLastValidPosition(clickPosition, true),
                                        lastPosition = seekNext(lvclickPosition);
                                    if (clickPosition < lastPosition) {
                                        caret(input, !isMask(clickPosition, true) && !isMask(clickPosition - 1, true) ? seekNext(clickPosition) : clickPosition);
                                    } else {
                                        var lvp = getMaskSet().validPositions[lvclickPosition],
                                            tt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : undefined, lvp),
                                            placeholder = getPlaceholder(lastPosition, tt.match);
                                        if ((placeholder !== "" && getBuffer()[lastPosition] !== placeholder && tt.match.optionalQuantifier !== true && tt.match.newBlockMarker !== true) || (!isMask(lastPosition, true) && tt.match.def === placeholder)) {
                                            var newPos = seekNext(lastPosition);
                                            if (clickPosition >= newPos || clickPosition === lastPosition) {
                                                lastPosition = newPos;
                                            }
                                        }
                                        caret(input, lastPosition);
                                    }
                                    break;
                            }
                        }
                    }
                }, 0);
            }
            ,
            dblclickEvent: function (e) {
                var input = this;
                setTimeout(function () {
                    caret(input, 0, seekNext(getLastValidPosition()));
                }, 0);
            }
            ,
            cutEvent: function (e) {
                var input = this,
                    $input = $(input),
                    pos = caret(input),
                    ev = e.originalEvent || e;

                //correct clipboardData
                var clipboardData = window.clipboardData || ev.clipboardData,
                    clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);
                clipboardData.setData("text", isRTL ? clipData.reverse().join("") : clipData.join(""));
                if (document.execCommand) document.execCommand("copy"); // copy selected content to system clipbaord

                handleRemove(input, Inputmask.keyCode.DELETE, pos);
                writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join(""));

                if (input.inputmask._valueGet() === getBufferTemplate().join("")) {
                    $input.trigger("cleared");
                }
            }
            ,
            blurEvent: function (e) {
                var $input = $(this),
                    input = this;
                if (input.inputmask) {
                    var nptValue = input.inputmask._valueGet(),
                        buffer = getBuffer().slice();

                    if (nptValue !== "") {
                        if (opts.clearMaskOnLostFocus) {
                            if (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join("")) {
                                buffer = [];
                            } else { //clearout optional tail of the mask
                                clearOptionalTail(buffer);
                            }
                        }
                        if (isComplete(buffer) === false) {
                            setTimeout(function () {
                                $input.trigger("incomplete");
                            }, 0);
                            if (opts.clearIncomplete) {
                                resetMaskSet();
                                if (opts.clearMaskOnLostFocus) {
                                    buffer = [];
                                } else {
                                    buffer = getBufferTemplate().slice();
                                }
                            }
                        }

                        writeBuffer(input, buffer, undefined, e);
                    }

                    if (undoValue !== getBuffer().join("")) {
                        undoValue = buffer.join("");
                        $input.trigger("change");
                    }
                }
            }
            ,
            mouseenterEvent: function (e) {
                var input = this;
                mouseEnter = true;
                if (document.activeElement !== input && opts.showMaskOnHover) {
                    if (input.inputmask._valueGet() !== getBuffer().join("")) {
                        writeBuffer(input, getBuffer());
                    }
                }
            }
            ,
            submitEvent: function (e) { //trigger change on submit if any
                if (undoValue !== getBuffer().join("")) {
                    $el.trigger("change");
                }
                if (opts.clearMaskOnLostFocus && getLastValidPosition() === -1 && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join("")) {
                    el.inputmask._valueSet(""); //clear masktemplete on submit and still has focus
                }
                if (opts.removeMaskOnSubmit) {
                    el.inputmask._valueSet(el.inputmask.unmaskedvalue(), true);
                    setTimeout(function () {
                        writeBuffer(el, getBuffer());
                    }, 0);
                }
            }
            ,
            resetEvent: function (e) {
                el.inputmask.refreshValue = true; //indicate a forced refresh when there is a call to the value before leaving the triggering event fn
                setTimeout(function () {
                    $el.trigger("setvalue");
                }, 0);
            }
        };

        function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {
            var inputValue = nptvl.slice(),
                charCodes = "",
                initialNdx = -1, result = undefined;

            // console.log(nptvl);

            function isTemplateMatch(ndx, charCodes) {
                var charCodeNdx = getBufferTemplate().slice(ndx, seekNext(ndx)).join("").indexOf(charCodes);
                return charCodeNdx !== -1 && !isMask(ndx) && getTest(ndx).match.nativeDef === charCodes.charAt(charCodes.length - 1);
            }

            resetMaskSet();
            if (!strict && opts.autoUnmask !== true) {
                var staticInput = getBufferTemplate().slice(0, seekNext(-1)).join(""),
                    matches = inputValue.join("").match(new RegExp("^" + Inputmask.escapeRegex(staticInput), "g"));
                if (matches && matches.length > 0) {
                    inputValue.splice(0, matches.length * staticInput.length);
                    initialNdx = seekNext(initialNdx);
                }
            } else {
                initialNdx = seekNext(initialNdx);
            }
            if (initialNdx === -1) {
                getMaskSet().p = seekNext(initialNdx);
                initialNdx = 0;
            } else getMaskSet().p = initialNdx;
            $.each(inputValue, function (ndx, charCode) {
                // console.log(charCode);
                if (charCode !== undefined) { //inputfallback strips some elements out of the inputarray.  $.each logically presents them as undefined
                    if (getMaskSet().validPositions[ndx] === undefined && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, true) &&
                        isValid(ndx, inputValue[ndx], true, undefined, undefined, true) === false) {
                        getMaskSet().p++;
                    }
                    else {

                        var keypress = new $.Event("_checkval");
                        keypress.which = charCode.charCodeAt(0);
                        charCodes += charCode;
                        var lvp = getLastValidPosition(undefined, true),
                            lvTest = getMaskSet().validPositions[lvp],
                            nextTest = getTestTemplate(lvp + 1, lvTest ? lvTest.locator.slice() : undefined, lvp);
                        if (!isTemplateMatch(initialNdx, charCodes) || strict || opts.autoUnmask) {
                            var pos = strict ? ndx : (nextTest.match.fn == null && nextTest.match.optionality && (lvp + 1) < getMaskSet().p ? lvp + 1 : getMaskSet().p);
                            result = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, pos);
                            initialNdx = pos + 1;
                            charCodes = "";
                        } else {
                            result = EventHandlers.keypressEvent.call(input, keypress, true, false, true, lvp + 1);
                        }
                        if (result !== false && !strict && $.isFunction(opts.onBeforeWrite)) {
                            var origResult = result;
                            result = opts.onBeforeWrite.call(inputmask, keypress, getBuffer(), result.forwardPosition, opts);
                            result = $.extend(origResult, result);
                            if (result && result.refreshFromBuffer) {
                                var refresh = result.refreshFromBuffer;
                                refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, result.buffer);
                                resetMaskSet(true);
                                if (result.caret) {
                                    getMaskSet().p = result.caret;
                                    result.forwardPosition = result.caret;
                                }
                            }
                        }
                    }
                }
            });
            if (writeOut) {
                var caretPos = undefined;
                if (document.activeElement === input && result) {
                    caretPos = opts.numericInput ? seekPrevious(result.forwardPosition) : result.forwardPosition;
                }

                writeBuffer(input, getBuffer(), caretPos, initiatingEvent || new $.Event("checkval"), initiatingEvent && initiatingEvent.type === "input");
            }
        }

        function unmaskedvalue(input) {
            if (input) {
                if (input.inputmask === undefined) {
                    return input.value;
                }
                if (input.inputmask && input.inputmask.refreshValue) { //forced refresh from the value form.reset
                    EventHandlers.setValueEvent.call(input);
                }
            }
            var umValue = [],
                vps = getMaskSet().validPositions;
            for (var pndx in vps) {
                if (vps[pndx].match && vps[pndx].match.fn != null) {
                    umValue.push(vps[pndx].input);
                }
            }
            var unmaskedValue = umValue.length === 0 ? "" : (isRTL ? umValue.reverse() : umValue).join("");
            if ($.isFunction(opts.onUnMask)) {
                var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join("");
                unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);
            }
            return unmaskedValue;
        }

        function caret(input, begin, end, notranslate) {
            function translatePosition(pos) {
                if (notranslate !== true && isRTL && typeof pos === "number" && (!opts.greedy || opts.placeholder !== "")) {
                    var bffrLght = getBuffer().join("").length; //join is needed because sometimes we get an empty buffer element which must not be counted for the caret position (numeric alias)
                    pos = bffrLght - pos;
                }
                return pos;
            }

            var range;
            if (begin !== undefined) {
                if (begin.begin !== undefined) {
                    end = begin.end;
                    begin = begin.begin;
                }
                if (typeof begin === "number") {
                    begin = translatePosition(begin);
                    end = translatePosition(end);
                    end = (typeof end == "number") ? end : begin;
                    // if (!$(input).is(":visible")) {
                    // 	return;
                    // }

                    var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;
                    input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0;

                    if (!mobile && opts.insertMode === false && begin === end) end++; //set visualization for insert/overwrite mode
                    if (input.setSelectionRange) {
                        input.selectionStart = begin;
                        input.selectionEnd = end;
                    } else if (window.getSelection) {
                        range = document.createRange();
                        if (input.firstChild === undefined || input.firstChild === null) {
                            var textNode = document.createTextNode("");
                            input.appendChild(textNode);
                        }
                        range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length);
                        range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length);
                        range.collapse(true);
                        var sel = window.getSelection();
                        sel.removeAllRanges();
                        sel.addRange(range);
                        //input.focus();
                    } else if (input.createTextRange) {
                        range = input.createTextRange();
                        range.collapse(true);
                        range.moveEnd("character", end);
                        range.moveStart("character", begin);
                        range.select();

                    }
                    renderColorMask(input, {begin: begin, end: end});
                }
            } else {
                if (input.setSelectionRange) {
                    begin = input.selectionStart;
                    end = input.selectionEnd;
                } else if (window.getSelection) {
                    range = window.getSelection().getRangeAt(0);
                    if (range.commonAncestorContainer.parentNode === input || range.commonAncestorContainer === input) {
                        begin = range.startOffset;
                        end = range.endOffset;
                    }
                } else if (document.selection && document.selection.createRange) {
                    range = document.selection.createRange();
                    begin = 0 - range.duplicate().moveStart("character", -input.inputmask._valueGet().length);
                    end = begin + range.text.length;
                }

                /*eslint-disable consistent-return */
                return {
                    "begin": translatePosition(begin),
                    "end": translatePosition(end)
                };
                /*eslint-enable consistent-return */
            }
        }

        function determineLastRequiredPosition(returnDefinition) {
            var buffer = getBuffer(),
                bl = buffer.length,
                pos, lvp = getLastValidPosition(),
                positions = {},
                lvTest = getMaskSet().validPositions[lvp],
                ndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined,
                testPos;
            for (pos = lvp + 1; pos < buffer.length; pos++) {
                testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
                ndxIntlzr = testPos.locator.slice();
                positions[pos] = $.extend(true, {}, testPos);
            }

            var lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;
            for (pos = bl - 1; pos > lvp; pos--) {
                testPos = positions[pos];
                if ((testPos.match.optionality ||
                        (testPos.match.optionalQuantifier && testPos.match.newBlockMarker) ||
                        (lvTestAlt &&
                            ((lvTestAlt !== positions[pos].locator[lvTest.alternation] && testPos.match.fn != null) ||
                                (testPos.match.fn === null && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAlt.toString().split(",")) && getTests(pos)[0].def !== "")))) &&
                    buffer[pos] === getPlaceholder(pos, testPos.match)) {
                    bl--;
                } else break;
            }
            return returnDefinition ? {
                "l": bl,
                "def": positions[bl] ? positions[bl].match : undefined
            } : bl;
        }

        function clearOptionalTail(buffer) {
            var rl = determineLastRequiredPosition(),
                validPos, bl = buffer.length;

            var lv = getMaskSet().validPositions[getLastValidPosition()];
            while (rl < bl &&
            !isMask(rl, true) &&
            (validPos = (lv !== undefined ? getTestTemplate(rl, lv.locator.slice(""), lv) : getTest(rl))) &&
            validPos.match.optionality !== true &&
            ((validPos.match.optionalQuantifier !== true && validPos.match.newBlockMarker !== true) || (rl + 1 === bl &&
                (lv !== undefined ? getTestTemplate(rl + 1, lv.locator.slice(""), lv) : getTest(rl + 1)).match.def === ""))) {
                rl++;
            }

            //exceptionally strip from the validatedPositions
            while ((validPos = getMaskSet().validPositions[rl - 1]) && validPos && validPos.match.optionality && validPos.input === opts.skipOptionalPartCharacter) {
                rl--;
            }
            buffer.splice(rl);
            return buffer;
        }

        function isComplete(buffer) { //return true / false / undefined (repeat *)
            if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);
            if (opts.repeat === "*") return undefined;
            var complete = false,
                lrp = determineLastRequiredPosition(true),
                aml = seekPrevious(lrp.l);

            if (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
                complete = true;
                for (var i = 0; i <= aml; i++) {
                    var test = getTestTemplate(i).match;
                    if ((test.fn !== null && getMaskSet().validPositions[i] === undefined && test.optionality !== true && test.optionalQuantifier !== true) || (test.fn === null && buffer[i] !== getPlaceholder(i, test))) {
                        complete = false;
                        break;
                    }
                }
            }
            return complete;
        }


        function handleRemove(input, k, pos, strict, fromIsValid) {
            function generalize() {
                if (opts.keepStatic) {
                    var validInputs = [],
                        lastAlt = getLastValidPosition(-1, true),
                        positionsClone = $.extend(true, {}, getMaskSet().validPositions),
                        prevAltPos = getMaskSet().validPositions[lastAlt];
                    //find last alternation
                    for (; lastAlt >= 0; lastAlt--) {
                        var altPos = getMaskSet().validPositions[lastAlt];
                        if (altPos) {
                            if (altPos.generatedInput !== true && /[0-9a-bA-Z]/.test(altPos.input)) {
                                validInputs.push(altPos.input);
                            }
                            delete getMaskSet().validPositions[lastAlt];
                            if (altPos.alternation !== undefined && altPos.locator[altPos.alternation] !== prevAltPos.locator[altPos.alternation]) {
                                break;
                            }
                            prevAltPos = altPos;
                        }
                    }

                    if (lastAlt > -1) {
                        getMaskSet().p = seekNext(getLastValidPosition(-1, true));
                        while (validInputs.length > 0) {
                            var keypress = new $.Event("keypress");
                            keypress.which = validInputs.pop().charCodeAt(0);
                            // eslint-disable-next-line no-use-before-define
                            EventHandlers.keypressEvent.call(input, keypress, true, false, false, getMaskSet().p);

                        }
                    } else getMaskSet().validPositions = $.extend(true, {}, positionsClone); //restore original positions
                }
            }

            if (opts.numericInput || isRTL) {
                if (k === Inputmask.keyCode.BACKSPACE) {
                    k = Inputmask.keyCode.DELETE;
                } else if (k === Inputmask.keyCode.DELETE) {
                    k = Inputmask.keyCode.BACKSPACE;
                }

                if (isRTL) {
                    var pend = pos.end;
                    pos.end = pos.begin;
                    pos.begin = pend;
                }
            }

            if (k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1 || opts.insertMode === false)) {
                pos.begin = seekPrevious(pos.begin);
                if (getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator) {
                    pos.begin--;
                }
            } else if (k === Inputmask.keyCode.DELETE && pos.begin === pos.end) {
                pos.end = isMask(pos.end, true) && (getMaskSet().validPositions[pos.end] && getMaskSet().validPositions[pos.end].input !== opts.radixPoint  ) ?
                    pos.end + 1 :
                    seekNext(pos.end) + 1;
                if (getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator) {
                    pos.end++;
                }
            }

            stripValidPositions(pos.begin, pos.end, false, strict);
            if (strict !== true) {
                generalize(); //revert the alternation
            }
            var lvp = getLastValidPosition(pos.begin, true);
            if (lvp < pos.begin) {
                //if (lvp === -1) resetMaskSet();
                getMaskSet().p = seekNext(lvp);
            } else if (strict !== true) {
                getMaskSet().p = pos.begin;
                if (fromIsValid !== true) {
                    //put position on first valid from pos.begin ~ #1351
                    while (getMaskSet().p < lvp && getMaskSet().validPositions[getMaskSet().p] === undefined) {
                        getMaskSet().p++;
                    }
                }
            }
        }

        function initializeColorMask(input) {
            var computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null);

            function findCaretPos(clientx) {
                //calculate text width
                var e = document.createElement("span"), caretPos;
                for (var style in computedStyle) { //clone styles
                    if (isNaN(style) && style.indexOf("font") !== -1) {
                        e.style[style] = computedStyle[style];
                    }
                }
                e.style.textTransform = computedStyle.textTransform;
                e.style.letterSpacing = computedStyle.letterSpacing;
                e.style.position = "absolute";
                e.style.height = "auto";
                e.style.width = "auto";
                e.style.visibility = "hidden";
                e.style.whiteSpace = "nowrap";

                document.body.appendChild(e);
                var inputText = input.inputmask._valueGet(), previousWidth = 0, itl;
                for (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos++) {
                    e.innerHTML += inputText.charAt(caretPos) || "_";
                    if (e.offsetWidth >= clientx) {
                        var offset1 = (clientx - previousWidth);
                        var offset2 = e.offsetWidth - clientx;
                        e.innerHTML = inputText.charAt(caretPos);
                        offset1 -= (e.offsetWidth / 3);
                        caretPos = offset1 < offset2 ? caretPos - 1 : caretPos;
                        break;
                    }
                    previousWidth = e.offsetWidth;
                }
                document.body.removeChild(e);
                return caretPos;
            }

            var template = document.createElement("div");
            template.style.width = computedStyle.width;
            template.style.textAlign = computedStyle.textAlign;
            colorMask = document.createElement("div");
            colorMask.className = "im-colormask";
            input.parentNode.insertBefore(colorMask, input);
            input.parentNode.removeChild(input);
            colorMask.appendChild(template);
            colorMask.appendChild(input);
            input.style.left = template.offsetLeft + "px";

            $(input).on("click", function (e) {
                caret(input, findCaretPos(e.clientX));
                return EventHandlers.clickEvent.call(input, [e]);
            });
            $(input).on("keydown", function (e) {
                if (!e.shiftKey && opts.insertMode !== false) {
                    setTimeout(function () {
                        renderColorMask(input);
                    }, 0);
                }
            });
        }

        Inputmask.prototype.positionColorMask = function (input, template) {
            input.style.left = template.offsetLeft + "px";
        }

        function renderColorMask(input, caretPos, clear) {
            var maskTemplate = "", isStatic = false, test, testPos, ndxIntlzr, pos = 0;

            function handleStatic() {
                if (!isStatic && (test.fn === null || testPos.input === undefined)) {
                    isStatic = true;
                    maskTemplate += "<span class='im-static'>"
                } else if (isStatic && ((test.fn !== null && testPos.input !== undefined) || test.def === "")) {
                    isStatic = false;
                    maskTemplate += "</span>"
                }
            }

            function handleCaret(force) {
                if ((force === true || pos === caretPos.begin) && document.activeElement === input) {
                    maskTemplate += "<span class='im-caret' style='border-right-width: 1px;border-right-style: solid;'></span>";
                }
            }

            if (colorMask !== undefined) {
                var buffer = getBuffer();
                if (caretPos === undefined) {
                    caretPos = caret(input);
                } else if (caretPos.begin === undefined) {
                    caretPos = {begin: caretPos, end: caretPos};
                }

                if (clear !== true) {
                    var lvp = getLastValidPosition();
                    do {
                        handleCaret();
                        if (getMaskSet().validPositions[pos]) {
                            testPos = getMaskSet().validPositions[pos];
                            test = testPos.match;
                            ndxIntlzr = testPos.locator.slice();
                            handleStatic();
                            maskTemplate += buffer[pos];
                        } else {
                            testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
                            test = testPos.match;
                            ndxIntlzr = testPos.locator.slice();
                            if (opts.jitMasking === false || pos < lvp || (typeof opts.jitMasking === "number" && isFinite(opts.jitMasking) && opts.jitMasking > pos)) {
                                handleStatic();
                                maskTemplate += getPlaceholder(pos, test);
                            }
                        }
                        pos++;
                    } while ((maxLength === undefined || pos < maxLength) && (test.fn !== null || test.def !== "") || lvp > pos || isStatic);
                    if (maskTemplate.indexOf("im-caret") === -1) handleCaret(true);
                    if (isStatic) handleStatic();
                }

                var template = colorMask.getElementsByTagName("div")[0];
                template.innerHTML = maskTemplate;
                input.inputmask.positionColorMask(input, template);
            }
        }

        function mask(elem) {
            function isElementTypeSupported(input, opts) {
                function patchValueProperty(npt) {
                    var valueGet;
                    var valueSet;

                    function patchValhook(type) {
                        if ($.valHooks && ($.valHooks[type] === undefined || $.valHooks[type].inputmaskpatch !== true)) {
                            var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) {
                                return elem.value;
                            };
                            var valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {
                                elem.value = value;
                                return elem;
                            };

                            $.valHooks[type] = {
                                get: function (elem) {
                                    if (elem.inputmask) {
                                        if (elem.inputmask.opts.autoUnmask) {
                                            return elem.inputmask.unmaskedvalue();
                                        } else {
                                            var result = valhookGet(elem);
                                            return getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) !== -1 || opts.nullable !== true ? result : "";
                                        }
                                    } else return valhookGet(elem);
                                },
                                set: function (elem, value) {
                                    var $elem = $(elem),
                                        result;
                                    result = valhookSet(elem, value);
                                    if (elem.inputmask) {
                                        $elem.trigger("setvalue");
                                    }
                                    return result;
                                },
                                inputmaskpatch: true
                            };
                        }
                    }

                    function getter() {
                        if (this.inputmask) {
                            return this.inputmask.opts.autoUnmask ?
                                this.inputmask.unmaskedvalue() :
                                (getLastValidPosition() !== -1 || opts.nullable !== true ?
                                    (document.activeElement === this && opts.clearMaskOnLostFocus ?
                                        (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join("") :
                                        valueGet.call(this)) :
                                    "");
                        } else return valueGet.call(this);
                    }

                    function setter(value) {
                        valueSet.call(this, value);
                        if (this.inputmask) {
                            $(this).trigger("setvalue");
                        }
                    }

                    function installNativeValueSetFallback(npt) {
                        EventRuler.on(npt, "mouseenter", function (event) {
                            var $input = $(this),
                                input = this,
                                value = input.inputmask._valueGet();
                            if (value !== getBuffer().join("") /*&& getLastValidPosition() > 0*/) {
                                $input.trigger("setvalue");
                            }
                        });
                    }

                    if (!npt.inputmask.__valueGet) {
                        if (opts.noValuePatching !== true) {
                            if (Object.getOwnPropertyDescriptor) {
                                if (typeof Object.getPrototypeOf !== "function") {
                                    Object.getPrototypeOf = typeof "test".__proto__ === "object" ? function (object) {
                                        return object.__proto__;
                                    } : function (object) {
                                        return object.constructor.prototype;
                                    };
                                }

                                var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), "value") : undefined;
                                if (valueProperty && valueProperty.get && valueProperty.set) {
                                    valueGet = valueProperty.get;
                                    valueSet = valueProperty.set;
                                    Object.defineProperty(npt, "value", {
                                        get: getter,
                                        set: setter,
                                        configurable: true
                                    });
                                } else if (npt.tagName !== "INPUT") {
                                    valueGet = function () {
                                        return this.textContent;
                                    };
                                    valueSet = function (value) {
                                        this.textContent = value;
                                    };
                                    Object.defineProperty(npt, "value", {
                                        get: getter,
                                        set: setter,
                                        configurable: true
                                    });
                                }
                            } else if (document.__lookupGetter__ && npt.__lookupGetter__("value")) {
                                valueGet = npt.__lookupGetter__("value");
                                valueSet = npt.__lookupSetter__("value");

                                npt.__defineGetter__("value", getter);
                                npt.__defineSetter__("value", setter);
                            }
                            npt.inputmask.__valueGet = valueGet; //store native property getter
                            npt.inputmask.__valueSet = valueSet; //store native property setter
                        }
                        npt.inputmask._valueGet = function (overruleRTL) {
                            return isRTL && overruleRTL !== true ? valueGet.call(this.el).split("").reverse().join("") : valueGet.call(this.el);
                        };
                        npt.inputmask._valueSet = function (value, overruleRTL) { //null check is needed for IE8 => otherwise converts to "null"
                            valueSet.call(this.el, (value === null || value === undefined) ? "" : ((overruleRTL !== true && isRTL) ? value.split("").reverse().join("") : value));
                        };

                        if (valueGet === undefined) { //jquery.val fallback
                            valueGet = function () {
                                return this.value;
                            };
                            valueSet = function (value) {
                                this.value = value;
                            };
                            patchValhook(npt.type);
                            installNativeValueSetFallback(npt);
                        }
                    }
                }

                var elementType = input.getAttribute("type");
                var isSupported = (input.tagName === "INPUT" && $.inArray(elementType, opts.supportsInputType) !== -1) || input.isContentEditable || input.tagName === "TEXTAREA";
                if (!isSupported) {
                    if (input.tagName === "INPUT") {
                        var el = document.createElement("input");
                        el.setAttribute("type", elementType);
                        isSupported = el.type === "text"; //apply mask only if the type is not natively supported
                        el = null;
                    } else isSupported = "partial";
                }
                if (isSupported !== false) {
                    patchValueProperty(input);
                } else input.inputmask = undefined;
                return isSupported;
            }

            //unbind all events - to make sure that no other mask will interfere when re-masking
            EventRuler.off(elem);
            var isSupported = isElementTypeSupported(elem, opts);
            if (isSupported !== false) {
                el = elem;
                $el = $(el);

                //read maxlength prop from el
                maxLength = el !== undefined ? el.maxLength : undefined;
                if (maxLength === -1) maxLength = undefined;

                if (opts.colorMask === true) {
                    initializeColorMask(el);
                }

                if (android) {
                    if (el.hasOwnProperty("inputmode")) {
                        el.inputmode = opts.inputmode;
                        el.setAttribute("inputmode", opts.inputmode);
                    }
                    if (opts.androidHack === "rtfm") {
                        if (opts.colorMask !== true) {
                            initializeColorMask(el);
                        }
                        el.type = "password";
                    }
                }

                if (isSupported === true) {
                    //bind events
                    EventRuler.on(el, "submit", EventHandlers.submitEvent);
                    EventRuler.on(el, "reset", EventHandlers.resetEvent);

                    EventRuler.on(el, "mouseenter", EventHandlers.mouseenterEvent);
                    EventRuler.on(el, "blur", EventHandlers.blurEvent);
                    EventRuler.on(el, "focus", EventHandlers.focusEvent);
                    EventRuler.on(el, "mouseleave", EventHandlers.mouseleaveEvent);
                    if (opts.colorMask !== true) {
                        EventRuler.on(el, "click", EventHandlers.clickEvent);
                    }
                    EventRuler.on(el, "dblclick", EventHandlers.dblclickEvent);
                    EventRuler.on(el, "paste", EventHandlers.pasteEvent);
                    EventRuler.on(el, "dragdrop", EventHandlers.pasteEvent);
                    EventRuler.on(el, "drop", EventHandlers.pasteEvent);
                    EventRuler.on(el, "cut", EventHandlers.cutEvent);
                    EventRuler.on(el, "complete", opts.oncomplete);
                    EventRuler.on(el, "incomplete", opts.onincomplete);
                    EventRuler.on(el, "cleared", opts.oncleared);
                    if (!android && opts.inputEventOnly !== true) {
                        EventRuler.on(el, "keydown", EventHandlers.keydownEvent);
                        EventRuler.on(el, "keypress", EventHandlers.keypressEvent);
                    } else el.removeAttribute("maxLength");
                    EventRuler.on(el, "compositionstart", $.noop);
                    EventRuler.on(el, "compositionupdate", $.noop);
                    EventRuler.on(el, "compositionend", $.noop);
                    EventRuler.on(el, "keyup", $.noop);
                    EventRuler.on(el, "input", EventHandlers.inputFallBackEvent);
                    EventRuler.on(el, "beforeinput", $.noop); //https://github.com/w3c/input-events - to implement
                }
                EventRuler.on(el, "setvalue", EventHandlers.setValueEvent);

                //apply mask
                undoValue = getBufferTemplate().join(""); //initialize the buffer and getmasklength
                if (el.inputmask._valueGet(true) !== "" || opts.clearMaskOnLostFocus === false || document.activeElement === el) {
                    var initialValue = $.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, el.inputmask._valueGet(true), opts) || el.inputmask._valueGet(true)) : el.inputmask._valueGet(true);
                    if (initialValue !== "") checkVal(el, true, false, isRTL ? initialValue.split("").reverse() : initialValue.split(""));
                    var buffer = getBuffer().slice();
                    undoValue = buffer.join("");
                    // Wrap document.activeElement in a try/catch block since IE9 throw "Unspecified error" if document.activeElement is undefined when we are in an IFrame.
                    if (isComplete(buffer) === false) {
                        if (opts.clearIncomplete) {
                            resetMaskSet();
                        }
                    }
                    if (opts.clearMaskOnLostFocus && document.activeElement !== el) {
                        if (getLastValidPosition() === -1) {
                            buffer = [];
                        } else {
                            clearOptionalTail(buffer);
                        }
                    }
                    writeBuffer(el, buffer);
                    if (document.activeElement === el) { //position the caret when in focus
                        caret(el, seekNext(getLastValidPosition()));
                    }
                }
            }
        }

//action object
        var valueBuffer;
        if (actionObj !== undefined) {
            switch (actionObj.action) {
                case "isComplete":
                    el = actionObj.el;
                    return isComplete(getBuffer());
                case "unmaskedvalue":
                    if (el === undefined || actionObj.value !== undefined) {
                        valueBuffer = actionObj.value;
                        valueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer) : valueBuffer).split("");
                        checkVal(undefined, false, false, isRTL ? valueBuffer.reverse() : valueBuffer);
                        if ($.isFunction(opts.onBeforeWrite)) opts.onBeforeWrite.call(inputmask, undefined, getBuffer(), 0, opts);
                    }
                    return unmaskedvalue(el);
                case "mask":
                    mask(el);
                    break;
                case "format":
                    valueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value) : actionObj.value).split("");
                    checkVal(undefined, true, false, isRTL ? valueBuffer.reverse() : valueBuffer);
                    if (actionObj.metadata) {
                        return {
                            value: isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join(""),
                            metadata: maskScope.call(this, {
                                "action": "getmetadata"
                            }, maskset, opts)
                        };
                    }

                    return isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join("");
                case "isValid":
                    if (actionObj.value) {
                        valueBuffer = actionObj.value.split("");
                        checkVal(undefined, true, true, isRTL ? valueBuffer.reverse() : valueBuffer);
                    } else {
                        actionObj.value = getBuffer().join("");
                    }
                    var buffer = getBuffer();
                    var rl = determineLastRequiredPosition(),
                        lmib = buffer.length - 1;
                    for (; lmib > rl; lmib--) {
                        if (isMask(lmib)) break;
                    }
                    buffer.splice(rl, lmib + 1 - rl);

                    return isComplete(buffer) && actionObj.value === getBuffer().join("");
                case "getemptymask":
                    return getBufferTemplate().join("");
                case "remove":
                    if (el && el.inputmask) {
                        $el = $(el);
                        //writeout the value
                        el.inputmask._valueSet(opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(true));
                        //unbind all events
                        EventRuler.off(el);
                        //restore the value property
                        var valueProperty;
                        if (Object.getOwnPropertyDescriptor && Object.getPrototypeOf) {
                            valueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), "value");
                            if (valueProperty) {
                                if (el.inputmask.__valueGet) {
                                    Object.defineProperty(el, "value", {
                                        get: el.inputmask.__valueGet,
                                        set: el.inputmask.__valueSet,
                                        configurable: true
                                    });
                                }
                            }
                        } else if (document.__lookupGetter__ && el.__lookupGetter__("value")) {
                            if (el.inputmask.__valueGet) {
                                el.__defineGetter__("value", el.inputmask.__valueGet);
                                el.__defineSetter__("value", el.inputmask.__valueSet);
                            }
                        }
                        //clear data
                        el.inputmask = undefined;
                    }
                    return el;
                    break;
                case "getmetadata":
                    if ($.isArray(maskset.metadata)) {
                        var maskTarget = getMaskTemplate(true, 0, false).join("");
                        $.each(maskset.metadata, function (ndx, mtdt) {
                            if (mtdt.mask === maskTarget) {
                                maskTarget = mtdt;
                                return false;
                            }
                        });
                        return maskTarget;
                    }

                    return maskset.metadata;
            }
        }
    }

//make inputmask available
    return Inputmask;
}))
;

/*!
* jquery.inputmask.bundle.js
* https://github.com/RobinHerbots/Inputmask
* Copyright (c) 2010 - 2017 Robin Herbots
* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
* Version: 3.3.11
*/

!function(modules) {
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: !1,
            exports: {}
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
        module.l = !0, module.exports;
    }
    var installedModules = {};
    __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function(exports, name, getter) {
        __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
            configurable: !1,
            enumerable: !0,
            get: getter
        });
    }, __webpack_require__.n = function(module) {
        var getter = module && module.__esModule ? function() {
            return module.default;
        } : function() {
            return module;
        };
        return __webpack_require__.d(getter, "a", getter), getter;
    }, __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 3);
}([ function(module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    !function(factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(2) ], void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function($) {
        return $;
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    !function(factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0), __webpack_require__(10), __webpack_require__(11) ], 
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function($, window, document, undefined) {
        function Inputmask(alias, options, internal) {
            if (!(this instanceof Inputmask)) return new Inputmask(alias, options, internal);
            this.el = undefined, this.events = {}, this.maskset = undefined, this.refreshValue = !1, 
            !0 !== internal && ($.isPlainObject(alias) ? options = alias : (options = options || {}).alias = alias, 
            this.opts = $.extend(!0, {}, this.defaults, options), this.noMasksCache = options && options.definitions !== undefined, 
            this.userOptions = options || {}, this.isRTL = this.opts.numericInput, resolveAlias(this.opts.alias, options, this.opts));
        }
        function resolveAlias(aliasStr, options, opts) {
            var aliasDefinition = Inputmask.prototype.aliases[aliasStr];
            return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, undefined, opts), 
            $.extend(!0, opts, aliasDefinition), $.extend(!0, opts, options), !0) : (null === opts.mask && (opts.mask = aliasStr), 
            !1);
        }
        function generateMaskSet(opts, nocache) {
            function generateMask(mask, metadata, opts) {
                var regexMask = !1;
                if (null !== mask && "" !== mask || ((regexMask = null !== opts.regex) ? mask = (mask = opts.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (regexMask = !0, 
                mask = ".*")), 1 === mask.length && !1 === opts.greedy && 0 !== opts.repeat && (opts.placeholder = ""), 
                opts.repeat > 0 || "*" === opts.repeat || "+" === opts.repeat) {
                    var repeatStart = "*" === opts.repeat ? 0 : "+" === opts.repeat ? 1 : opts.repeat;
                    mask = opts.groupmarker.start + mask + opts.groupmarker.end + opts.quantifiermarker.start + repeatStart + "," + opts.repeat + opts.quantifiermarker.end;
                }
                var masksetDefinition, maskdefKey = regexMask ? "regex_" + opts.regex : opts.numericInput ? mask.split("").reverse().join("") : mask;
                return Inputmask.prototype.masksCache[maskdefKey] === undefined || !0 === nocache ? (masksetDefinition = {
                    mask: mask,
                    maskToken: Inputmask.prototype.analyseMask(mask, regexMask, opts),
                    validPositions: {},
                    _buffer: undefined,
                    buffer: undefined,
                    tests: {},
                    metadata: metadata,
                    maskLength: undefined
                }, !0 !== nocache && (Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition, 
                masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]))) : masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]), 
                masksetDefinition;
            }
            if ($.isFunction(opts.mask) && (opts.mask = opts.mask(opts)), $.isArray(opts.mask)) {
                if (opts.mask.length > 1) {
                    opts.keepStatic = null === opts.keepStatic || opts.keepStatic;
                    var altMask = opts.groupmarker.start;
                    return $.each(opts.numericInput ? opts.mask.reverse() : opts.mask, function(ndx, msk) {
                        altMask.length > 1 && (altMask += opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start), 
                        msk.mask === undefined || $.isFunction(msk.mask) ? altMask += msk : altMask += msk.mask;
                    }), altMask += opts.groupmarker.end, generateMask(altMask, opts.mask, opts);
                }
                opts.mask = opts.mask.pop();
            }
            return opts.mask && opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask) ? generateMask(opts.mask.mask, opts.mask, opts) : generateMask(opts.mask, opts.mask, opts);
        }
        function maskScope(actionObj, maskset, opts) {
            function getMaskTemplate(baseOnInput, minimalPos, includeMode) {
                minimalPos = minimalPos || 0;
                var ndxIntlzr, test, testPos, maskTemplate = [], pos = 0, lvp = getLastValidPosition();
                do {
                    !0 === baseOnInput && getMaskSet().validPositions[pos] ? (test = (testPos = getMaskSet().validPositions[pos]).match, 
                    ndxIntlzr = testPos.locator.slice(), maskTemplate.push(!0 === includeMode ? testPos.input : !1 === includeMode ? test.nativeDef : getPlaceholder(pos, test))) : (test = (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1)).match, 
                    ndxIntlzr = testPos.locator.slice(), (!1 === opts.jitMasking || pos < lvp || "number" == typeof opts.jitMasking && isFinite(opts.jitMasking) && opts.jitMasking > pos) && maskTemplate.push(!1 === includeMode ? test.nativeDef : getPlaceholder(pos, test))), 
                    pos++;
                } while ((maxLength === undefined || pos < maxLength) && (null !== test.fn || "" !== test.def) || minimalPos > pos);
                return "" === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(), getMaskSet().maskLength = pos + 1, 
                maskTemplate;
            }
            function getMaskSet() {
                return maskset;
            }
            function resetMaskSet(soft) {
                var maskset = getMaskSet();
                maskset.buffer = undefined, !0 !== soft && (maskset.validPositions = {}, maskset.p = 0);
            }
            function getLastValidPosition(closestTo, strict, validPositions) {
                var before = -1, after = -1, valids = validPositions || getMaskSet().validPositions;
                closestTo === undefined && (closestTo = -1);
                for (var posNdx in valids) {
                    var psNdx = parseInt(posNdx);
                    valids[psNdx] && (strict || !0 !== valids[psNdx].generatedInput) && (psNdx <= closestTo && (before = psNdx), 
                    psNdx >= closestTo && (after = psNdx));
                }
                return -1 !== before && closestTo - before > 1 || after < closestTo ? before : after;
            }
            function stripValidPositions(start, end, nocheck, strict) {
                var i, startPos = start, positionsClone = $.extend(!0, {}, getMaskSet().validPositions), needsValidation = !1;
                for (getMaskSet().p = start, i = end - 1; i >= startPos; i--) getMaskSet().validPositions[i] !== undefined && (!0 !== nocheck && (!getMaskSet().validPositions[i].match.optionality && function(pos) {
                    var posMatch = getMaskSet().validPositions[pos];
                    if (posMatch !== undefined && null === posMatch.match.fn) {
                        var prevMatch = getMaskSet().validPositions[pos - 1], nextMatch = getMaskSet().validPositions[pos + 1];
                        return prevMatch !== undefined && nextMatch !== undefined;
                    }
                    return !1;
                }(i) || !1 === opts.canClearPosition(getMaskSet(), i, getLastValidPosition(), strict, opts)) || delete getMaskSet().validPositions[i]);
                for (resetMaskSet(!0), i = startPos + 1; i <= getLastValidPosition(); ) {
                    for (;getMaskSet().validPositions[startPos] !== undefined; ) startPos++;
                    if (i < startPos && (i = startPos + 1), getMaskSet().validPositions[i] === undefined && isMask(i)) i++; else {
                        var t = getTestTemplate(i);
                        !1 === needsValidation && positionsClone[startPos] && positionsClone[startPos].match.def === t.match.def ? (getMaskSet().validPositions[startPos] = $.extend(!0, {}, positionsClone[startPos]), 
                        getMaskSet().validPositions[startPos].input = t.input, delete getMaskSet().validPositions[i], 
                        i++) : positionCanMatchDefinition(startPos, t.match.def) ? !1 !== isValid(startPos, t.input || getPlaceholder(i), !0) && (delete getMaskSet().validPositions[i], 
                        i++, needsValidation = !0) : isMask(i) || (i++, startPos--), startPos++;
                    }
                }
                resetMaskSet(!0);
            }
            function determineTestTemplate(tests, guessNextBest) {
                for (var testPos, testPositions = tests, lvp = getLastValidPosition(), lvTest = getMaskSet().validPositions[lvp] || getTests(0)[0], lvTestAltArr = lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation].toString().split(",") : [], ndx = 0; ndx < testPositions.length && (!((testPos = testPositions[ndx]).match && (opts.greedy && !0 !== testPos.match.optionalQuantifier || (!1 === testPos.match.optionality || !1 === testPos.match.newBlockMarker) && !0 !== testPos.match.optionalQuantifier) && (lvTest.alternation === undefined || lvTest.alternation !== testPos.alternation || testPos.locator[lvTest.alternation] !== undefined && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAltArr))) || !0 === guessNextBest && (null !== testPos.match.fn || /[0-9a-bA-Z]/.test(testPos.match.def))); ndx++) ;
                return testPos;
            }
            function getTestTemplate(pos, ndxIntlzr, tstPs) {
                return getMaskSet().validPositions[pos] || determineTestTemplate(getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));
            }
            function getTest(pos) {
                return getMaskSet().validPositions[pos] ? getMaskSet().validPositions[pos] : getTests(pos)[0];
            }
            function positionCanMatchDefinition(pos, def) {
                for (var valid = !1, tests = getTests(pos), tndx = 0; tndx < tests.length; tndx++) if (tests[tndx].match && tests[tndx].match.def === def) {
                    valid = !0;
                    break;
                }
                return valid;
            }
            function getTests(pos, ndxIntlzr, tstPs) {
                function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {
                    function handleMatch(match, loopNdx, quantifierRecurse) {
                        function isFirstMatch(latestMatch, tokenGroup) {
                            var firstMatch = 0 === $.inArray(latestMatch, tokenGroup.matches);
                            return firstMatch || $.each(tokenGroup.matches, function(ndx, match) {
                                if (!0 === match.isQuantifier && (firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]))) return !1;
                            }), firstMatch;
                        }
                        function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {
                            var bestMatch, indexPos;
                            if (getMaskSet().validPositions[pos - 1] && targetAlternation && getMaskSet().tests[pos]) for (var vpAlternation = getMaskSet().validPositions[pos - 1].locator, tpAlternation = getMaskSet().tests[pos][0].locator, i = 0; i < targetAlternation; i++) if (vpAlternation[i] !== tpAlternation[i]) return vpAlternation.slice(targetAlternation + 1);
                            return (getMaskSet().tests[pos] || getMaskSet().validPositions[pos]) && $.each(getMaskSet().tests[pos] || [ getMaskSet().validPositions[pos] ], function(ndx, lmnt) {
                                var alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation, ndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;
                                (indexPos === undefined || ndxPos < indexPos) && -1 !== ndxPos && (bestMatch = lmnt, 
                                indexPos = ndxPos);
                            }), bestMatch ? bestMatch.locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1) : targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;
                        }
                        if (testPos > 1e4) throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + getMaskSet().mask;
                        if (testPos === pos && match.matches === undefined) return matches.push({
                            match: match,
                            locator: loopNdx.reverse(),
                            cd: cacheDependency
                        }), !0;
                        if (match.matches !== undefined) {
                            if (match.isGroup && quantifierRecurse !== match) {
                                if (match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx)) return !0;
                            } else if (match.isOptional) {
                                var optionalToken = match;
                                if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) {
                                    if (latestMatch = matches[matches.length - 1].match, !isFirstMatch(latestMatch, optionalToken)) return !0;
                                    insertStop = !0, testPos = pos;
                                }
                            } else if (match.isAlternator) {
                                var maltMatches, alternateToken = match, malternateMatches = [], currentMatches = matches.slice(), loopNdxCnt = loopNdx.length, altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;
                                if (-1 === altIndex || "string" == typeof altIndex) {
                                    var amndx, currentPos = testPos, ndxInitializerClone = ndxInitializer.slice(), altIndexArr = [];
                                    if ("string" == typeof altIndex) altIndexArr = altIndex.split(","); else for (amndx = 0; amndx < alternateToken.matches.length; amndx++) altIndexArr.push(amndx);
                                    for (var ndx = 0; ndx < altIndexArr.length; ndx++) {
                                        if (amndx = parseInt(altIndexArr[ndx]), matches = [], ndxInitializer = resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice(), 
                                        !0 !== (match = handleMatch(alternateToken.matches[amndx] || maskToken.matches[amndx], [ amndx ].concat(loopNdx), quantifierRecurse) || match) && match !== undefined && altIndexArr[altIndexArr.length - 1] < alternateToken.matches.length) {
                                            var ntndx = $.inArray(match, maskToken.matches) + 1;
                                            maskToken.matches.length > ntndx && (match = handleMatch(maskToken.matches[ntndx], [ ntndx ].concat(loopNdx.slice(1, loopNdx.length)), quantifierRecurse)) && (altIndexArr.push(ntndx.toString()), 
                                            $.each(matches, function(ndx, lmnt) {
                                                lmnt.alternation = loopNdx.length - 1;
                                            }));
                                        }
                                        maltMatches = matches.slice(), testPos = currentPos, matches = [];
                                        for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
                                            var altMatch = maltMatches[ndx1], dropMatch = !1;
                                            altMatch.alternation = altMatch.alternation || loopNdxCnt;
                                            for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {
                                                var altMatch2 = malternateMatches[ndx2];
                                                if ("string" != typeof altIndex || -1 !== $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr)) {
                                                    if (function(source, target) {
                                                        return source.match.nativeDef === target.match.nativeDef || source.match.def === target.match.nativeDef || source.match.nativeDef === target.match.def;
                                                    }(altMatch, altMatch2)) {
                                                        dropMatch = !0, altMatch.alternation === altMatch2.alternation && -1 === altMatch2.locator[altMatch2.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) && (altMatch2.locator[altMatch2.alternation] = altMatch2.locator[altMatch2.alternation] + "," + altMatch.locator[altMatch.alternation], 
                                                        altMatch2.alternation = altMatch.alternation), altMatch.match.nativeDef === altMatch2.match.def && (altMatch.locator[altMatch.alternation] = altMatch2.locator[altMatch2.alternation], 
                                                        malternateMatches.splice(malternateMatches.indexOf(altMatch2), 1, altMatch));
                                                        break;
                                                    }
                                                    if (altMatch.match.def === altMatch2.match.def) {
                                                        dropMatch = !1;
                                                        break;
                                                    }
                                                    if (function(source, target) {
                                                        return null === source.match.fn && null !== target.match.fn && target.match.fn.test(source.match.def, getMaskSet(), pos, !1, opts, !1);
                                                    }(altMatch, altMatch2) || function(source, target) {
                                                        return null !== source.match.fn && null !== target.match.fn && target.match.fn.test(source.match.def.replace(/[\[\]]/g, ""), getMaskSet(), pos, !1, opts, !1);
                                                    }(altMatch, altMatch2)) {
                                                        altMatch.alternation === altMatch2.alternation && -1 === altMatch.locator[altMatch.alternation].toString().indexOf(altMatch2.locator[altMatch2.alternation].toString().split("")[0]) && (altMatch.na = altMatch.na || altMatch.locator[altMatch.alternation].toString(), 
                                                        -1 === altMatch.na.indexOf(altMatch.locator[altMatch.alternation].toString().split("")[0]) && (altMatch.na = altMatch.na + "," + altMatch.locator[altMatch2.alternation].toString().split("")[0]), 
                                                        dropMatch = !0, altMatch.locator[altMatch.alternation] = altMatch2.locator[altMatch2.alternation].toString().split("")[0] + "," + altMatch.locator[altMatch.alternation], 
                                                        malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));
                                                        break;
                                                    }
                                                }
                                            }
                                            dropMatch || malternateMatches.push(altMatch);
                                        }
                                    }
                                    "string" == typeof altIndex && (malternateMatches = $.map(malternateMatches, function(lmnt, ndx) {
                                        if (isFinite(ndx)) {
                                            var alternation = lmnt.alternation, altLocArr = lmnt.locator[alternation].toString().split(",");
                                            lmnt.locator[alternation] = undefined, lmnt.alternation = undefined;
                                            for (var alndx = 0; alndx < altLocArr.length; alndx++) -1 !== $.inArray(altLocArr[alndx], altIndexArr) && (lmnt.locator[alternation] !== undefined ? (lmnt.locator[alternation] += ",", 
                                            lmnt.locator[alternation] += altLocArr[alndx]) : lmnt.locator[alternation] = parseInt(altLocArr[alndx]), 
                                            lmnt.alternation = alternation);
                                            if (lmnt.locator[alternation] !== undefined) return lmnt;
                                        }
                                    })), matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = matches.length > 0, 
                                    match = malternateMatches.length > 0, ndxInitializer = ndxInitializerClone.slice();
                                } else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [ altIndex ].concat(loopNdx), quantifierRecurse);
                                if (match) return !0;
                            } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) for (var qt = match, qndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos; qndx++) {
                                var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];
                                if (match = handleMatch(tokenGroup, [ qndx ].concat(loopNdx), tokenGroup)) {
                                    if (latestMatch = matches[matches.length - 1].match, latestMatch.optionalQuantifier = qndx > qt.quantifier.min - 1, 
                                    isFirstMatch(latestMatch, tokenGroup)) {
                                        if (qndx > qt.quantifier.min - 1) {
                                            insertStop = !0, testPos = pos;
                                            break;
                                        }
                                        return !0;
                                    }
                                    return !0;
                                }
                            } else if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) return !0;
                        } else testPos++;
                    }
                    for (var tndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++) if (!0 !== maskToken.matches[tndx].isQuantifier) {
                        var match = handleMatch(maskToken.matches[tndx], [ tndx ].concat(loopNdx), quantifierRecurse);
                        if (match && testPos === pos) return match;
                        if (testPos > pos) break;
                    }
                }
                function filterTests(tests) {
                    if (opts.keepStatic && pos > 0 && tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0) && !0 !== tests[0].match.optionality && !0 !== tests[0].match.optionalQuantifier && null === tests[0].match.fn && !/[0-9a-bA-Z]/.test(tests[0].match.def)) {
                        if (getMaskSet().validPositions[pos - 1] === undefined) return [ determineTestTemplate(tests) ];
                        if (getMaskSet().validPositions[pos - 1].alternation === tests[0].alternation) return [ determineTestTemplate(tests) ];
                        if (getMaskSet().validPositions[pos - 1]) return [ determineTestTemplate(tests) ];
                    }
                    return tests;
                }
                var latestMatch, maskTokens = getMaskSet().maskToken, testPos = ndxIntlzr ? tstPs : 0, ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [ 0 ], matches = [], insertStop = !1, cacheDependency = ndxIntlzr ? ndxIntlzr.join("") : "";
                if (pos > -1) {
                    if (ndxIntlzr === undefined) {
                        for (var test, previousPos = pos - 1; (test = getMaskSet().validPositions[previousPos] || getMaskSet().tests[previousPos]) === undefined && previousPos > -1; ) previousPos--;
                        test !== undefined && previousPos > -1 && (ndxInitializer = function(tests) {
                            var locator = [];
                            return $.isArray(tests) || (tests = [ tests ]), tests.length > 0 && (tests[0].alternation === undefined ? 0 === (locator = determineTestTemplate(tests.slice()).locator.slice()).length && (locator = tests[0].locator.slice()) : $.each(tests, function(ndx, tst) {
                                if ("" !== tst.def) if (0 === locator.length) locator = tst.locator.slice(); else for (var i = 0; i < locator.length; i++) tst.locator[i] && -1 === locator[i].toString().indexOf(tst.locator[i]) && (locator[i] += "," + tst.locator[i]);
                            })), locator;
                        }(test), cacheDependency = ndxInitializer.join(""), testPos = previousPos);
                    }
                    if (getMaskSet().tests[pos] && getMaskSet().tests[pos][0].cd === cacheDependency) return filterTests(getMaskSet().tests[pos]);
                    for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length && !(resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [ mtndx ]) && testPos === pos || testPos > pos); mtndx++) ;
                }
                return (0 === matches.length || insertStop) && matches.push({
                    match: {
                        fn: null,
                        cardinality: 0,
                        optionality: !0,
                        casing: null,
                        def: "",
                        placeholder: ""
                    },
                    locator: [],
                    cd: cacheDependency
                }), ndxIntlzr !== undefined && getMaskSet().tests[pos] ? filterTests($.extend(!0, [], matches)) : (getMaskSet().tests[pos] = $.extend(!0, [], matches), 
                filterTests(getMaskSet().tests[pos]));
            }
            function getBufferTemplate() {
                return getMaskSet()._buffer === undefined && (getMaskSet()._buffer = getMaskTemplate(!1, 1), 
                getMaskSet().buffer === undefined && (getMaskSet().buffer = getMaskSet()._buffer.slice())), 
                getMaskSet()._buffer;
            }
            function getBuffer(noCache) {
                return getMaskSet().buffer !== undefined && !0 !== noCache || (getMaskSet().buffer = getMaskTemplate(!0, getLastValidPosition(), !0)), 
                getMaskSet().buffer;
            }
            function refreshFromBuffer(start, end, buffer) {
                var i, p;
                if (!0 === start) resetMaskSet(), start = 0, end = buffer.length; else for (i = start; i < end; i++) delete getMaskSet().validPositions[i];
                for (p = start, i = start; i < end; i++) if (resetMaskSet(!0), buffer[i] !== opts.skipOptionalPartCharacter) {
                    var valResult = isValid(p, buffer[i], !0, !0);
                    !1 !== valResult && (resetMaskSet(!0), p = valResult.caret !== undefined ? valResult.caret : valResult.pos + 1);
                }
            }
            function casing(elem, test, pos) {
                switch (opts.casing || test.casing) {
                  case "upper":
                    elem = elem.toUpperCase();
                    break;

                  case "lower":
                    elem = elem.toLowerCase();
                    break;

                  case "title":
                    var posBefore = getMaskSet().validPositions[pos - 1];
                    elem = 0 === pos || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE) ? elem.toUpperCase() : elem.toLowerCase();
                    break;

                  default:
                    if ($.isFunction(opts.casing)) {
                        var args = Array.prototype.slice.call(arguments);
                        args.push(getMaskSet().validPositions), elem = opts.casing.apply(this, args);
                    }
                }
                return elem;
            }
            function checkAlternationMatch(altArr1, altArr2, na) {
                for (var naNdx, altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, naArr = na !== undefined ? na.split(",") : [], i = 0; i < naArr.length; i++) -1 !== (naNdx = altArr1.indexOf(naArr[i])) && altArr1.splice(naNdx, 1);
                for (var alndx = 0; alndx < altArr1.length; alndx++) if (-1 !== $.inArray(altArr1[alndx], altArrC)) {
                    isMatch = !0;
                    break;
                }
                return isMatch;
            }
            function isValid(pos, c, strict, fromSetValid, fromAlternate, validateOnly) {
                function isSelection(posObj) {
                    var selection = isRTL ? posObj.begin - posObj.end > 1 || posObj.begin - posObj.end == 1 : posObj.end - posObj.begin > 1 || posObj.end - posObj.begin == 1;
                    return selection && 0 === posObj.begin && posObj.end === getMaskSet().maskLength ? "full" : selection;
                }
                function _isValid(position, c, strict) {
                    var rslt = !1;
                    return $.each(getTests(position), function(ndx, tst) {
                        for (var test = tst.match, loopend = c ? 1 : 0, chrs = "", i = test.cardinality; i > loopend; i--) chrs += getBufferElement(position - (i - 1));
                        if (c && (chrs += c), getBuffer(!0), !1 !== (rslt = null != test.fn ? test.fn.test(chrs, getMaskSet(), position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && "" !== test.def && {
                            c: getPlaceholder(position, test, !0) || test.def,
                            pos: position
                        })) {
                            var elem = rslt.c !== undefined ? rslt.c : c;
                            elem = elem === opts.skipOptionalPartCharacter && null === test.fn ? getPlaceholder(position, test, !0) || test.def : elem;
                            var validatedPos = position, possibleModifiedBuffer = getBuffer();
                            if (rslt.remove !== undefined && ($.isArray(rslt.remove) || (rslt.remove = [ rslt.remove ]), 
                            $.each(rslt.remove.sort(function(a, b) {
                                return b - a;
                            }), function(ndx, lmnt) {
                                stripValidPositions(lmnt, lmnt + 1, !0);
                            })), rslt.insert !== undefined && ($.isArray(rslt.insert) || (rslt.insert = [ rslt.insert ]), 
                            $.each(rslt.insert.sort(function(a, b) {
                                return a - b;
                            }), function(ndx, lmnt) {
                                isValid(lmnt.pos, lmnt.c, !0, fromSetValid);
                            })), rslt.refreshFromBuffer) {
                                var refresh = rslt.refreshFromBuffer;
                                if (refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, possibleModifiedBuffer), 
                                rslt.pos === undefined && rslt.c === undefined) return rslt.pos = getLastValidPosition(), 
                                !1;
                                if ((validatedPos = rslt.pos !== undefined ? rslt.pos : position) !== position) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0, fromSetValid)), 
                                !1;
                            } else if (!0 !== rslt && rslt.pos !== undefined && rslt.pos !== position && (validatedPos = rslt.pos, 
                            refreshFromBuffer(position, validatedPos, getBuffer().slice()), validatedPos !== position)) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0)), 
                            !1;
                            return (!0 === rslt || rslt.pos !== undefined || rslt.c !== undefined) && (ndx > 0 && resetMaskSet(!0), 
                            setValidPosition(validatedPos, $.extend({}, tst, {
                                input: casing(elem, test, validatedPos)
                            }), fromSetValid, isSelection(pos)) || (rslt = !1), !1);
                        }
                    }), rslt;
                }
                function setValidPosition(pos, validTest, fromSetValid, isSelection) {
                    if (isSelection || opts.insertMode && getMaskSet().validPositions[pos] !== undefined && fromSetValid === undefined) {
                        var i, positionsClone = $.extend(!0, {}, getMaskSet().validPositions), lvp = getLastValidPosition(undefined, !0);
                        for (i = pos; i <= lvp; i++) delete getMaskSet().validPositions[i];
                        getMaskSet().validPositions[pos] = $.extend(!0, {}, validTest);
                        var j, valid = !0, vps = getMaskSet().validPositions, needsValidation = !1, initialLength = getMaskSet().maskLength;
                        for (i = j = pos; i <= lvp; i++) {
                            var t = positionsClone[i];
                            if (t !== undefined) for (var posMatch = j; posMatch < getMaskSet().maskLength && (null === t.match.fn && vps[i] && (!0 === vps[i].match.optionalQuantifier || !0 === vps[i].match.optionality) || null != t.match.fn); ) {
                                if (posMatch++, !1 === needsValidation && positionsClone[posMatch] && positionsClone[posMatch].match.def === t.match.def) getMaskSet().validPositions[posMatch] = $.extend(!0, {}, positionsClone[posMatch]), 
                                getMaskSet().validPositions[posMatch].input = t.input, fillMissingNonMask(posMatch), 
                                j = posMatch, valid = !0; else if (positionCanMatchDefinition(posMatch, t.match.def)) {
                                    var result = isValid(posMatch, t.input, !0, !0);
                                    valid = !1 !== result, j = result.caret || result.insert ? getLastValidPosition() : posMatch, 
                                    needsValidation = !0;
                                } else if (!(valid = !0 === t.generatedInput) && posMatch >= getMaskSet().maskLength - 1) break;
                                if (getMaskSet().maskLength < initialLength && (getMaskSet().maskLength = initialLength), 
                                valid) break;
                            }
                            if (!valid) break;
                        }
                        if (!valid) return getMaskSet().validPositions = $.extend(!0, {}, positionsClone), 
                        resetMaskSet(!0), !1;
                    } else getMaskSet().validPositions[pos] = $.extend(!0, {}, validTest);
                    return resetMaskSet(!0), !0;
                }
                function fillMissingNonMask(maskPos) {
                    for (var pndx = maskPos - 1; pndx > -1 && !getMaskSet().validPositions[pndx]; pndx--) ;
                    var testTemplate, testsFromPos;
                    for (pndx++; pndx < maskPos; pndx++) getMaskSet().validPositions[pndx] === undefined && (!1 === opts.jitMasking || opts.jitMasking > pndx) && ("" === (testsFromPos = getTests(pndx, getTestTemplate(pndx - 1).locator, pndx - 1).slice())[testsFromPos.length - 1].match.def && testsFromPos.pop(), 
                    (testTemplate = determineTestTemplate(testsFromPos)) && (testTemplate.match.def === opts.radixPointDefinitionSymbol || !isMask(pndx, !0) || $.inArray(opts.radixPoint, getBuffer()) < pndx && testTemplate.match.fn && testTemplate.match.fn.test(getPlaceholder(pndx), getMaskSet(), pndx, !1, opts)) && !1 !== (result = _isValid(pndx, getPlaceholder(pndx, testTemplate.match, !0) || (null == testTemplate.match.fn ? testTemplate.match.def : "" !== getPlaceholder(pndx) ? getPlaceholder(pndx) : getBuffer()[pndx]), !0)) && (getMaskSet().validPositions[result.pos || pndx].generatedInput = !0));
                }
                strict = !0 === strict;
                var maskPos = pos;
                pos.begin !== undefined && (maskPos = isRTL && !isSelection(pos) ? pos.end : pos.begin);
                var result = !0, positionsClone = $.extend(!0, {}, getMaskSet().validPositions);
                if ($.isFunction(opts.preValidation) && !strict && !0 !== fromSetValid && !0 !== validateOnly && (result = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts)), 
                !0 === result) {
                    if (fillMissingNonMask(maskPos), isSelection(pos) && (handleRemove(undefined, Inputmask.keyCode.DELETE, pos, !0, !0), 
                    maskPos = getMaskSet().p), maskPos < getMaskSet().maskLength && (maxLength === undefined || maskPos < maxLength) && (result = _isValid(maskPos, c, strict), 
                    (!strict || !0 === fromSetValid) && !1 === result && !0 !== validateOnly)) {
                        var currentPosValid = getMaskSet().validPositions[maskPos];
                        if (!currentPosValid || null !== currentPosValid.match.fn || currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter) {
                            if ((opts.insertMode || getMaskSet().validPositions[seekNext(maskPos)] === undefined) && !isMask(maskPos, !0)) for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) if (!1 !== (result = _isValid(nPos, c, strict))) {
                                !function(originalPos, newPos) {
                                    var vp = getMaskSet().validPositions[newPos];
                                    if (vp) for (var targetLocator = vp.locator, tll = targetLocator.length, ps = originalPos; ps < newPos; ps++) if (getMaskSet().validPositions[ps] === undefined && !isMask(ps, !0)) {
                                        var tests = getTests(ps).slice(), bestMatch = determineTestTemplate(tests, !0), equality = -1;
                                        "" === tests[tests.length - 1].match.def && tests.pop(), $.each(tests, function(ndx, tst) {
                                            for (var i = 0; i < tll; i++) {
                                                if (tst.locator[i] === undefined || !checkAlternationMatch(tst.locator[i].toString().split(","), targetLocator[i].toString().split(","), tst.na)) {
                                                    var targetAI = targetLocator[i], bestMatchAI = bestMatch.locator[i], tstAI = tst.locator[i];
                                                    targetAI - bestMatchAI > Math.abs(targetAI - tstAI) && (bestMatch = tst);
                                                    break;
                                                }
                                                equality < i && (equality = i, bestMatch = tst);
                                            }
                                        }), (bestMatch = $.extend({}, bestMatch, {
                                            input: getPlaceholder(ps, bestMatch.match, !0) || bestMatch.match.def
                                        })).generatedInput = !0, setValidPosition(ps, bestMatch, !0), getMaskSet().validPositions[newPos] = undefined, 
                                        _isValid(newPos, vp.input, !0);
                                    }
                                }(maskPos, result.pos !== undefined ? result.pos : nPos), maskPos = nPos;
                                break;
                            }
                        } else result = {
                            caret: seekNext(maskPos)
                        };
                    }
                    !1 === result && opts.keepStatic && !strict && !0 !== fromAlternate && (result = function(pos, c, strict) {
                        var lastAlt, alternation, altPos, prevAltPos, i, validPos, altNdxs, decisionPos, validPsClone = $.extend(!0, {}, getMaskSet().validPositions), isValidRslt = !1, lAltPos = getLastValidPosition();
                        for (prevAltPos = getMaskSet().validPositions[lAltPos]; lAltPos >= 0; lAltPos--) if ((altPos = getMaskSet().validPositions[lAltPos]) && altPos.alternation !== undefined) {
                            if (lastAlt = lAltPos, alternation = getMaskSet().validPositions[lastAlt].alternation, 
                            prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) break;
                            prevAltPos = altPos;
                        }
                        if (alternation !== undefined) {
                            decisionPos = parseInt(lastAlt);
                            var decisionTaker = prevAltPos.locator[prevAltPos.alternation || alternation] !== undefined ? prevAltPos.locator[prevAltPos.alternation || alternation] : altNdxs[0];
                            decisionTaker.length > 0 && (decisionTaker = decisionTaker.split(",")[0]);
                            var possibilityPos = getMaskSet().validPositions[decisionPos], prevPos = getMaskSet().validPositions[decisionPos - 1];
                            $.each(getTests(decisionPos, prevPos ? prevPos.locator : undefined, decisionPos - 1), function(ndx, test) {
                                altNdxs = test.locator[alternation] ? test.locator[alternation].toString().split(",") : [];
                                for (var mndx = 0; mndx < altNdxs.length; mndx++) {
                                    var validInputs = [], staticInputsBeforePos = 0, staticInputsBeforePosAlternate = 0, verifyValidInput = !1;
                                    if (decisionTaker < altNdxs[mndx] && (test.na === undefined || -1 === $.inArray(altNdxs[mndx], test.na.split(",")) || -1 === $.inArray(decisionTaker.toString(), altNdxs))) {
                                        getMaskSet().validPositions[decisionPos] = $.extend(!0, {}, test);
                                        var possibilities = getMaskSet().validPositions[decisionPos].locator;
                                        for (getMaskSet().validPositions[decisionPos].locator[alternation] = parseInt(altNdxs[mndx]), 
                                        null == test.match.fn ? (possibilityPos.input !== test.match.def && (verifyValidInput = !0, 
                                        !0 !== possibilityPos.generatedInput && validInputs.push(possibilityPos.input)), 
                                        staticInputsBeforePosAlternate++, getMaskSet().validPositions[decisionPos].generatedInput = !/[0-9a-bA-Z]/.test(test.match.def), 
                                        getMaskSet().validPositions[decisionPos].input = test.match.def) : getMaskSet().validPositions[decisionPos].input = possibilityPos.input, 
                                        i = decisionPos + 1; i < getLastValidPosition(undefined, !0) + 1; i++) (validPos = getMaskSet().validPositions[i]) && !0 !== validPos.generatedInput && /[0-9a-bA-Z]/.test(validPos.input) ? validInputs.push(validPos.input) : i < pos && staticInputsBeforePos++, 
                                        delete getMaskSet().validPositions[i];
                                        for (verifyValidInput && validInputs[0] === test.match.def && validInputs.shift(), 
                                        resetMaskSet(!0), isValidRslt = !0; validInputs.length > 0; ) {
                                            var input = validInputs.shift();
                                            if (input !== opts.skipOptionalPartCharacter && !(isValidRslt = isValid(getLastValidPosition(undefined, !0) + 1, input, !1, fromSetValid, !0))) break;
                                        }
                                        if (isValidRslt) {
                                            getMaskSet().validPositions[decisionPos].locator = possibilities;
                                            var targetLvp = getLastValidPosition(pos) + 1;
                                            for (i = decisionPos + 1; i < getLastValidPosition() + 1; i++) ((validPos = getMaskSet().validPositions[i]) === undefined || null == validPos.match.fn) && i < pos + (staticInputsBeforePosAlternate - staticInputsBeforePos) && staticInputsBeforePosAlternate++;
                                            isValidRslt = isValid((pos += staticInputsBeforePosAlternate - staticInputsBeforePos) > targetLvp ? targetLvp : pos, c, strict, fromSetValid, !0);
                                        }
                                        if (isValidRslt) return !1;
                                        resetMaskSet(), getMaskSet().validPositions = $.extend(!0, {}, validPsClone);
                                    }
                                }
                            });
                        }
                        return isValidRslt;
                    }(maskPos, c, strict)), !0 === result && (result = {
                        pos: maskPos
                    });
                }
                if ($.isFunction(opts.postValidation) && !1 !== result && !strict && !0 !== fromSetValid && !0 !== validateOnly) {
                    var postResult = opts.postValidation(getBuffer(!0), result, opts);
                    if (postResult.refreshFromBuffer && postResult.buffer) {
                        var refresh = postResult.refreshFromBuffer;
                        refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, postResult.buffer);
                    }
                    result = !0 === postResult ? result : postResult;
                }
                return result && result.pos === undefined && (result.pos = maskPos), !1 !== result && !0 !== validateOnly || (resetMaskSet(!0), 
                getMaskSet().validPositions = $.extend(!0, {}, positionsClone)), result;
            }
            function isMask(pos, strict) {
                var test = getTestTemplate(pos).match;
                if ("" === test.def && (test = getTest(pos).match), null != test.fn) return test.fn;
                if (!0 !== strict && pos > -1) {
                    var tests = getTests(pos);
                    return tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0);
                }
                return !1;
            }
            function seekNext(pos, newBlock) {
                var maskL = getMaskSet().maskLength;
                if (pos >= maskL) return maskL;
                var position = pos;
                for (getTests(maskL + 1).length > 1 && (getMaskTemplate(!0, maskL + 1, !0), maskL = getMaskSet().maskLength); ++position < maskL && (!0 === newBlock && (!0 !== getTest(position).match.newBlockMarker || !isMask(position)) || !0 !== newBlock && !isMask(position)); ) ;
                return position;
            }
            function seekPrevious(pos, newBlock) {
                var tests, position = pos;
                if (position <= 0) return 0;
                for (;--position > 0 && (!0 === newBlock && !0 !== getTest(position).match.newBlockMarker || !0 !== newBlock && !isMask(position) && ((tests = getTests(position)).length < 2 || 2 === tests.length && "" === tests[1].match.def)); ) ;
                return position;
            }
            function getBufferElement(position) {
                return getMaskSet().validPositions[position] === undefined ? getPlaceholder(position) : getMaskSet().validPositions[position].input;
            }
            function writeBuffer(input, buffer, caretPos, event, triggerInputEvent) {
                if (event && $.isFunction(opts.onBeforeWrite)) {
                    var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);
                    if (result) {
                        if (result.refreshFromBuffer) {
                            var refresh = result.refreshFromBuffer;
                            refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer || buffer), 
                            buffer = getBuffer(!0);
                        }
                        caretPos !== undefined && (caretPos = result.caret !== undefined ? result.caret : caretPos);
                    }
                }
                input !== undefined && (input.inputmask._valueSet(buffer.join("")), caretPos === undefined || event !== undefined && "blur" === event.type ? renderColorMask(input, caretPos, 0 === buffer.length) : android && event && "input" === event.type ? setTimeout(function() {
                    caret(input, caretPos);
                }, 0) : caret(input, caretPos), !0 === triggerInputEvent && (skipInputEvent = !0, 
                $(input).trigger("input")));
            }
            function getPlaceholder(pos, test, returnPL) {
                if ((test = test || getTest(pos).match).placeholder !== undefined || !0 === returnPL) return $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;
                if (null === test.fn) {
                    if (pos > -1 && getMaskSet().validPositions[pos] === undefined) {
                        var prevTest, tests = getTests(pos), staticAlternations = [];
                        if (tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0)) for (var i = 0; i < tests.length; i++) if (!0 !== tests[i].match.optionality && !0 !== tests[i].match.optionalQuantifier && (null === tests[i].match.fn || prevTest === undefined || !1 !== tests[i].match.fn.test(prevTest.match.def, getMaskSet(), pos, !0, opts)) && (staticAlternations.push(tests[i]), 
                        null === tests[i].match.fn && (prevTest = tests[i]), staticAlternations.length > 1 && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def))) return opts.placeholder.charAt(pos % opts.placeholder.length);
                    }
                    return test.def;
                }
                return opts.placeholder.charAt(pos % opts.placeholder.length);
            }
            function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {
                function isTemplateMatch(ndx, charCodes) {
                    return -1 !== getBufferTemplate().slice(ndx, seekNext(ndx)).join("").indexOf(charCodes) && !isMask(ndx) && getTest(ndx).match.nativeDef === charCodes.charAt(charCodes.length - 1);
                }
                var inputValue = nptvl.slice(), charCodes = "", initialNdx = -1, result = undefined;
                if (resetMaskSet(), strict || !0 === opts.autoUnmask) initialNdx = seekNext(initialNdx); else {
                    var staticInput = getBufferTemplate().slice(0, seekNext(-1)).join(""), matches = inputValue.join("").match(new RegExp("^" + Inputmask.escapeRegex(staticInput), "g"));
                    matches && matches.length > 0 && (inputValue.splice(0, matches.length * staticInput.length), 
                    initialNdx = seekNext(initialNdx));
                }
                if (-1 === initialNdx ? (getMaskSet().p = seekNext(initialNdx), initialNdx = 0) : getMaskSet().p = initialNdx, 
                $.each(inputValue, function(ndx, charCode) {
                    if (charCode !== undefined) if (getMaskSet().validPositions[ndx] === undefined && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, !0) && !1 === isValid(ndx, inputValue[ndx], !0, undefined, undefined, !0)) getMaskSet().p++; else {
                        var keypress = new $.Event("_checkval");
                        keypress.which = charCode.charCodeAt(0), charCodes += charCode;
                        var lvp = getLastValidPosition(undefined, !0), lvTest = getMaskSet().validPositions[lvp], nextTest = getTestTemplate(lvp + 1, lvTest ? lvTest.locator.slice() : undefined, lvp);
                        if (!isTemplateMatch(initialNdx, charCodes) || strict || opts.autoUnmask) {
                            var pos = strict ? ndx : null == nextTest.match.fn && nextTest.match.optionality && lvp + 1 < getMaskSet().p ? lvp + 1 : getMaskSet().p;
                            result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, pos), 
                            initialNdx = pos + 1, charCodes = "";
                        } else result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, !0, lvp + 1);
                        if (!1 !== result && !strict && $.isFunction(opts.onBeforeWrite)) {
                            var origResult = result;
                            if (result = opts.onBeforeWrite.call(inputmask, keypress, getBuffer(), result.forwardPosition, opts), 
                            (result = $.extend(origResult, result)) && result.refreshFromBuffer) {
                                var refresh = result.refreshFromBuffer;
                                refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer), 
                                resetMaskSet(!0), result.caret && (getMaskSet().p = result.caret, result.forwardPosition = result.caret);
                            }
                        }
                    }
                }), writeOut) {
                    var caretPos = undefined;
                    document.activeElement === input && result && (caretPos = opts.numericInput ? seekPrevious(result.forwardPosition) : result.forwardPosition), 
                    writeBuffer(input, getBuffer(), caretPos, initiatingEvent || new $.Event("checkval"), initiatingEvent && "input" === initiatingEvent.type);
                }
            }
            function unmaskedvalue(input) {
                if (input) {
                    if (input.inputmask === undefined) return input.value;
                    input.inputmask && input.inputmask.refreshValue && EventHandlers.setValueEvent.call(input);
                }
                var umValue = [], vps = getMaskSet().validPositions;
                for (var pndx in vps) vps[pndx].match && null != vps[pndx].match.fn && umValue.push(vps[pndx].input);
                var unmaskedValue = 0 === umValue.length ? "" : (isRTL ? umValue.reverse() : umValue).join("");
                if ($.isFunction(opts.onUnMask)) {
                    var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join("");
                    unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);
                }
                return unmaskedValue;
            }
            function caret(input, begin, end, notranslate) {
                function translatePosition(pos) {
                    return !0 === notranslate || !isRTL || "number" != typeof pos || opts.greedy && "" === opts.placeholder || (pos = getBuffer().join("").length - pos), 
                    pos;
                }
                var range;
                if (begin === undefined) return input.setSelectionRange ? (begin = input.selectionStart, 
                end = input.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== input && range.commonAncestorContainer !== input || (begin = range.startOffset, 
                end = range.endOffset) : document.selection && document.selection.createRange && (end = (begin = 0 - (range = document.selection.createRange()).duplicate().moveStart("character", -input.inputmask._valueGet().length)) + range.text.length), 
                {
                    begin: translatePosition(begin),
                    end: translatePosition(end)
                };
                if (begin.begin !== undefined && (end = begin.end, begin = begin.begin), "number" == typeof begin) {
                    begin = translatePosition(begin), end = "number" == typeof (end = translatePosition(end)) ? end : begin;
                    var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;
                    if (input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0, mobile || !1 !== opts.insertMode || begin !== end || end++, 
                    input.setSelectionRange) input.selectionStart = begin, input.selectionEnd = end; else if (window.getSelection) {
                        if (range = document.createRange(), input.firstChild === undefined || null === input.firstChild) {
                            var textNode = document.createTextNode("");
                            input.appendChild(textNode);
                        }
                        range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length), 
                        range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length), 
                        range.collapse(!0);
                        var sel = window.getSelection();
                        sel.removeAllRanges(), sel.addRange(range);
                    } else input.createTextRange && ((range = input.createTextRange()).collapse(!0), 
                    range.moveEnd("character", end), range.moveStart("character", begin), range.select());
                    renderColorMask(input, {
                        begin: begin,
                        end: end
                    });
                }
            }
            function determineLastRequiredPosition(returnDefinition) {
                var pos, testPos, buffer = getBuffer(), bl = buffer.length, lvp = getLastValidPosition(), positions = {}, lvTest = getMaskSet().validPositions[lvp], ndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined;
                for (pos = lvp + 1; pos < buffer.length; pos++) ndxIntlzr = (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1)).locator.slice(), 
                positions[pos] = $.extend(!0, {}, testPos);
                var lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;
                for (pos = bl - 1; pos > lvp && (((testPos = positions[pos]).match.optionality || testPos.match.optionalQuantifier && testPos.match.newBlockMarker || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && null != testPos.match.fn || null === testPos.match.fn && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAlt.toString().split(",")) && "" !== getTests(pos)[0].def)) && buffer[pos] === getPlaceholder(pos, testPos.match)); pos--) bl--;
                return returnDefinition ? {
                    l: bl,
                    def: positions[bl] ? positions[bl].match : undefined
                } : bl;
            }
            function clearOptionalTail(buffer) {
                for (var validPos, rl = determineLastRequiredPosition(), bl = buffer.length, lv = getMaskSet().validPositions[getLastValidPosition()]; rl < bl && !isMask(rl, !0) && (validPos = lv !== undefined ? getTestTemplate(rl, lv.locator.slice(""), lv) : getTest(rl)) && !0 !== validPos.match.optionality && (!0 !== validPos.match.optionalQuantifier && !0 !== validPos.match.newBlockMarker || rl + 1 === bl && "" === (lv !== undefined ? getTestTemplate(rl + 1, lv.locator.slice(""), lv) : getTest(rl + 1)).match.def); ) rl++;
                for (;(validPos = getMaskSet().validPositions[rl - 1]) && validPos && validPos.match.optionality && validPos.input === opts.skipOptionalPartCharacter; ) rl--;
                return buffer.splice(rl), buffer;
            }
            function isComplete(buffer) {
                if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);
                if ("*" === opts.repeat) return undefined;
                var complete = !1, lrp = determineLastRequiredPosition(!0), aml = seekPrevious(lrp.l);
                if (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
                    complete = !0;
                    for (var i = 0; i <= aml; i++) {
                        var test = getTestTemplate(i).match;
                        if (null !== test.fn && getMaskSet().validPositions[i] === undefined && !0 !== test.optionality && !0 !== test.optionalQuantifier || null === test.fn && buffer[i] !== getPlaceholder(i, test)) {
                            complete = !1;
                            break;
                        }
                    }
                }
                return complete;
            }
            function handleRemove(input, k, pos, strict, fromIsValid) {
                if ((opts.numericInput || isRTL) && (k === Inputmask.keyCode.BACKSPACE ? k = Inputmask.keyCode.DELETE : k === Inputmask.keyCode.DELETE && (k = Inputmask.keyCode.BACKSPACE), 
                isRTL)) {
                    var pend = pos.end;
                    pos.end = pos.begin, pos.begin = pend;
                }
                k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1 || !1 === opts.insertMode) ? (pos.begin = seekPrevious(pos.begin), 
                getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator && pos.begin--) : k === Inputmask.keyCode.DELETE && pos.begin === pos.end && (pos.end = isMask(pos.end, !0) && getMaskSet().validPositions[pos.end] && getMaskSet().validPositions[pos.end].input !== opts.radixPoint ? pos.end + 1 : seekNext(pos.end) + 1, 
                getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator && pos.end++), 
                stripValidPositions(pos.begin, pos.end, !1, strict), !0 !== strict && function() {
                    if (opts.keepStatic) {
                        for (var validInputs = [], lastAlt = getLastValidPosition(-1, !0), positionsClone = $.extend(!0, {}, getMaskSet().validPositions), prevAltPos = getMaskSet().validPositions[lastAlt]; lastAlt >= 0; lastAlt--) {
                            var altPos = getMaskSet().validPositions[lastAlt];
                            if (altPos) {
                                if (!0 !== altPos.generatedInput && /[0-9a-bA-Z]/.test(altPos.input) && validInputs.push(altPos.input), 
                                delete getMaskSet().validPositions[lastAlt], altPos.alternation !== undefined && altPos.locator[altPos.alternation] !== prevAltPos.locator[altPos.alternation]) break;
                                prevAltPos = altPos;
                            }
                        }
                        if (lastAlt > -1) for (getMaskSet().p = seekNext(getLastValidPosition(-1, !0)); validInputs.length > 0; ) {
                            var keypress = new $.Event("keypress");
                            keypress.which = validInputs.pop().charCodeAt(0), EventHandlers.keypressEvent.call(input, keypress, !0, !1, !1, getMaskSet().p);
                        } else getMaskSet().validPositions = $.extend(!0, {}, positionsClone);
                    }
                }();
                var lvp = getLastValidPosition(pos.begin, !0);
                if (lvp < pos.begin) getMaskSet().p = seekNext(lvp); else if (!0 !== strict && (getMaskSet().p = pos.begin, 
                !0 !== fromIsValid)) for (;getMaskSet().p < lvp && getMaskSet().validPositions[getMaskSet().p] === undefined; ) getMaskSet().p++;
            }
            function initializeColorMask(input) {
                function findCaretPos(clientx) {
                    var caretPos, e = document.createElement("span");
                    for (var style in computedStyle) isNaN(style) && -1 !== style.indexOf("font") && (e.style[style] = computedStyle[style]);
                    e.style.textTransform = computedStyle.textTransform, e.style.letterSpacing = computedStyle.letterSpacing, 
                    e.style.position = "absolute", e.style.height = "auto", e.style.width = "auto", 
                    e.style.visibility = "hidden", e.style.whiteSpace = "nowrap", document.body.appendChild(e);
                    var itl, inputText = input.inputmask._valueGet(), previousWidth = 0;
                    for (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos++) {
                        if (e.innerHTML += inputText.charAt(caretPos) || "_", e.offsetWidth >= clientx) {
                            var offset1 = clientx - previousWidth, offset2 = e.offsetWidth - clientx;
                            e.innerHTML = inputText.charAt(caretPos), caretPos = (offset1 -= e.offsetWidth / 3) < offset2 ? caretPos - 1 : caretPos;
                            break;
                        }
                        previousWidth = e.offsetWidth;
                    }
                    return document.body.removeChild(e), caretPos;
                }
                var computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null), template = document.createElement("div");
                template.style.width = computedStyle.width, template.style.textAlign = computedStyle.textAlign, 
                (colorMask = document.createElement("div")).className = "im-colormask", input.parentNode.insertBefore(colorMask, input), 
                input.parentNode.removeChild(input), colorMask.appendChild(template), colorMask.appendChild(input), 
                input.style.left = template.offsetLeft + "px", $(input).on("click", function(e) {
                    return caret(input, findCaretPos(e.clientX)), EventHandlers.clickEvent.call(input, [ e ]);
                }), $(input).on("keydown", function(e) {
                    e.shiftKey || !1 === opts.insertMode || setTimeout(function() {
                        renderColorMask(input);
                    }, 0);
                });
            }
            function renderColorMask(input, caretPos, clear) {
                function handleStatic() {
                    isStatic || null !== test.fn && testPos.input !== undefined ? isStatic && (null !== test.fn && testPos.input !== undefined || "" === test.def) && (isStatic = !1, 
                    maskTemplate += "</span>") : (isStatic = !0, maskTemplate += "<span class='im-static'>");
                }
                function handleCaret(force) {
                    !0 !== force && pos !== caretPos.begin || document.activeElement !== input || (maskTemplate += "<span class='im-caret' style='border-right-width: 1px;border-right-style: solid;'></span>");
                }
                var test, testPos, ndxIntlzr, maskTemplate = "", isStatic = !1, pos = 0;
                if (colorMask !== undefined) {
                    var buffer = getBuffer();
                    if (caretPos === undefined ? caretPos = caret(input) : caretPos.begin === undefined && (caretPos = {
                        begin: caretPos,
                        end: caretPos
                    }), !0 !== clear) {
                        var lvp = getLastValidPosition();
                        do {
                            handleCaret(), getMaskSet().validPositions[pos] ? (testPos = getMaskSet().validPositions[pos], 
                            test = testPos.match, ndxIntlzr = testPos.locator.slice(), handleStatic(), maskTemplate += buffer[pos]) : (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), 
                            test = testPos.match, ndxIntlzr = testPos.locator.slice(), (!1 === opts.jitMasking || pos < lvp || "number" == typeof opts.jitMasking && isFinite(opts.jitMasking) && opts.jitMasking > pos) && (handleStatic(), 
                            maskTemplate += getPlaceholder(pos, test))), pos++;
                        } while ((maxLength === undefined || pos < maxLength) && (null !== test.fn || "" !== test.def) || lvp > pos || isStatic);
                        -1 === maskTemplate.indexOf("im-caret") && handleCaret(!0), isStatic && handleStatic();
                    }
                    var template = colorMask.getElementsByTagName("div")[0];
                    template.innerHTML = maskTemplate, input.inputmask.positionColorMask(input, template);
                }
            }
            maskset = maskset || this.maskset, opts = opts || this.opts;
            var undoValue, $el, maxLength, colorMask, inputmask = this, el = this.el, isRTL = this.isRTL, skipKeyPressEvent = !1, skipInputEvent = !1, ignorable = !1, mouseEnter = !1, EventRuler = {
                on: function(input, eventName, eventHandler) {
                    var ev = function(e) {
                        if (this.inputmask === undefined && "FORM" !== this.nodeName) {
                            var imOpts = $.data(this, "_inputmask_opts");
                            imOpts ? new Inputmask(imOpts).mask(this) : EventRuler.off(this);
                        } else {
                            if ("setvalue" === e.type || "FORM" === this.nodeName || !(this.disabled || this.readOnly && !("keydown" === e.type && e.ctrlKey && 67 === e.keyCode || !1 === opts.tabThrough && e.keyCode === Inputmask.keyCode.TAB))) {
                                switch (e.type) {
                                  case "input":
                                    if (!0 === skipInputEvent) return skipInputEvent = !1, e.preventDefault();
                                    break;

                                  case "keydown":
                                    skipKeyPressEvent = !1, skipInputEvent = !1;
                                    break;

                                  case "keypress":
                                    if (!0 === skipKeyPressEvent) return e.preventDefault();
                                    skipKeyPressEvent = !0;
                                    break;

                                  case "click":
                                    if (iemobile || iphone) {
                                        var that = this, args = arguments;
                                        return setTimeout(function() {
                                            eventHandler.apply(that, args);
                                        }, 0), !1;
                                    }
                                }
                                var returnVal = eventHandler.apply(this, arguments);
                                return !1 === returnVal && (e.preventDefault(), e.stopPropagation()), returnVal;
                            }
                            e.preventDefault();
                        }
                    };
                    input.inputmask.events[eventName] = input.inputmask.events[eventName] || [], input.inputmask.events[eventName].push(ev), 
                    -1 !== $.inArray(eventName, [ "submit", "reset" ]) ? null !== input.form && $(input.form).on(eventName, ev) : $(input).on(eventName, ev);
                },
                off: function(input, event) {
                    if (input.inputmask && input.inputmask.events) {
                        var events;
                        event ? (events = [])[event] = input.inputmask.events[event] : events = input.inputmask.events, 
                        $.each(events, function(eventName, evArr) {
                            for (;evArr.length > 0; ) {
                                var ev = evArr.pop();
                                -1 !== $.inArray(eventName, [ "submit", "reset" ]) ? null !== input.form && $(input.form).off(eventName, ev) : $(input).off(eventName, ev);
                            }
                            delete input.inputmask.events[eventName];
                        });
                    }
                }
            }, EventHandlers = {
                keydownEvent: function(e) {
                    var input = this, $input = $(input), k = e.keyCode, pos = caret(input);
                    if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI || e.ctrlKey && k === Inputmask.keyCode.X && !function(eventName) {
                        var el = document.createElement("input"), evName = "on" + eventName, isSupported = evName in el;
                        return isSupported || (el.setAttribute(evName, "return;"), isSupported = "function" == typeof el[evName]), 
                        el = null, isSupported;
                    }("cut")) e.preventDefault(), handleRemove(input, k, pos), writeBuffer(input, getBuffer(!0), getMaskSet().p, e, input.inputmask._valueGet() !== getBuffer().join("")), 
                    input.inputmask._valueGet() === getBufferTemplate().join("") ? $input.trigger("cleared") : !0 === isComplete(getBuffer()) && $input.trigger("complete"); else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) {
                        e.preventDefault();
                        var caretPos = seekNext(getLastValidPosition());
                        opts.insertMode || caretPos !== getMaskSet().maskLength || e.shiftKey || caretPos--, 
                        caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, !0);
                    } else k === Inputmask.keyCode.HOME && !e.shiftKey || k === Inputmask.keyCode.PAGE_UP ? (e.preventDefault(), 
                    caret(input, 0, e.shiftKey ? pos.begin : 0, !0)) : (opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE || 90 === k && e.ctrlKey) && !0 !== e.altKey ? (checkVal(input, !0, !1, undoValue.split("")), 
                    $input.trigger("click")) : k !== Inputmask.keyCode.INSERT || e.shiftKey || e.ctrlKey ? !0 === opts.tabThrough && k === Inputmask.keyCode.TAB ? (!0 === e.shiftKey ? (null === getTest(pos.begin).match.fn && (pos.begin = seekNext(pos.begin)), 
                    pos.end = seekPrevious(pos.begin, !0), pos.begin = seekPrevious(pos.end, !0)) : (pos.begin = seekNext(pos.begin, !0), 
                    pos.end = seekNext(pos.begin, !0), pos.end < getMaskSet().maskLength && pos.end--), 
                    pos.begin < getMaskSet().maskLength && (e.preventDefault(), caret(input, pos.begin, pos.end))) : e.shiftKey || !1 === opts.insertMode && (k === Inputmask.keyCode.RIGHT ? setTimeout(function() {
                        var caretPos = caret(input);
                        caret(input, caretPos.begin);
                    }, 0) : k === Inputmask.keyCode.LEFT && setTimeout(function() {
                        var caretPos = caret(input);
                        caret(input, isRTL ? caretPos.begin + 1 : caretPos.begin - 1);
                    }, 0)) : (opts.insertMode = !opts.insertMode, caret(input, opts.insertMode || pos.begin !== getMaskSet().maskLength ? pos.begin : pos.begin - 1));
                    opts.onKeyDown.call(this, e, getBuffer(), caret(input).begin, opts), ignorable = -1 !== $.inArray(k, opts.ignorables);
                },
                keypressEvent: function(e, checkval, writeOut, strict, ndx) {
                    var input = this, $input = $(input), k = e.which || e.charCode || e.keyCode;
                    if (!(!0 === checkval || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable)) return k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join("") && (undoValue = getBuffer().join(""), 
                    setTimeout(function() {
                        $input.trigger("change");
                    }, 0)), !0;
                    if (k) {
                        46 === k && !1 === e.shiftKey && "" !== opts.radixPoint && (k = opts.radixPoint.charCodeAt(0));
                        var forwardPosition, pos = checkval ? {
                            begin: ndx,
                            end: ndx
                        } : caret(input), c = String.fromCharCode(k);
                        getMaskSet().writeOutBuffer = !0;
                        var valResult = isValid(pos, c, strict);
                        if (!1 !== valResult && (resetMaskSet(!0), forwardPosition = valResult.caret !== undefined ? valResult.caret : checkval ? valResult.pos + 1 : seekNext(valResult.pos), 
                        getMaskSet().p = forwardPosition), !1 !== writeOut && (setTimeout(function() {
                            opts.onKeyValidation.call(input, k, valResult, opts);
                        }, 0), getMaskSet().writeOutBuffer && !1 !== valResult)) {
                            var buffer = getBuffer();
                            writeBuffer(input, buffer, opts.numericInput && valResult.caret === undefined ? seekPrevious(forwardPosition) : forwardPosition, e, !0 !== checkval), 
                            !0 !== checkval && setTimeout(function() {
                                !0 === isComplete(buffer) && $input.trigger("complete");
                            }, 0);
                        }
                        if (e.preventDefault(), checkval) return !1 !== valResult && (valResult.forwardPosition = forwardPosition), 
                        valResult;
                    }
                },
                pasteEvent: function(e) {
                    var tempValue, input = this, ev = e.originalEvent || e, $input = $(input), inputValue = input.inputmask._valueGet(!0), caretPos = caret(input);
                    isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue);
                    var valueBeforeCaret = inputValue.substr(0, caretPos.begin), valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);
                    if (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join("") && (valueBeforeCaret = ""), 
                    valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join("") && (valueAfterCaret = ""), 
                    isRTL && (tempValue = valueBeforeCaret, valueBeforeCaret = valueAfterCaret, valueAfterCaret = tempValue), 
                    window.clipboardData && window.clipboardData.getData) inputValue = valueBeforeCaret + window.clipboardData.getData("Text") + valueAfterCaret; else {
                        if (!ev.clipboardData || !ev.clipboardData.getData) return !0;
                        inputValue = valueBeforeCaret + ev.clipboardData.getData("text/plain") + valueAfterCaret;
                    }
                    var pasteValue = inputValue;
                    if ($.isFunction(opts.onBeforePaste)) {
                        if (!1 === (pasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts))) return e.preventDefault();
                        pasteValue || (pasteValue = inputValue);
                    }
                    return checkVal(input, !1, !1, isRTL ? pasteValue.split("").reverse() : pasteValue.toString().split("")), 
                    writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join("")), 
                    !0 === isComplete(getBuffer()) && $input.trigger("complete"), e.preventDefault();
                },
                inputFallBackEvent: function(e) {
                    var input = this, inputValue = input.inputmask._valueGet();
                    if (getBuffer().join("") !== inputValue) {
                        var caretPos = caret(input);
                        if (!1 === function(input, inputValue, caretPos) {
                            if ("." === inputValue.charAt(caretPos.begin - 1) && "" !== opts.radixPoint && ((inputValue = inputValue.split(""))[caretPos.begin - 1] = opts.radixPoint.charAt(0), 
                            inputValue = inputValue.join("")), inputValue.charAt(caretPos.begin - 1) === opts.radixPoint && inputValue.length > getBuffer().length) {
                                var keypress = new $.Event("keypress");
                                return keypress.which = opts.radixPoint.charCodeAt(0), EventHandlers.keypressEvent.call(input, keypress, !0, !0, !1, caretPos.begin - 1), 
                                !1;
                            }
                        }(input, inputValue, caretPos)) return !1;
                        if (inputValue = inputValue.replace(new RegExp("(" + Inputmask.escapeRegex(getBufferTemplate().join("")) + ")*"), ""), 
                        !1 === function(input, inputValue, caretPos) {
                            if (iemobile) {
                                var inputChar = inputValue.replace(getBuffer().join(""), "");
                                if (1 === inputChar.length) {
                                    var keypress = new $.Event("keypress");
                                    return keypress.which = inputChar.charCodeAt(0), EventHandlers.keypressEvent.call(input, keypress, !0, !0, !1, getMaskSet().validPositions[caretPos.begin - 1] ? caretPos.begin : caretPos.begin - 1), 
                                    !1;
                                }
                            }
                        }(input, inputValue, caretPos)) return !1;
                        caretPos.begin > inputValue.length && (caret(input, inputValue.length), caretPos = caret(input));
                        var buffer = getBuffer().join(""), frontPart = inputValue.substr(0, caretPos.begin), backPart = inputValue.substr(caretPos.begin), frontBufferPart = buffer.substr(0, caretPos.begin), backBufferPart = buffer.substr(caretPos.begin), selection = caretPos, entries = "", isEntry = !1;
                        if (frontPart !== frontBufferPart) {
                            selection.begin = 0;
                            for (var fpl = (isEntry = frontPart.length >= frontBufferPart.length) ? frontPart.length : frontBufferPart.length, i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < fpl; i++) selection.begin++;
                            isEntry && (entries += frontPart.slice(selection.begin, selection.end));
                        }
                        backPart !== backBufferPart && (backPart.length > backBufferPart.length ? isEntry && (selection.end = selection.begin) : backPart.length < backBufferPart.length ? selection.end += backBufferPart.length - backPart.length : backPart.charAt(0) !== backBufferPart.charAt(0) && selection.end++), 
                        writeBuffer(input, getBuffer(), selection), entries.length > 0 ? $.each(entries.split(""), function(ndx, entry) {
                            var keypress = new $.Event("keypress");
                            keypress.which = entry.charCodeAt(0), ignorable = !1, EventHandlers.keypressEvent.call(input, keypress);
                        }) : (selection.begin === selection.end - 1 && caret(input, seekPrevious(selection.begin + 1), selection.end), 
                        e.keyCode = Inputmask.keyCode.DELETE, EventHandlers.keydownEvent.call(input, e)), 
                        e.preventDefault();
                    }
                },
                setValueEvent: function(e) {
                    this.inputmask.refreshValue = !1;
                    var input = this, value = input.inputmask._valueGet(!0);
                    $.isFunction(opts.onBeforeMask) && (value = opts.onBeforeMask.call(inputmask, value, opts) || value), 
                    value = value.split(""), checkVal(input, !0, !1, isRTL ? value.reverse() : value), 
                    undoValue = getBuffer().join(""), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join("") && input.inputmask._valueSet("");
                },
                focusEvent: function(e) {
                    var input = this, nptValue = input.inputmask._valueGet();
                    opts.showMaskOnFocus && (!opts.showMaskOnHover || opts.showMaskOnHover && "" === nptValue) && (input.inputmask._valueGet() !== getBuffer().join("") ? writeBuffer(input, getBuffer(), seekNext(getLastValidPosition())) : !1 === mouseEnter && caret(input, seekNext(getLastValidPosition()))), 
                    !0 === opts.positionCaretOnTab && !1 === mouseEnter && "" !== nptValue && (writeBuffer(input, getBuffer(), caret(input)), 
                    EventHandlers.clickEvent.apply(input, [ e, !0 ])), undoValue = getBuffer().join("");
                },
                mouseleaveEvent: function(e) {
                    var input = this;
                    if (mouseEnter = !1, opts.clearMaskOnLostFocus && document.activeElement !== input) {
                        var buffer = getBuffer().slice(), nptValue = input.inputmask._valueGet();
                        nptValue !== input.getAttribute("placeholder") && "" !== nptValue && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join("") ? buffer = [] : clearOptionalTail(buffer), 
                        writeBuffer(input, buffer));
                    }
                },
                clickEvent: function(e, tabbed) {
                    function doRadixFocus(clickPos) {
                        if ("" !== opts.radixPoint) {
                            var vps = getMaskSet().validPositions;
                            if (vps[clickPos] === undefined || vps[clickPos].input === getPlaceholder(clickPos)) {
                                if (clickPos < seekNext(-1)) return !0;
                                var radixPos = $.inArray(opts.radixPoint, getBuffer());
                                if (-1 !== radixPos) {
                                    for (var vp in vps) if (radixPos < vp && vps[vp].input !== getPlaceholder(vp)) return !1;
                                    return !0;
                                }
                            }
                        }
                        return !1;
                    }
                    var input = this;
                    setTimeout(function() {
                        if (document.activeElement === input) {
                            var selectedCaret = caret(input);
                            if (tabbed && (isRTL ? selectedCaret.end = selectedCaret.begin : selectedCaret.begin = selectedCaret.end), 
                            selectedCaret.begin === selectedCaret.end) switch (opts.positionCaretOnClick) {
                              case "none":
                                break;

                              case "radixFocus":
                                if (doRadixFocus(selectedCaret.begin)) {
                                    var radixPos = getBuffer().join("").indexOf(opts.radixPoint);
                                    caret(input, opts.numericInput ? seekNext(radixPos) : radixPos);
                                    break;
                                }

                              default:
                                var clickPosition = selectedCaret.begin, lvclickPosition = getLastValidPosition(clickPosition, !0), lastPosition = seekNext(lvclickPosition);
                                if (clickPosition < lastPosition) caret(input, isMask(clickPosition, !0) || isMask(clickPosition - 1, !0) ? clickPosition : seekNext(clickPosition)); else {
                                    var lvp = getMaskSet().validPositions[lvclickPosition], tt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : undefined, lvp), placeholder = getPlaceholder(lastPosition, tt.match);
                                    if ("" !== placeholder && getBuffer()[lastPosition] !== placeholder && !0 !== tt.match.optionalQuantifier && !0 !== tt.match.newBlockMarker || !isMask(lastPosition, !0) && tt.match.def === placeholder) {
                                        var newPos = seekNext(lastPosition);
                                        (clickPosition >= newPos || clickPosition === lastPosition) && (lastPosition = newPos);
                                    }
                                    caret(input, lastPosition);
                                }
                            }
                        }
                    }, 0);
                },
                dblclickEvent: function(e) {
                    var input = this;
                    setTimeout(function() {
                        caret(input, 0, seekNext(getLastValidPosition()));
                    }, 0);
                },
                cutEvent: function(e) {
                    var input = this, $input = $(input), pos = caret(input), ev = e.originalEvent || e, clipboardData = window.clipboardData || ev.clipboardData, clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);
                    clipboardData.setData("text", isRTL ? clipData.reverse().join("") : clipData.join("")), 
                    document.execCommand && document.execCommand("copy"), handleRemove(input, Inputmask.keyCode.DELETE, pos), 
                    writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join("")), 
                    input.inputmask._valueGet() === getBufferTemplate().join("") && $input.trigger("cleared");
                },
                blurEvent: function(e) {
                    var $input = $(this), input = this;
                    if (input.inputmask) {
                        var nptValue = input.inputmask._valueGet(), buffer = getBuffer().slice();
                        "" !== nptValue && (opts.clearMaskOnLostFocus && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join("") ? buffer = [] : clearOptionalTail(buffer)), 
                        !1 === isComplete(buffer) && (setTimeout(function() {
                            $input.trigger("incomplete");
                        }, 0), opts.clearIncomplete && (resetMaskSet(), buffer = opts.clearMaskOnLostFocus ? [] : getBufferTemplate().slice())), 
                        writeBuffer(input, buffer, undefined, e)), undoValue !== getBuffer().join("") && (undoValue = buffer.join(""), 
                        $input.trigger("change"));
                    }
                },
                mouseenterEvent: function(e) {
                    var input = this;
                    mouseEnter = !0, document.activeElement !== input && opts.showMaskOnHover && input.inputmask._valueGet() !== getBuffer().join("") && writeBuffer(input, getBuffer());
                },
                submitEvent: function(e) {
                    undoValue !== getBuffer().join("") && $el.trigger("change"), opts.clearMaskOnLostFocus && -1 === getLastValidPosition() && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join("") && el.inputmask._valueSet(""), 
                    opts.removeMaskOnSubmit && (el.inputmask._valueSet(el.inputmask.unmaskedvalue(), !0), 
                    setTimeout(function() {
                        writeBuffer(el, getBuffer());
                    }, 0));
                },
                resetEvent: function(e) {
                    el.inputmask.refreshValue = !0, setTimeout(function() {
                        $el.trigger("setvalue");
                    }, 0);
                }
            };
            Inputmask.prototype.positionColorMask = function(input, template) {
                input.style.left = template.offsetLeft + "px";
            };
            var valueBuffer;
            if (actionObj !== undefined) switch (actionObj.action) {
              case "isComplete":
                return el = actionObj.el, isComplete(getBuffer());

              case "unmaskedvalue":
                return el !== undefined && actionObj.value === undefined || (valueBuffer = actionObj.value, 
                valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer : valueBuffer).split(""), 
                checkVal(undefined, !1, !1, isRTL ? valueBuffer.reverse() : valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite.call(inputmask, undefined, getBuffer(), 0, opts)), 
                unmaskedvalue(el);

              case "mask":
                !function(elem) {
                    EventRuler.off(elem);
                    var isSupported = function(input, opts) {
                        var elementType = input.getAttribute("type"), isSupported = "INPUT" === input.tagName && -1 !== $.inArray(elementType, opts.supportsInputType) || input.isContentEditable || "TEXTAREA" === input.tagName;
                        if (!isSupported) if ("INPUT" === input.tagName) {
                            var el = document.createElement("input");
                            el.setAttribute("type", elementType), isSupported = "text" === el.type, el = null;
                        } else isSupported = "partial";
                        return !1 !== isSupported ? function(npt) {
                            function getter() {
                                return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== getLastValidPosition() || !0 !== opts.nullable ? document.activeElement === this && opts.clearMaskOnLostFocus ? (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join("") : valueGet.call(this) : "" : valueGet.call(this);
                            }
                            function setter(value) {
                                valueSet.call(this, value), this.inputmask && $(this).trigger("setvalue");
                            }
                            var valueGet, valueSet;
                            if (!npt.inputmask.__valueGet) {
                                if (!0 !== opts.noValuePatching) {
                                    if (Object.getOwnPropertyDescriptor) {
                                        "function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === _typeof("test".__proto__) ? function(object) {
                                            return object.__proto__;
                                        } : function(object) {
                                            return object.constructor.prototype;
                                        });
                                        var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), "value") : undefined;
                                        valueProperty && valueProperty.get && valueProperty.set ? (valueGet = valueProperty.get, 
                                        valueSet = valueProperty.set, Object.defineProperty(npt, "value", {
                                            get: getter,
                                            set: setter,
                                            configurable: !0
                                        })) : "INPUT" !== npt.tagName && (valueGet = function() {
                                            return this.textContent;
                                        }, valueSet = function(value) {
                                            this.textContent = value;
                                        }, Object.defineProperty(npt, "value", {
                                            get: getter,
                                            set: setter,
                                            configurable: !0
                                        }));
                                    } else document.__lookupGetter__ && npt.__lookupGetter__("value") && (valueGet = npt.__lookupGetter__("value"), 
                                    valueSet = npt.__lookupSetter__("value"), npt.__defineGetter__("value", getter), 
                                    npt.__defineSetter__("value", setter));
                                    npt.inputmask.__valueGet = valueGet, npt.inputmask.__valueSet = valueSet;
                                }
                                npt.inputmask._valueGet = function(overruleRTL) {
                                    return isRTL && !0 !== overruleRTL ? valueGet.call(this.el).split("").reverse().join("") : valueGet.call(this.el);
                                }, npt.inputmask._valueSet = function(value, overruleRTL) {
                                    valueSet.call(this.el, null === value || value === undefined ? "" : !0 !== overruleRTL && isRTL ? value.split("").reverse().join("") : value);
                                }, valueGet === undefined && (valueGet = function() {
                                    return this.value;
                                }, valueSet = function(value) {
                                    this.value = value;
                                }, function(type) {
                                    if ($.valHooks && ($.valHooks[type] === undefined || !0 !== $.valHooks[type].inputmaskpatch)) {
                                        var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function(elem) {
                                            return elem.value;
                                        }, valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function(elem, value) {
                                            return elem.value = value, elem;
                                        };
                                        $.valHooks[type] = {
                                            get: function(elem) {
                                                if (elem.inputmask) {
                                                    if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue();
                                                    var result = valhookGet(elem);
                                                    return -1 !== getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) || !0 !== opts.nullable ? result : "";
                                                }
                                                return valhookGet(elem);
                                            },
                                            set: function(elem, value) {
                                                var result, $elem = $(elem);
                                                return result = valhookSet(elem, value), elem.inputmask && $elem.trigger("setvalue"), 
                                                result;
                                            },
                                            inputmaskpatch: !0
                                        };
                                    }
                                }(npt.type), function(npt) {
                                    EventRuler.on(npt, "mouseenter", function(event) {
                                        var $input = $(this);
                                        this.inputmask._valueGet() !== getBuffer().join("") && $input.trigger("setvalue");
                                    });
                                }(npt));
                            }
                        }(input) : input.inputmask = undefined, isSupported;
                    }(elem, opts);
                    if (!1 !== isSupported && (el = elem, $el = $(el), -1 === (maxLength = el !== undefined ? el.maxLength : undefined) && (maxLength = undefined), 
                    !0 === opts.colorMask && initializeColorMask(el), android && (el.hasOwnProperty("inputmode") && (el.inputmode = opts.inputmode, 
                    el.setAttribute("inputmode", opts.inputmode)), "rtfm" === opts.androidHack && (!0 !== opts.colorMask && initializeColorMask(el), 
                    el.type = "password")), !0 === isSupported && (EventRuler.on(el, "submit", EventHandlers.submitEvent), 
                    EventRuler.on(el, "reset", EventHandlers.resetEvent), EventRuler.on(el, "mouseenter", EventHandlers.mouseenterEvent), 
                    EventRuler.on(el, "blur", EventHandlers.blurEvent), EventRuler.on(el, "focus", EventHandlers.focusEvent), 
                    EventRuler.on(el, "mouseleave", EventHandlers.mouseleaveEvent), !0 !== opts.colorMask && EventRuler.on(el, "click", EventHandlers.clickEvent), 
                    EventRuler.on(el, "dblclick", EventHandlers.dblclickEvent), EventRuler.on(el, "paste", EventHandlers.pasteEvent), 
                    EventRuler.on(el, "dragdrop", EventHandlers.pasteEvent), EventRuler.on(el, "drop", EventHandlers.pasteEvent), 
                    EventRuler.on(el, "cut", EventHandlers.cutEvent), EventRuler.on(el, "complete", opts.oncomplete), 
                    EventRuler.on(el, "incomplete", opts.onincomplete), EventRuler.on(el, "cleared", opts.oncleared), 
                    android || !0 === opts.inputEventOnly ? el.removeAttribute("maxLength") : (EventRuler.on(el, "keydown", EventHandlers.keydownEvent), 
                    EventRuler.on(el, "keypress", EventHandlers.keypressEvent)), EventRuler.on(el, "compositionstart", $.noop), 
                    EventRuler.on(el, "compositionupdate", $.noop), EventRuler.on(el, "compositionend", $.noop), 
                    EventRuler.on(el, "keyup", $.noop), EventRuler.on(el, "input", EventHandlers.inputFallBackEvent), 
                    EventRuler.on(el, "beforeinput", $.noop)), EventRuler.on(el, "setvalue", EventHandlers.setValueEvent), 
                    undoValue = getBufferTemplate().join(""), "" !== el.inputmask._valueGet(!0) || !1 === opts.clearMaskOnLostFocus || document.activeElement === el)) {
                        var initialValue = $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(inputmask, el.inputmask._valueGet(!0), opts) || el.inputmask._valueGet(!0) : el.inputmask._valueGet(!0);
                        "" !== initialValue && checkVal(el, !0, !1, isRTL ? initialValue.split("").reverse() : initialValue.split(""));
                        var buffer = getBuffer().slice();
                        undoValue = buffer.join(""), !1 === isComplete(buffer) && opts.clearIncomplete && resetMaskSet(), 
                        opts.clearMaskOnLostFocus && document.activeElement !== el && (-1 === getLastValidPosition() ? buffer = [] : clearOptionalTail(buffer)), 
                        writeBuffer(el, buffer), document.activeElement === el && caret(el, seekNext(getLastValidPosition()));
                    }
                }(el);
                break;

              case "format":
                return valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value : actionObj.value).split(""), 
                checkVal(undefined, !0, !1, isRTL ? valueBuffer.reverse() : valueBuffer), actionObj.metadata ? {
                    value: isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join(""),
                    metadata: maskScope.call(this, {
                        action: "getmetadata"
                    }, maskset, opts)
                } : isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join("");

              case "isValid":
                actionObj.value ? (valueBuffer = actionObj.value.split(""), checkVal(undefined, !0, !0, isRTL ? valueBuffer.reverse() : valueBuffer)) : actionObj.value = getBuffer().join("");
                for (var buffer = getBuffer(), rl = determineLastRequiredPosition(), lmib = buffer.length - 1; lmib > rl && !isMask(lmib); lmib--) ;
                return buffer.splice(rl, lmib + 1 - rl), isComplete(buffer) && actionObj.value === getBuffer().join("");

              case "getemptymask":
                return getBufferTemplate().join("");

              case "remove":
                if (el && el.inputmask) {
                    $el = $(el), el.inputmask._valueSet(opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(!0)), 
                    EventRuler.off(el);
                    Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), "value") && el.inputmask.__valueGet && Object.defineProperty(el, "value", {
                        get: el.inputmask.__valueGet,
                        set: el.inputmask.__valueSet,
                        configurable: !0
                    }) : document.__lookupGetter__ && el.__lookupGetter__("value") && el.inputmask.__valueGet && (el.__defineGetter__("value", el.inputmask.__valueGet), 
                    el.__defineSetter__("value", el.inputmask.__valueSet)), el.inputmask = undefined;
                }
                return el;

              case "getmetadata":
                if ($.isArray(maskset.metadata)) {
                    var maskTarget = getMaskTemplate(!0, 0, !1).join("");
                    return $.each(maskset.metadata, function(ndx, mtdt) {
                        if (mtdt.mask === maskTarget) return maskTarget = mtdt, !1;
                    }), maskTarget;
                }
                return maskset.metadata;
            }
        }
        var ua = navigator.userAgent, mobile = /mobile/i.test(ua), iemobile = /iemobile/i.test(ua), iphone = /iphone/i.test(ua) && !iemobile, android = /android/i.test(ua) && !iemobile;
        return Inputmask.prototype = {
            dataAttribute: "data-inputmask",
            defaults: {
                placeholder: "_",
                optionalmarker: {
                    start: "[",
                    end: "]"
                },
                quantifiermarker: {
                    start: "{",
                    end: "}"
                },
                groupmarker: {
                    start: "(",
                    end: ")"
                },
                alternatormarker: "|",
                escapeChar: "\\",
                mask: null,
                regex: null,
                oncomplete: $.noop,
                onincomplete: $.noop,
                oncleared: $.noop,
                repeat: 0,
                greedy: !0,
                autoUnmask: !1,
                removeMaskOnSubmit: !1,
                clearMaskOnLostFocus: !0,
                insertMode: !0,
                clearIncomplete: !1,
                alias: null,
                onKeyDown: $.noop,
                onBeforeMask: null,
                onBeforePaste: function(pastedValue, opts) {
                    return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;
                },
                onBeforeWrite: null,
                onUnMask: null,
                showMaskOnFocus: !0,
                showMaskOnHover: !0,
                onKeyValidation: $.noop,
                skipOptionalPartCharacter: " ",
                numericInput: !1,
                rightAlign: !1,
                undoOnEscape: !0,
                radixPoint: "",
                radixPointDefinitionSymbol: undefined,
                groupSeparator: "",
                keepStatic: null,
                positionCaretOnTab: !0,
                tabThrough: !1,
                supportsInputType: [ "text", "tel", "password" ],
                ignorables: [ 8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229 ],
                isComplete: null,
                canClearPosition: $.noop,
                preValidation: null,
                postValidation: null,
                staticDefinitionSymbol: undefined,
                jitMasking: !1,
                nullable: !0,
                inputEventOnly: !1,
                noValuePatching: !1,
                positionCaretOnClick: "lvp",
                casing: null,
                inputmode: "verbatim",
                colorMask: !1,
                androidHack: !1,
                importDataAttributes: !0
            },
            definitions: {
                "9": {
                    validator: "[0-9１-９]",
                    cardinality: 1,
                    definitionSymbol: "*"
                },
                a: {
                    validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                    cardinality: 1,
                    definitionSymbol: "*"
                },
                "*": {
                    validator: "[0-9１-９A-Za-zА-яЁёÀ-ÿµ]",
                    cardinality: 1
                }
            },
            aliases: {},
            masksCache: {},
            mask: function(elems) {
                function importAttributeOptions(npt, opts, userOptions, dataAttribute) {
                    if (!0 === opts.importDataAttributes) {
                        var option, dataoptions, optionData, p, importOption = function(option, optionData) {
                            null !== (optionData = optionData !== undefined ? optionData : npt.getAttribute(dataAttribute + "-" + option)) && ("string" == typeof optionData && (0 === option.indexOf("on") ? optionData = window[optionData] : "false" === optionData ? optionData = !1 : "true" === optionData && (optionData = !0)), 
                            userOptions[option] = optionData);
                        }, attrOptions = npt.getAttribute(dataAttribute);
                        if (attrOptions && "" !== attrOptions && (attrOptions = attrOptions.replace(new RegExp("'", "g"), '"'), 
                        dataoptions = JSON.parse("{" + attrOptions + "}")), dataoptions) {
                            optionData = undefined;
                            for (p in dataoptions) if ("alias" === p.toLowerCase()) {
                                optionData = dataoptions[p];
                                break;
                            }
                        }
                        importOption("alias", optionData), userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts);
                        for (option in opts) {
                            if (dataoptions) {
                                optionData = undefined;
                                for (p in dataoptions) if (p.toLowerCase() === option.toLowerCase()) {
                                    optionData = dataoptions[p];
                                    break;
                                }
                            }
                            importOption(option, optionData);
                        }
                    }
                    return $.extend(!0, opts, userOptions), ("rtl" === npt.dir || opts.rightAlign) && (npt.style.textAlign = "right"), 
                    ("rtl" === npt.dir || opts.numericInput) && (npt.dir = "ltr", npt.removeAttribute("dir"), 
                    opts.isRTL = !0), opts;
                }
                var that = this;
                return "string" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), 
                elems = elems.nodeName ? [ elems ] : elems, $.each(elems, function(ndx, el) {
                    var scopedOpts = $.extend(!0, {}, that.opts);
                    importAttributeOptions(el, scopedOpts, $.extend(!0, {}, that.userOptions), that.dataAttribute);
                    var maskset = generateMaskSet(scopedOpts, that.noMasksCache);
                    maskset !== undefined && (el.inputmask !== undefined && (el.inputmask.opts.autoUnmask = !0, 
                    el.inputmask.remove()), el.inputmask = new Inputmask(undefined, undefined, !0), 
                    el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = $.extend(!0, {}, that.userOptions), 
                    el.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput, el.inputmask.el = el, 
                    el.inputmask.maskset = maskset, $.data(el, "_inputmask_opts", scopedOpts), maskScope.call(el.inputmask, {
                        action: "mask"
                    }));
                }), elems && elems[0] ? elems[0].inputmask || this : this;
            },
            option: function(options, noremask) {
                return "string" == typeof options ? this.opts[options] : "object" === (void 0 === options ? "undefined" : _typeof(options)) ? ($.extend(this.userOptions, options), 
                this.el && !0 !== noremask && this.mask(this.el), this) : void 0;
            },
            unmaskedvalue: function(value) {
                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), 
                maskScope.call(this, {
                    action: "unmaskedvalue",
                    value: value
                });
            },
            remove: function() {
                return maskScope.call(this, {
                    action: "remove"
                });
            },
            getemptymask: function() {
                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), 
                maskScope.call(this, {
                    action: "getemptymask"
                });
            },
            hasMaskedValue: function() {
                return !this.opts.autoUnmask;
            },
            isComplete: function() {
                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), 
                maskScope.call(this, {
                    action: "isComplete"
                });
            },
            getmetadata: function() {
                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), 
                maskScope.call(this, {
                    action: "getmetadata"
                });
            },
            isValid: function(value) {
                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), 
                maskScope.call(this, {
                    action: "isValid",
                    value: value
                });
            },
            format: function(value, metadata) {
                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), 
                maskScope.call(this, {
                    action: "format",
                    value: value,
                    metadata: metadata
                });
            },
            analyseMask: function(mask, regexMask, opts) {
                function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {
                    this.matches = [], this.openGroup = isGroup || !1, this.alternatorGroup = !1, this.isGroup = isGroup || !1, 
                    this.isOptional = isOptional || !1, this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1, 
                    this.quantifier = {
                        min: 1,
                        max: 1
                    };
                }
                function insertTestDefinition(mtoken, element, position) {
                    position = position !== undefined ? position : mtoken.matches.length;
                    var prevMatch = mtoken.matches[position - 1];
                    if (regexMask) 0 === element.indexOf("[") || escaped && /\\d|\\s|\\w]/i.test(element) || "." === element ? mtoken.matches.splice(position++, 0, {
                        fn: new RegExp(element, opts.casing ? "i" : ""),
                        cardinality: 1,
                        optionality: mtoken.isOptional,
                        newBlockMarker: prevMatch === undefined || prevMatch.def !== element,
                        casing: null,
                        def: element,
                        placeholder: undefined,
                        nativeDef: element
                    }) : (escaped && (element = element[element.length - 1]), $.each(element.split(""), function(ndx, lmnt) {
                        prevMatch = mtoken.matches[position - 1], mtoken.matches.splice(position++, 0, {
                            fn: null,
                            cardinality: 0,
                            optionality: mtoken.isOptional,
                            newBlockMarker: prevMatch === undefined || prevMatch.def !== lmnt && null !== prevMatch.fn,
                            casing: null,
                            def: opts.staticDefinitionSymbol || lmnt,
                            placeholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,
                            nativeDef: lmnt
                        });
                    })), escaped = !1; else {
                        var maskdef = (opts.definitions ? opts.definitions[element] : undefined) || Inputmask.prototype.definitions[element];
                        if (maskdef && !escaped) {
                            for (var prevalidators = maskdef.prevalidator, prevalidatorsL = prevalidators ? prevalidators.length : 0, i = 1; i < maskdef.cardinality; i++) {
                                var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [], validator = prevalidator.validator, cardinality = prevalidator.cardinality;
                                mtoken.matches.splice(position++, 0, {
                                    fn: validator ? "string" == typeof validator ? new RegExp(validator, opts.casing ? "i" : "") : new function() {
                                        this.test = validator;
                                    }() : new RegExp("."),
                                    cardinality: cardinality || 1,
                                    optionality: mtoken.isOptional,
                                    newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),
                                    casing: maskdef.casing,
                                    def: maskdef.definitionSymbol || element,
                                    placeholder: maskdef.placeholder,
                                    nativeDef: element
                                }), prevMatch = mtoken.matches[position - 1];
                            }
                            mtoken.matches.splice(position++, 0, {
                                fn: maskdef.validator ? "string" == typeof maskdef.validator ? new RegExp(maskdef.validator, opts.casing ? "i" : "") : new function() {
                                    this.test = maskdef.validator;
                                }() : new RegExp("."),
                                cardinality: maskdef.cardinality,
                                optionality: mtoken.isOptional,
                                newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),
                                casing: maskdef.casing,
                                def: maskdef.definitionSymbol || element,
                                placeholder: maskdef.placeholder,
                                nativeDef: element
                            });
                        } else mtoken.matches.splice(position++, 0, {
                            fn: null,
                            cardinality: 0,
                            optionality: mtoken.isOptional,
                            newBlockMarker: prevMatch === undefined || prevMatch.def !== element && null !== prevMatch.fn,
                            casing: null,
                            def: opts.staticDefinitionSymbol || element,
                            placeholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,
                            nativeDef: element
                        }), escaped = !1;
                    }
                }
                function verifyGroupMarker(maskToken) {
                    maskToken && maskToken.matches && $.each(maskToken.matches, function(ndx, token) {
                        var nextToken = maskToken.matches[ndx + 1];
                        (nextToken === undefined || nextToken.matches === undefined || !1 === nextToken.isQuantifier) && token && token.isGroup && (token.isGroup = !1, 
                        regexMask || (insertTestDefinition(token, opts.groupmarker.start, 0), !0 !== token.openGroup && insertTestDefinition(token, opts.groupmarker.end))), 
                        verifyGroupMarker(token);
                    });
                }
                function defaultCase() {
                    if (openenings.length > 0) {
                        if (currentOpeningToken = openenings[openenings.length - 1], insertTestDefinition(currentOpeningToken, m), 
                        currentOpeningToken.isAlternator) {
                            alternator = openenings.pop();
                            for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1;
                            openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1]).matches.push(alternator) : currentToken.matches.push(alternator);
                        }
                    } else insertTestDefinition(currentToken, m);
                }
                function reverseTokens(maskToken) {
                    maskToken.matches = maskToken.matches.reverse();
                    for (var match in maskToken.matches) if (maskToken.matches.hasOwnProperty(match)) {
                        var intMatch = parseInt(match);
                        if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) {
                            var qt = maskToken.matches[match];
                            maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt);
                        }
                        maskToken.matches[match].matches !== undefined ? maskToken.matches[match] = reverseTokens(maskToken.matches[match]) : maskToken.matches[match] = function(st) {
                            return st === opts.optionalmarker.start ? st = opts.optionalmarker.end : st === opts.optionalmarker.end ? st = opts.optionalmarker.start : st === opts.groupmarker.start ? st = opts.groupmarker.end : st === opts.groupmarker.end && (st = opts.groupmarker.start), 
                            st;
                        }(maskToken.matches[match]);
                    }
                    return maskToken;
                }
                var match, m, openingToken, currentOpeningToken, alternator, lastMatch, groupToken, tokenizer = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g, regexTokenizer = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, escaped = !1, currentToken = new MaskToken(), openenings = [], maskTokens = [];
                for (regexMask && (opts.optionalmarker.start = undefined, opts.optionalmarker.end = undefined); match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask); ) {
                    if (m = match[0], regexMask) switch (m.charAt(0)) {
                      case "?":
                        m = "{0,1}";
                        break;

                      case "+":
                      case "*":
                        m = "{" + m + "}";
                    }
                    if (escaped) defaultCase(); else switch (m.charAt(0)) {
                      case opts.escapeChar:
                        escaped = !0, regexMask && defaultCase();
                        break;

                      case opts.optionalmarker.end:
                      case opts.groupmarker.end:
                        if (openingToken = openenings.pop(), openingToken.openGroup = !1, openingToken !== undefined) if (openenings.length > 0) {
                            if ((currentOpeningToken = openenings[openenings.length - 1]).matches.push(openingToken), 
                            currentOpeningToken.isAlternator) {
                                alternator = openenings.pop();
                                for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1, 
                                alternator.matches[mndx].alternatorGroup = !1;
                                openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1]).matches.push(alternator) : currentToken.matches.push(alternator);
                            }
                        } else currentToken.matches.push(openingToken); else defaultCase();
                        break;

                      case opts.optionalmarker.start:
                        openenings.push(new MaskToken(!1, !0));
                        break;

                      case opts.groupmarker.start:
                        openenings.push(new MaskToken(!0));
                        break;

                      case opts.quantifiermarker.start:
                        var quantifier = new MaskToken(!1, !1, !0), mq = (m = m.replace(/[{}]/g, "")).split(","), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]), mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
                        if ("*" !== mq1 && "+" !== mq1 || (mq0 = "*" === mq1 ? 0 : 1), quantifier.quantifier = {
                            min: mq0,
                            max: mq1
                        }, openenings.length > 0) {
                            var matches = openenings[openenings.length - 1].matches;
                            (match = matches.pop()).isGroup || ((groupToken = new MaskToken(!0)).matches.push(match), 
                            match = groupToken), matches.push(match), matches.push(quantifier);
                        } else (match = currentToken.matches.pop()).isGroup || (regexMask && null === match.fn && "." === match.def && (match.fn = new RegExp(match.def, opts.casing ? "i" : "")), 
                        (groupToken = new MaskToken(!0)).matches.push(match), match = groupToken), currentToken.matches.push(match), 
                        currentToken.matches.push(quantifier);
                        break;

                      case opts.alternatormarker:
                        if (openenings.length > 0) {
                            var subToken = (currentOpeningToken = openenings[openenings.length - 1]).matches[currentOpeningToken.matches.length - 1];
                            lastMatch = currentOpeningToken.openGroup && (subToken.matches === undefined || !1 === subToken.isGroup && !1 === subToken.isAlternator) ? openenings.pop() : currentOpeningToken.matches.pop();
                        } else lastMatch = currentToken.matches.pop();
                        if (lastMatch.isAlternator) openenings.push(lastMatch); else if (lastMatch.alternatorGroup ? (alternator = openenings.pop(), 
                        lastMatch.alternatorGroup = !1) : alternator = new MaskToken(!1, !1, !1, !0), alternator.matches.push(lastMatch), 
                        openenings.push(alternator), lastMatch.openGroup) {
                            lastMatch.openGroup = !1;
                            var alternatorGroup = new MaskToken(!0);
                            alternatorGroup.alternatorGroup = !0, openenings.push(alternatorGroup);
                        }
                        break;

                      default:
                        defaultCase();
                    }
                }
                for (;openenings.length > 0; ) openingToken = openenings.pop(), currentToken.matches.push(openingToken);
                return currentToken.matches.length > 0 && (verifyGroupMarker(currentToken), maskTokens.push(currentToken)), 
                (opts.numericInput || opts.isRTL) && reverseTokens(maskTokens[0]), maskTokens;
            }
        }, Inputmask.extendDefaults = function(options) {
            $.extend(!0, Inputmask.prototype.defaults, options);
        }, Inputmask.extendDefinitions = function(definition) {
            $.extend(!0, Inputmask.prototype.definitions, definition);
        }, Inputmask.extendAliases = function(alias) {
            $.extend(!0, Inputmask.prototype.aliases, alias);
        }, Inputmask.format = function(value, options, metadata) {
            return Inputmask(options).format(value, metadata);
        }, Inputmask.unmask = function(value, options) {
            return Inputmask(options).unmaskedvalue(value);
        }, Inputmask.isValid = function(value, options) {
            return Inputmask(options).isValid(value);
        }, Inputmask.remove = function(elems) {
            $.each(elems, function(ndx, el) {
                el.inputmask && el.inputmask.remove();
            });
        }, Inputmask.escapeRegex = function(str) {
            var specials = [ "/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^" ];
            return str.replace(new RegExp("(\\" + specials.join("|\\") + ")", "gim"), "\\$1");
        }, Inputmask.keyCode = {
            ALT: 18,
            BACKSPACE: 8,
            BACKSPACE_SAFARI: 127,
            CAPS_LOCK: 20,
            COMMA: 188,
            COMMAND: 91,
            COMMAND_LEFT: 91,
            COMMAND_RIGHT: 93,
            CONTROL: 17,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            INSERT: 45,
            LEFT: 37,
            MENU: 93,
            NUMPAD_ADD: 107,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            NUMPAD_ENTER: 108,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_SUBTRACT: 109,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SHIFT: 16,
            SPACE: 32,
            TAB: 9,
            UP: 38,
            WINDOWS: 91,
            X: 88
        }, Inputmask;
    });
}, function(module, exports) {
    module.exports = jQuery;
}, function(module, exports, __webpack_require__) {
    "use strict";
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    __webpack_require__(4), __webpack_require__(9), __webpack_require__(12), __webpack_require__(13), 
    __webpack_require__(14), __webpack_require__(15);
    var _inputmask2 = _interopRequireDefault(__webpack_require__(1)), _inputmask4 = _interopRequireDefault(__webpack_require__(0)), _jquery2 = _interopRequireDefault(__webpack_require__(2));
    _inputmask4.default === _jquery2.default && __webpack_require__(16), window.Inputmask = _inputmask2.default;
}, function(module, exports, __webpack_require__) {
    var content = __webpack_require__(5);
    "string" == typeof content && (content = [ [ module.i, content, "" ] ]);
    var options = {
        hmr: !0
    };
    options.transform = void 0;
    __webpack_require__(7)(content, options);
    content.locals && (module.exports = content.locals);
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(6)(void 0)).push([ module.i, "span.im-caret {\r\n    -webkit-animation: 1s blink step-end infinite;\r\n    animation: 1s blink step-end infinite;\r\n}\r\n\r\n@keyframes blink {\r\n    from, to {\r\n        border-right-color: black;\r\n    }\r\n    50% {\r\n        border-right-color: transparent;\r\n    }\r\n}\r\n\r\n@-webkit-keyframes blink {\r\n    from, to {\r\n        border-right-color: black;\r\n    }\r\n    50% {\r\n        border-right-color: transparent;\r\n    }\r\n}\r\n\r\nspan.im-static {\r\n    color: grey;\r\n}\r\n\r\ndiv.im-colormask {\r\n    display: inline-block;\r\n    border-style: inset;\r\n    border-width: 2px;\r\n    -webkit-appearance: textfield;\r\n    -moz-appearance: textfield;\r\n    appearance: textfield;\r\n}\r\n\r\ndiv.im-colormask > input {\r\n    position: absolute;\r\n    display: inline-block;\r\n    background-color: transparent;\r\n    color: transparent;\r\n    -webkit-appearance: caret;\r\n    -moz-appearance: caret;\r\n    appearance: caret;\r\n    border-style: none;\r\n    left: 0; /*calculated*/\r\n}\r\n\r\ndiv.im-colormask > input:focus {\r\n    outline: none;\r\n}\r\n\r\ndiv.im-colormask > input::-moz-selection{\r\n    background: none;\r\n}\r\n\r\ndiv.im-colormask > input::selection{\r\n    background: none;\r\n}\r\ndiv.im-colormask > input::-moz-selection{\r\n    background: none;\r\n}\r\n\r\ndiv.im-colormask > div {\r\n    color: black;\r\n    display: inline-block;\r\n    width: 100px; /*calculated*/\r\n}", "" ]);
}, function(module, exports) {
    function cssWithMappingToString(item, useSourceMap) {
        var content = item[1] || "", cssMapping = item[3];
        if (!cssMapping) return content;
        if (useSourceMap && "function" == typeof btoa) {
            var sourceMapping = toComment(cssMapping), sourceURLs = cssMapping.sources.map(function(source) {
                return "/*# sourceURL=" + cssMapping.sourceRoot + source + " */";
            });
            return [ content ].concat(sourceURLs).concat([ sourceMapping ]).join("\n");
        }
        return [ content ].join("\n");
    }
    function toComment(sourceMap) {
        return "/*# " + ("sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))))) + " */";
    }
    module.exports = function(useSourceMap) {
        var list = [];
        return list.toString = function() {
            return this.map(function(item) {
                var content = cssWithMappingToString(item, useSourceMap);
                return item[2] ? "@media " + item[2] + "{" + content + "}" : content;
            }).join("");
        }, list.i = function(modules, mediaQuery) {
            "string" == typeof modules && (modules = [ [ null, modules, "" ] ]);
            for (var alreadyImportedModules = {}, i = 0; i < this.length; i++) {
                var id = this[i][0];
                "number" == typeof id && (alreadyImportedModules[id] = !0);
            }
            for (i = 0; i < modules.length; i++) {
                var item = modules[i];
                "number" == typeof item[0] && alreadyImportedModules[item[0]] || (mediaQuery && !item[2] ? item[2] = mediaQuery : mediaQuery && (item[2] = "(" + item[2] + ") and (" + mediaQuery + ")"), 
                list.push(item));
            }
        }, list;
    };
}, function(module, exports, __webpack_require__) {
    function addStylesToDom(styles, options) {
        for (var i = 0; i < styles.length; i++) {
            var item = styles[i], domStyle = stylesInDom[item.id];
            if (domStyle) {
                domStyle.refs++;
                for (j = 0; j < domStyle.parts.length; j++) domStyle.parts[j](item.parts[j]);
                for (;j < item.parts.length; j++) domStyle.parts.push(addStyle(item.parts[j], options));
            } else {
                for (var parts = [], j = 0; j < item.parts.length; j++) parts.push(addStyle(item.parts[j], options));
                stylesInDom[item.id] = {
                    id: item.id,
                    refs: 1,
                    parts: parts
                };
            }
        }
    }
    function listToStyles(list, options) {
        for (var styles = [], newStyles = {}, i = 0; i < list.length; i++) {
            var item = list[i], id = options.base ? item[0] + options.base : item[0], part = {
                css: item[1],
                media: item[2],
                sourceMap: item[3]
            };
            newStyles[id] ? newStyles[id].parts.push(part) : styles.push(newStyles[id] = {
                id: id,
                parts: [ part ]
            });
        }
        return styles;
    }
    function insertStyleElement(options, style) {
        var target = getElement(options.insertInto);
        if (!target) throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
        var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];
        if ("top" === options.insertAt) lastStyleElementInsertedAtTop ? lastStyleElementInsertedAtTop.nextSibling ? target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling) : target.appendChild(style) : target.insertBefore(style, target.firstChild), 
        stylesInsertedAtTop.push(style); else if ("bottom" === options.insertAt) target.appendChild(style); else {
            if ("object" != typeof options.insertAt || !options.insertAt.before) throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
            var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
            target.insertBefore(style, nextSibling);
        }
    }
    function removeStyleElement(style) {
        if (null === style.parentNode) return !1;
        style.parentNode.removeChild(style);
        var idx = stylesInsertedAtTop.indexOf(style);
        idx >= 0 && stylesInsertedAtTop.splice(idx, 1);
    }
    function createStyleElement(options) {
        var style = document.createElement("style");
        return options.attrs.type = "text/css", addAttrs(style, options.attrs), insertStyleElement(options, style), 
        style;
    }
    function createLinkElement(options) {
        var link = document.createElement("link");
        return options.attrs.type = "text/css", options.attrs.rel = "stylesheet", addAttrs(link, options.attrs), 
        insertStyleElement(options, link), link;
    }
    function addAttrs(el, attrs) {
        Object.keys(attrs).forEach(function(key) {
            el.setAttribute(key, attrs[key]);
        });
    }
    function addStyle(obj, options) {
        var style, update, remove, result;
        if (options.transform && obj.css) {
            if (!(result = options.transform(obj.css))) return function() {};
            obj.css = result;
        }
        if (options.singleton) {
            var styleIndex = singletonCounter++;
            style = singleton || (singleton = createStyleElement(options)), update = applyToSingletonTag.bind(null, style, styleIndex, !1), 
            remove = applyToSingletonTag.bind(null, style, styleIndex, !0);
        } else obj.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (style = createLinkElement(options), 
        update = updateLink.bind(null, style, options), remove = function() {
            removeStyleElement(style), style.href && URL.revokeObjectURL(style.href);
        }) : (style = createStyleElement(options), update = applyToTag.bind(null, style), 
        remove = function() {
            removeStyleElement(style);
        });
        return update(obj), function(newObj) {
            if (newObj) {
                if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) return;
                update(obj = newObj);
            } else remove();
        };
    }
    function applyToSingletonTag(style, index, remove, obj) {
        var css = remove ? "" : obj.css;
        if (style.styleSheet) style.styleSheet.cssText = replaceText(index, css); else {
            var cssNode = document.createTextNode(css), childNodes = style.childNodes;
            childNodes[index] && style.removeChild(childNodes[index]), childNodes.length ? style.insertBefore(cssNode, childNodes[index]) : style.appendChild(cssNode);
        }
    }
    function applyToTag(style, obj) {
        var css = obj.css, media = obj.media;
        if (media && style.setAttribute("media", media), style.styleSheet) style.styleSheet.cssText = css; else {
            for (;style.firstChild; ) style.removeChild(style.firstChild);
            style.appendChild(document.createTextNode(css));
        }
    }
    function updateLink(link, options, obj) {
        var css = obj.css, sourceMap = obj.sourceMap, autoFixUrls = void 0 === options.convertToAbsoluteUrls && sourceMap;
        (options.convertToAbsoluteUrls || autoFixUrls) && (css = fixUrls(css)), sourceMap && (css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */");
        var blob = new Blob([ css ], {
            type: "text/css"
        }), oldSrc = link.href;
        link.href = URL.createObjectURL(blob), oldSrc && URL.revokeObjectURL(oldSrc);
    }
    var stylesInDom = {}, isOldIE = function(fn) {
        var memo;
        return function() {
            return void 0 === memo && (memo = fn.apply(this, arguments)), memo;
        };
    }(function() {
        return window && document && document.all && !window.atob;
    }), getElement = function(fn) {
        var memo = {};
        return function(selector) {
            if (void 0 === memo[selector]) {
                var styleTarget = fn.call(this, selector);
                if (styleTarget instanceof window.HTMLIFrameElement) try {
                    styleTarget = styleTarget.contentDocument.head;
                } catch (e) {
                    styleTarget = null;
                }
                memo[selector] = styleTarget;
            }
            return memo[selector];
        };
    }(function(target) {
        return document.querySelector(target);
    }), singleton = null, singletonCounter = 0, stylesInsertedAtTop = [], fixUrls = __webpack_require__(8);
    module.exports = function(list, options) {
        if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document) throw new Error("The style-loader cannot be used in a non-browser environment");
        (options = options || {}).attrs = "object" == typeof options.attrs ? options.attrs : {}, 
        options.singleton || (options.singleton = isOldIE()), options.insertInto || (options.insertInto = "head"), 
        options.insertAt || (options.insertAt = "bottom");
        var styles = listToStyles(list, options);
        return addStylesToDom(styles, options), function(newList) {
            for (var mayRemove = [], i = 0; i < styles.length; i++) {
                var item = styles[i];
                (domStyle = stylesInDom[item.id]).refs--, mayRemove.push(domStyle);
            }
            newList && addStylesToDom(listToStyles(newList, options), options);
            for (i = 0; i < mayRemove.length; i++) {
                var domStyle = mayRemove[i];
                if (0 === domStyle.refs) {
                    for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();
                    delete stylesInDom[domStyle.id];
                }
            }
        };
    };
    var replaceText = function() {
        var textStore = [];
        return function(index, replacement) {
            return textStore[index] = replacement, textStore.filter(Boolean).join("\n");
        };
    }();
}, function(module, exports) {
    module.exports = function(css) {
        var location = "undefined" != typeof window && window.location;
        if (!location) throw new Error("fixUrls requires window.location");
        if (!css || "string" != typeof css) return css;
        var baseUrl = location.protocol + "//" + location.host, currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");
        return css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
            var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function(o, $1) {
                return $1;
            }).replace(/^'(.*)'$/, function(o, $1) {
                return $1;
            });
            if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) return fullMatch;
            var newUrl;
            return newUrl = 0 === unquotedOrigUrl.indexOf("//") ? unquotedOrigUrl : 0 === unquotedOrigUrl.indexOf("/") ? baseUrl + unquotedOrigUrl : currentDir + unquotedOrigUrl.replace(/^\.\//, ""), 
            "url(" + JSON.stringify(newUrl) + ")";
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    !function(factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0), __webpack_require__(1) ], 
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function($, Inputmask) {
        function isLeapYear(year) {
            return isNaN(year) || 29 === new Date(year, 2, 0).getDate();
        }
        return Inputmask.extendAliases({
            "dd/mm/yyyy": {
                mask: "1/2/y",
                placeholder: "dd/mm/yyyy",
                regex: {
                    val1pre: new RegExp("[0-3]"),
                    val1: new RegExp("0[1-9]|[12][0-9]|3[01]"),
                    val2pre: function(separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|[12][0-9]|3[01])" + escapedSeparator + "[01])");
                    },
                    val2: function(separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|[12][0-9])" + escapedSeparator + "(0[1-9]|1[012]))|(30" + escapedSeparator + "(0[13-9]|1[012]))|(31" + escapedSeparator + "(0[13578]|1[02]))");
                    }
                },
                leapday: "29/02/",
                separator: "/",
                yearrange: {
                    minyear: 1900,
                    maxyear: 2099
                },
                isInYearRange: function(chrs, minyear, maxyear) {
                    if (isNaN(chrs)) return !1;
                    var enteredyear = parseInt(chrs.concat(minyear.toString().slice(chrs.length))), enteredyear2 = parseInt(chrs.concat(maxyear.toString().slice(chrs.length)));
                    return !isNaN(enteredyear) && (minyear <= enteredyear && enteredyear <= maxyear) || !isNaN(enteredyear2) && (minyear <= enteredyear2 && enteredyear2 <= maxyear);
                },
                determinebaseyear: function(minyear, maxyear, hint) {
                    var currentyear = new Date().getFullYear();
                    if (minyear > currentyear) return minyear;
                    if (maxyear < currentyear) {
                        for (var maxYearPrefix = maxyear.toString().slice(0, 2), maxYearPostfix = maxyear.toString().slice(2, 4); maxyear < maxYearPrefix + hint; ) maxYearPrefix--;
                        var maxxYear = maxYearPrefix + maxYearPostfix;
                        return minyear > maxxYear ? minyear : maxxYear;
                    }
                    if (minyear <= currentyear && currentyear <= maxyear) {
                        for (var currentYearPrefix = currentyear.toString().slice(0, 2); maxyear < currentYearPrefix + hint; ) currentYearPrefix--;
                        var currentYearAndHint = currentYearPrefix + hint;
                        return currentYearAndHint < minyear ? minyear : currentYearAndHint;
                    }
                    return currentyear;
                },
                onKeyDown: function(e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                        var today = new Date();
                        $input.val(today.getDate().toString() + (today.getMonth() + 1).toString() + today.getFullYear().toString()), 
                        $input.trigger("setvalue");
                    }
                },
                getFrontValue: function(mask, buffer, opts) {
                    for (var start = 0, length = 0, i = 0; i < mask.length && "2" !== mask.charAt(i); i++) {
                        var definition = opts.definitions[mask.charAt(i)];
                        definition ? (start += length, length = definition.cardinality) : length++;
                    }
                    return buffer.join("").substr(start, length);
                },
                postValidation: function(buffer, currentResult, opts) {
                    var dayMonthValue, year, bufferStr = buffer.join("");
                    return 0 === opts.mask.indexOf("y") ? (year = bufferStr.substr(0, 4), dayMonthValue = bufferStr.substring(4, 10)) : (year = bufferStr.substring(6, 10), 
                    dayMonthValue = bufferStr.substr(0, 6)), currentResult && (dayMonthValue !== opts.leapday || isLeapYear(year));
                },
                definitions: {
                    "1": {
                        validator: function(chrs, maskset, pos, strict, opts) {
                            var isValid = opts.regex.val1.test(chrs);
                            return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === "-./".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val1.test("0" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = "0", 
                            {
                                refreshFromBuffer: {
                                    start: pos - 1,
                                    end: pos
                                },
                                pos: pos,
                                c: chrs.charAt(0)
                            });
                        },
                        cardinality: 2,
                        prevalidator: [ {
                            validator: function(chrs, maskset, pos, strict, opts) {
                                var pchrs = chrs;
                                isNaN(maskset.buffer[pos + 1]) || (pchrs += maskset.buffer[pos + 1]);
                                var isValid = 1 === pchrs.length ? opts.regex.val1pre.test(pchrs) : opts.regex.val1.test(pchrs);
                                if (isValid && maskset.validPositions[pos] && (opts.regex.val2(opts.separator).test(chrs + maskset.validPositions[pos].input) || (maskset.validPositions[pos].input = "0" === chrs ? "1" : "0")), 
                                !strict && !isValid) {
                                    if (isValid = opts.regex.val1.test(chrs + "0")) return maskset.buffer[pos] = chrs, 
                                    maskset.buffer[++pos] = "0", {
                                        pos: pos,
                                        c: "0"
                                    };
                                    if (isValid = opts.regex.val1.test("0" + chrs)) return maskset.buffer[pos] = "0", 
                                    pos++, {
                                        pos: pos
                                    };
                                }
                                return isValid;
                            },
                            cardinality: 1
                        } ]
                    },
                    "2": {
                        validator: function(chrs, maskset, pos, strict, opts) {
                            var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);
                            -1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = "01" + opts.separator);
                            var isValid = opts.regex.val2(opts.separator).test(frontValue + chrs);
                            return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === "-./".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val2(opts.separator).test(frontValue + "0" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = "0", 
                            {
                                refreshFromBuffer: {
                                    start: pos - 1,
                                    end: pos
                                },
                                pos: pos,
                                c: chrs.charAt(0)
                            });
                        },
                        cardinality: 2,
                        prevalidator: [ {
                            validator: function(chrs, maskset, pos, strict, opts) {
                                isNaN(maskset.buffer[pos + 1]) || (chrs += maskset.buffer[pos + 1]);
                                var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);
                                -1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = "01" + opts.separator);
                                var isValid = 1 === chrs.length ? opts.regex.val2pre(opts.separator).test(frontValue + chrs) : opts.regex.val2(opts.separator).test(frontValue + chrs);
                                return isValid && maskset.validPositions[pos] && (opts.regex.val2(opts.separator).test(chrs + maskset.validPositions[pos].input) || (maskset.validPositions[pos].input = "0" === chrs ? "1" : "0")), 
                                strict || isValid || !(isValid = opts.regex.val2(opts.separator).test(frontValue + "0" + chrs)) ? isValid : (maskset.buffer[pos] = "0", 
                                pos++, {
                                    pos: pos
                                });
                            },
                            cardinality: 1
                        } ]
                    },
                    y: {
                        validator: function(chrs, maskset, pos, strict, opts) {
                            return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                        },
                        cardinality: 4,
                        prevalidator: [ {
                            validator: function(chrs, maskset, pos, strict, opts) {
                                var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                                if (!strict && !isValid) {
                                    var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0").toString().slice(0, 1);
                                    if (isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0), 
                                    {
                                        pos: pos
                                    };
                                    if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0").toString().slice(0, 2), 
                                    isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0), 
                                    maskset.buffer[pos++] = yearPrefix.charAt(1), {
                                        pos: pos
                                    };
                                }
                                return isValid;
                            },
                            cardinality: 1
                        }, {
                            validator: function(chrs, maskset, pos, strict, opts) {
                                var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                                if (!strict && !isValid) {
                                    var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2);
                                    if (isValid = opts.isInYearRange(chrs[0] + yearPrefix[1] + chrs[1], opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(1), 
                                    {
                                        pos: pos
                                    };
                                    if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2), 
                                    isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos - 1] = yearPrefix.charAt(0), 
                                    maskset.buffer[pos++] = yearPrefix.charAt(1), maskset.buffer[pos++] = chrs.charAt(0), 
                                    {
                                        refreshFromBuffer: {
                                            start: pos - 3,
                                            end: pos
                                        },
                                        pos: pos
                                    };
                                }
                                return isValid;
                            },
                            cardinality: 2
                        }, {
                            validator: function(chrs, maskset, pos, strict, opts) {
                                return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                            },
                            cardinality: 3
                        } ]
                    }
                },
                insertMode: !1,
                autoUnmask: !1
            },
            "mm/dd/yyyy": {
                placeholder: "mm/dd/yyyy",
                alias: "dd/mm/yyyy",
                regex: {
                    val2pre: function(separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
                    },
                    val2: function(separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
                    },
                    val1pre: new RegExp("[01]"),
                    val1: new RegExp("0[1-9]|1[012]")
                },
                leapday: "02/29/",
                onKeyDown: function(e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                        var today = new Date();
                        $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()), 
                        $input.trigger("setvalue");
                    }
                }
            },
            "yyyy/mm/dd": {
                mask: "y/1/2",
                placeholder: "yyyy/mm/dd",
                alias: "mm/dd/yyyy",
                leapday: "/02/29",
                onKeyDown: function(e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                        var today = new Date();
                        $input.val(today.getFullYear().toString() + (today.getMonth() + 1).toString() + today.getDate().toString()), 
                        $input.trigger("setvalue");
                    }
                }
            },
            "dd.mm.yyyy": {
                mask: "1.2.y",
                placeholder: "dd.mm.yyyy",
                leapday: "29.02.",
                separator: ".",
                alias: "dd/mm/yyyy"
            },
            "dd-mm-yyyy": {
                mask: "1-2-y",
                placeholder: "dd-mm-yyyy",
                leapday: "29-02-",
                separator: "-",
                alias: "dd/mm/yyyy"
            },
            "mm.dd.yyyy": {
                mask: "1.2.y",
                placeholder: "mm.dd.yyyy",
                leapday: "02.29.",
                separator: ".",
                alias: "mm/dd/yyyy"
            },
            "mm-dd-yyyy": {
                mask: "1-2-y",
                placeholder: "mm-dd-yyyy",
                leapday: "02-29-",
                separator: "-",
                alias: "mm/dd/yyyy"
            },
            "yyyy.mm.dd": {
                mask: "y.1.2",
                placeholder: "yyyy.mm.dd",
                leapday: ".02.29",
                separator: ".",
                alias: "yyyy/mm/dd"
            },
            "yyyy-mm-dd": {
                mask: "y-1-2",
                placeholder: "yyyy-mm-dd",
                leapday: "-02-29",
                separator: "-",
                alias: "yyyy/mm/dd"
            },
            datetime: {
                mask: "1/2/y h:s",
                placeholder: "dd/mm/yyyy hh:mm",
                alias: "dd/mm/yyyy",
                regex: {
                    hrspre: new RegExp("[012]"),
                    hrs24: new RegExp("2[0-4]|1[3-9]"),
                    hrs: new RegExp("[01][0-9]|2[0-4]"),
                    ampm: new RegExp("^[a|p|A|P][m|M]"),
                    mspre: new RegExp("[0-5]"),
                    ms: new RegExp("[0-5][0-9]")
                },
                timeseparator: ":",
                hourFormat: "24",
                definitions: {
                    h: {
                        validator: function(chrs, maskset, pos, strict, opts) {
                            if ("24" === opts.hourFormat && 24 === parseInt(chrs, 10)) return maskset.buffer[pos - 1] = "0", 
                            maskset.buffer[pos] = "0", {
                                refreshFromBuffer: {
                                    start: pos - 1,
                                    end: pos
                                },
                                c: "0"
                            };
                            var isValid = opts.regex.hrs.test(chrs);
                            if (!strict && !isValid && (chrs.charAt(1) === opts.timeseparator || -1 !== "-.:".indexOf(chrs.charAt(1))) && (isValid = opts.regex.hrs.test("0" + chrs.charAt(0)))) return maskset.buffer[pos - 1] = "0", 
                            maskset.buffer[pos] = chrs.charAt(0), pos++, {
                                refreshFromBuffer: {
                                    start: pos - 2,
                                    end: pos
                                },
                                pos: pos,
                                c: opts.timeseparator
                            };
                            if (isValid && "24" !== opts.hourFormat && opts.regex.hrs24.test(chrs)) {
                                var tmp = parseInt(chrs, 10);
                                return 24 === tmp ? (maskset.buffer[pos + 5] = "a", maskset.buffer[pos + 6] = "m") : (maskset.buffer[pos + 5] = "p", 
                                maskset.buffer[pos + 6] = "m"), (tmp -= 12) < 10 ? (maskset.buffer[pos] = tmp.toString(), 
                                maskset.buffer[pos - 1] = "0") : (maskset.buffer[pos] = tmp.toString().charAt(1), 
                                maskset.buffer[pos - 1] = tmp.toString().charAt(0)), {
                                    refreshFromBuffer: {
                                        start: pos - 1,
                                        end: pos + 6
                                    },
                                    c: maskset.buffer[pos]
                                };
                            }
                            return isValid;
                        },
                        cardinality: 2,
                        prevalidator: [ {
                            validator: function(chrs, maskset, pos, strict, opts) {
                                var isValid = opts.regex.hrspre.test(chrs);
                                return strict || isValid || !(isValid = opts.regex.hrs.test("0" + chrs)) ? isValid : (maskset.buffer[pos] = "0", 
                                pos++, {
                                    pos: pos
                                });
                            },
                            cardinality: 1
                        } ]
                    },
                    s: {
                        validator: "[0-5][0-9]",
                        cardinality: 2,
                        prevalidator: [ {
                            validator: function(chrs, maskset, pos, strict, opts) {
                                var isValid = opts.regex.mspre.test(chrs);
                                return strict || isValid || !(isValid = opts.regex.ms.test("0" + chrs)) ? isValid : (maskset.buffer[pos] = "0", 
                                pos++, {
                                    pos: pos
                                });
                            },
                            cardinality: 1
                        } ]
                    },
                    t: {
                        validator: function(chrs, maskset, pos, strict, opts) {
                            return opts.regex.ampm.test(chrs + "m");
                        },
                        casing: "lower",
                        cardinality: 1
                    }
                },
                insertMode: !1,
                autoUnmask: !1
            },
            datetime12: {
                mask: "1/2/y h:s t\\m",
                placeholder: "dd/mm/yyyy hh:mm xm",
                alias: "datetime",
                hourFormat: "12"
            },
            "mm/dd/yyyy hh:mm xm": {
                mask: "1/2/y h:s t\\m",
                placeholder: "mm/dd/yyyy hh:mm xm",
                alias: "datetime12",
                regex: {
                    val2pre: function(separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
                    },
                    val2: function(separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
                    },
                    val1pre: new RegExp("[01]"),
                    val1: new RegExp("0[1-9]|1[012]")
                },
                leapday: "02/29/",
                onKeyDown: function(e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                        var today = new Date();
                        $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()), 
                        $input.trigger("setvalue");
                    }
                }
            },
            "hh:mm t": {
                mask: "h:s t\\m",
                placeholder: "hh:mm xm",
                alias: "datetime",
                hourFormat: "12"
            },
            "h:s t": {
                mask: "h:s t\\m",
                placeholder: "hh:mm xm",
                alias: "datetime",
                hourFormat: "12"
            },
            "hh:mm:ss": {
                mask: "h:s:s",
                placeholder: "hh:mm:ss",
                alias: "datetime",
                autoUnmask: !1
            },
            "hh:mm": {
                mask: "h:s",
                placeholder: "hh:mm",
                alias: "datetime",
                autoUnmask: !1
            },
            date: {
                alias: "dd/mm/yyyy"
            },
            "mm/yyyy": {
                mask: "1/y",
                placeholder: "mm/yyyy",
                leapday: "donotuse",
                separator: "/",
                alias: "mm/dd/yyyy"
            },
            shamsi: {
                regex: {
                    val2pre: function(separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "[0-3])");
                    },
                    val2: function(separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[1-9]|1[012])" + escapedSeparator + "30)|((0[1-6])" + escapedSeparator + "31)");
                    },
                    val1pre: new RegExp("[01]"),
                    val1: new RegExp("0[1-9]|1[012]")
                },
                yearrange: {
                    minyear: 1300,
                    maxyear: 1499
                },
                mask: "y/1/2",
                leapday: "/12/30",
                placeholder: "yyyy/mm/dd",
                alias: "mm/dd/yyyy",
                clearIncomplete: !0
            },
            "yyyy-mm-dd hh:mm:ss": {
                mask: "y-1-2 h:s:s",
                placeholder: "yyyy-mm-dd hh:mm:ss",
                alias: "datetime",
                separator: "-",
                leapday: "-02-29",
                regex: {
                    val2pre: function(separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
                    },
                    val2: function(separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
                    },
                    val1pre: new RegExp("[01]"),
                    val1: new RegExp("0[1-9]|1[012]")
                },
                onKeyDown: function(e, buffer, caretPos, opts) {}
            }
        }), Inputmask;
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
        return window;
    }.call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}, function(module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
        return document;
    }.call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}, function(module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    !function(factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0), __webpack_require__(1) ], 
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function($, Inputmask) {
        return Inputmask.extendDefinitions({
            A: {
                validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                cardinality: 1,
                casing: "upper"
            },
            "&": {
                validator: "[0-9A-Za-zА-яЁёÀ-ÿµ]",
                cardinality: 1,
                casing: "upper"
            },
            "#": {
                validator: "[0-9A-Fa-f]",
                cardinality: 1,
                casing: "upper"
            }
        }), Inputmask.extendAliases({
            url: {
                definitions: {
                    i: {
                        validator: ".",
                        cardinality: 1
                    }
                },
                mask: "(\\http://)|(\\http\\s://)|(ftp://)|(ftp\\s://)i{+}",
                insertMode: !1,
                autoUnmask: !1,
                inputmode: "url"
            },
            ip: {
                mask: "i[i[i]].i[i[i]].i[i[i]].i[i[i]]",
                definitions: {
                    i: {
                        validator: function(chrs, maskset, pos, strict, opts) {
                            return pos - 1 > -1 && "." !== maskset.buffer[pos - 1] ? (chrs = maskset.buffer[pos - 1] + chrs, 
                            chrs = pos - 2 > -1 && "." !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : "0" + chrs) : chrs = "00" + chrs, 
                            new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]").test(chrs);
                        },
                        cardinality: 1
                    }
                },
                onUnMask: function(maskedValue, unmaskedValue, opts) {
                    return maskedValue;
                },
                inputmode: "numeric"
            },
            email: {
                mask: "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]",
                greedy: !1,
                onBeforePaste: function(pastedValue, opts) {
                    return (pastedValue = pastedValue.toLowerCase()).replace("mailto:", "");
                },
                definitions: {
                    "*": {
                        validator: "[0-9A-Za-z!#$%&'*+/=?^_`{|}~-]",
                        cardinality: 1,
                        casing: "lower"
                    },
                    "-": {
                        validator: "[0-9A-Za-z-]",
                        cardinality: 1,
                        casing: "lower"
                    }
                },
                onUnMask: function(maskedValue, unmaskedValue, opts) {
                    return maskedValue;
                },
                inputmode: "email"
            },
            mac: {
                mask: "##:##:##:##:##:##"
            },
            vin: {
                mask: "V{13}9{4}",
                definitions: {
                    V: {
                        validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                        cardinality: 1,
                        casing: "upper"
                    }
                },
                clearIncomplete: !0,
                autoUnmask: !0
            }
        }), Inputmask;
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    !function(factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0), __webpack_require__(1) ], 
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function($, Inputmask, undefined) {
        function autoEscape(txt, opts) {
            for (var escapedTxt = "", i = 0; i < txt.length; i++) Inputmask.prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker.start === txt.charAt(i) || opts.optionalmarker.end === txt.charAt(i) || opts.quantifiermarker.start === txt.charAt(i) || opts.quantifiermarker.end === txt.charAt(i) || opts.groupmarker.start === txt.charAt(i) || opts.groupmarker.end === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? escapedTxt += "\\" + txt.charAt(i) : escapedTxt += txt.charAt(i);
            return escapedTxt;
        }
        return Inputmask.extendAliases({
            numeric: {
                mask: function(opts) {
                    if (0 !== opts.repeat && isNaN(opts.integerDigits) && (opts.integerDigits = opts.repeat), 
                    opts.repeat = 0, opts.groupSeparator === opts.radixPoint && ("." === opts.radixPoint ? opts.groupSeparator = "," : "," === opts.radixPoint ? opts.groupSeparator = "." : opts.groupSeparator = ""), 
                    " " === opts.groupSeparator && (opts.skipOptionalPartCharacter = undefined), opts.autoGroup = opts.autoGroup && "" !== opts.groupSeparator, 
                    opts.autoGroup && ("string" == typeof opts.groupSize && isFinite(opts.groupSize) && (opts.groupSize = parseInt(opts.groupSize)), 
                    isFinite(opts.integerDigits))) {
                        var seps = Math.floor(opts.integerDigits / opts.groupSize), mod = opts.integerDigits % opts.groupSize;
                        opts.integerDigits = parseInt(opts.integerDigits) + (0 === mod ? seps - 1 : seps), 
                        opts.integerDigits < 1 && (opts.integerDigits = "*");
                    }
                    opts.placeholder.length > 1 && (opts.placeholder = opts.placeholder.charAt(0)), 
                    "radixFocus" === opts.positionCaretOnClick && "" === opts.placeholder && !1 === opts.integerOptional && (opts.positionCaretOnClick = "lvp"), 
                    opts.definitions[";"] = opts.definitions["~"], opts.definitions[";"].definitionSymbol = "~", 
                    !0 === opts.numericInput && (opts.positionCaretOnClick = "radixFocus" === opts.positionCaretOnClick ? "lvp" : opts.positionCaretOnClick, 
                    opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2), opts.decimalProtect = !1);
                    var mask = "[+]";
                    if (mask += autoEscape(opts.prefix, opts), !0 === opts.integerOptional ? mask += "~{1," + opts.integerDigits + "}" : mask += "~{" + opts.integerDigits + "}", 
                    opts.digits !== undefined) {
                        opts.radixPointDefinitionSymbol = opts.decimalProtect ? ":" : opts.radixPoint;
                        var dq = opts.digits.toString().split(",");
                        isFinite(dq[0] && dq[1] && isFinite(dq[1])) ? mask += opts.radixPointDefinitionSymbol + ";{" + opts.digits + "}" : (isNaN(opts.digits) || parseInt(opts.digits) > 0) && (opts.digitsOptional ? mask += "[" + opts.radixPointDefinitionSymbol + ";{1," + opts.digits + "}]" : mask += opts.radixPointDefinitionSymbol + ";{" + opts.digits + "}");
                    }
                    return mask += autoEscape(opts.suffix, opts), mask += "[-]", opts.greedy = !1, mask;
                },
                placeholder: "",
                greedy: !1,
                digits: "*",
                digitsOptional: !0,
                enforceDigitsOnBlur: !1,
                radixPoint: ".",
                positionCaretOnClick: "radixFocus",
                groupSize: 3,
                groupSeparator: "",
                autoGroup: !1,
                allowMinus: !0,
                negationSymbol: {
                    front: "-",
                    back: ""
                },
                integerDigits: "+",
                integerOptional: !0,
                prefix: "",
                suffix: "",
                rightAlign: !0,
                decimalProtect: !0,
                min: null,
                max: null,
                step: 1,
                insertMode: !0,
                autoUnmask: !1,
                unmaskAsNumber: !1,
                inputmode: "numeric",
                preValidation: function(buffer, pos, c, isSelection, opts) {
                    if ("-" === c || c === opts.negationSymbol.front) return !0 === opts.allowMinus && (opts.isNegative = opts.isNegative === undefined || !opts.isNegative, 
                    "" === buffer.join("") || {
                        caret: pos,
                        dopost: !0
                    });
                    if (!1 === isSelection && c === opts.radixPoint && opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) {
                        var radixPos = $.inArray(opts.radixPoint, buffer);
                        if (-1 !== radixPos) return !0 === opts.numericInput ? pos === radixPos : {
                            caret: radixPos + 1
                        };
                    }
                    return !0;
                },
                postValidation: function(buffer, currentResult, opts) {
                    var suffix = opts.suffix.split(""), prefix = opts.prefix.split("");
                    if (currentResult.pos === undefined && currentResult.caret !== undefined && !0 !== currentResult.dopost) return currentResult;
                    var caretPos = currentResult.caret !== undefined ? currentResult.caret : currentResult.pos, maskedValue = buffer.slice();
                    opts.numericInput && (caretPos = maskedValue.length - caretPos - 1, maskedValue = maskedValue.reverse());
                    var charAtPos = maskedValue[caretPos];
                    if (charAtPos === opts.groupSeparator && (charAtPos = maskedValue[caretPos += 1]), 
                    caretPos === maskedValue.length - opts.suffix.length - 1 && charAtPos === opts.radixPoint) return currentResult;
                    charAtPos !== undefined && charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back && (maskedValue[caretPos] = "?", 
                    opts.prefix.length > 0 && caretPos >= (!1 === opts.isNegative ? 1 : 0) && caretPos < opts.prefix.length - 1 + (!1 === opts.isNegative ? 1 : 0) ? prefix[caretPos - (!1 === opts.isNegative ? 1 : 0)] = "?" : opts.suffix.length > 0 && caretPos >= maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0) && (suffix[caretPos - (maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0))] = "?")), 
                    prefix = prefix.join(""), suffix = suffix.join("");
                    var processValue = maskedValue.join("").replace(prefix, "");
                    if (processValue = processValue.replace(suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""), 
                    processValue = processValue.replace(new RegExp("[-" + Inputmask.escapeRegex(opts.negationSymbol.front) + "]", "g"), ""), 
                    processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), ""), 
                    isNaN(opts.placeholder) && (processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.placeholder), "g"), "")), 
                    processValue.length > 1 && 1 !== processValue.indexOf(opts.radixPoint) && ("0" === charAtPos && (processValue = processValue.replace(/^\?/g, "")), 
                    processValue = processValue.replace(/^0/g, "")), processValue.charAt(0) === opts.radixPoint && "" !== opts.radixPoint && !0 !== opts.numericInput && (processValue = "0" + processValue), 
                    "" !== processValue) {
                        if (processValue = processValue.split(""), (!opts.digitsOptional || opts.enforceDigitsOnBlur && "blur" === currentResult.event) && isFinite(opts.digits)) {
                            var radixPosition = $.inArray(opts.radixPoint, processValue), rpb = $.inArray(opts.radixPoint, maskedValue);
                            -1 === radixPosition && (processValue.push(opts.radixPoint), radixPosition = processValue.length - 1);
                            for (var i = 1; i <= opts.digits; i++) opts.digitsOptional && (!opts.enforceDigitsOnBlur || "blur" !== currentResult.event) || processValue[radixPosition + i] !== undefined && processValue[radixPosition + i] !== opts.placeholder.charAt(0) ? -1 !== rpb && maskedValue[rpb + i] !== undefined && (processValue[radixPosition + i] = processValue[radixPosition + i] || maskedValue[rpb + i]) : processValue[radixPosition + i] = currentResult.placeholder || opts.placeholder.charAt(0);
                        }
                        if (!0 !== opts.autoGroup || "" === opts.groupSeparator || charAtPos === opts.radixPoint && currentResult.pos === undefined && !currentResult.dopost) processValue = processValue.join(""); else {
                            var addRadix = processValue[processValue.length - 1] === opts.radixPoint && currentResult.c === opts.radixPoint;
                            processValue = Inputmask(function(buffer, opts) {
                                var postMask = "";
                                if (postMask += "(" + opts.groupSeparator + "*{" + opts.groupSize + "}){*}", "" !== opts.radixPoint) {
                                    var radixSplit = buffer.join("").split(opts.radixPoint);
                                    radixSplit[1] && (postMask += opts.radixPoint + "*{" + radixSplit[1].match(/^\d*\??\d*/)[0].length + "}");
                                }
                                return postMask;
                            }(processValue, opts), {
                                numericInput: !0,
                                jitMasking: !0,
                                definitions: {
                                    "*": {
                                        validator: "[0-9?]",
                                        cardinality: 1
                                    }
                                }
                            }).format(processValue.join("")), addRadix && (processValue += opts.radixPoint), 
                            processValue.charAt(0) === opts.groupSeparator && processValue.substr(1);
                        }
                    }
                    if (opts.isNegative && "blur" === currentResult.event && (opts.isNegative = "0" !== processValue), 
                    processValue = prefix + processValue, processValue += suffix, opts.isNegative && (processValue = opts.negationSymbol.front + processValue, 
                    processValue += opts.negationSymbol.back), processValue = processValue.split(""), 
                    charAtPos !== undefined) if (charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back) (caretPos = $.inArray("?", processValue)) > -1 ? processValue[caretPos] = charAtPos : caretPos = currentResult.caret || 0; else if (charAtPos === opts.radixPoint || charAtPos === opts.negationSymbol.front || charAtPos === opts.negationSymbol.back) {
                        var newCaretPos = $.inArray(charAtPos, processValue);
                        -1 !== newCaretPos && (caretPos = newCaretPos);
                    }
                    opts.numericInput && (caretPos = processValue.length - caretPos - 1, processValue = processValue.reverse());
                    var rslt = {
                        caret: charAtPos === undefined || currentResult.pos !== undefined ? caretPos + (opts.numericInput ? -1 : 1) : caretPos,
                        buffer: processValue,
                        refreshFromBuffer: currentResult.dopost || buffer.join("") !== processValue.join("")
                    };
                    return rslt.refreshFromBuffer ? rslt : currentResult;
                },
                onBeforeWrite: function(e, buffer, caretPos, opts) {
                    if (e) switch (e.type) {
                      case "keydown":
                        return opts.postValidation(buffer, {
                            caret: caretPos,
                            dopost: !0
                        }, opts);

                      case "blur":
                      case "checkval":
                        var unmasked;
                        if (function(opts) {
                            opts.parseMinMaxOptions === undefined && (null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""), 
                            "," === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, ".")), 
                            opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN, isNaN(opts.min) && (opts.min = Number.MIN_VALUE)), 
                            null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""), 
                            "," === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, ".")), 
                            opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN, isNaN(opts.max) && (opts.max = Number.MAX_VALUE)), 
                            opts.parseMinMaxOptions = "done");
                        }(opts), null !== opts.min || null !== opts.max) {
                            if (unmasked = opts.onUnMask(buffer.join(""), undefined, $.extend({}, opts, {
                                unmaskAsNumber: !0
                            })), null !== opts.min && unmasked < opts.min) return opts.isNegative = opts.min < 0, 
                            opts.postValidation(opts.min.toString().replace(".", opts.radixPoint).split(""), {
                                caret: caretPos,
                                dopost: !0,
                                placeholder: "0"
                            }, opts);
                            if (null !== opts.max && unmasked > opts.max) return opts.isNegative = opts.max < 0, 
                            opts.postValidation(opts.max.toString().replace(".", opts.radixPoint).split(""), {
                                caret: caretPos,
                                dopost: !0,
                                placeholder: "0"
                            }, opts);
                        }
                        return opts.postValidation(buffer, {
                            caret: caretPos,
                            placeholder: "0",
                            event: "blur"
                        }, opts);

                      case "_checkval":
                        return {
                            caret: caretPos
                        };
                    }
                },
                regex: {
                    integerPart: function(opts, emptyCheck) {
                        return emptyCheck ? new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "+]?") : new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "+]?\\d+");
                    },
                    integerNPart: function(opts) {
                        return new RegExp("[\\d" + Inputmask.escapeRegex(opts.groupSeparator) + Inputmask.escapeRegex(opts.placeholder.charAt(0)) + "]+");
                    }
                },
                definitions: {
                    "~": {
                        validator: function(chrs, maskset, pos, strict, opts, isSelection) {
                            var isValid = strict ? new RegExp("[0-9" + Inputmask.escapeRegex(opts.groupSeparator) + "]").test(chrs) : new RegExp("[0-9]").test(chrs);
                            if (!0 === isValid) {
                                if (!0 !== opts.numericInput && maskset.validPositions[pos] !== undefined && "~" === maskset.validPositions[pos].match.def && !isSelection) {
                                    var processValue = maskset.buffer.join(""), pvRadixSplit = (processValue = (processValue = processValue.replace(new RegExp("[-" + Inputmask.escapeRegex(opts.negationSymbol.front) + "]", "g"), "")).replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), "")).split(opts.radixPoint);
                                    pvRadixSplit.length > 1 && (pvRadixSplit[1] = pvRadixSplit[1].replace(/0/g, opts.placeholder.charAt(0))), 
                                    "0" === pvRadixSplit[0] && (pvRadixSplit[0] = pvRadixSplit[0].replace(/0/g, opts.placeholder.charAt(0))), 
                                    processValue = pvRadixSplit[0] + opts.radixPoint + pvRadixSplit[1] || "";
                                    var bufferTemplate = maskset._buffer.join("");
                                    for (processValue === opts.radixPoint && (processValue = bufferTemplate); null === processValue.match(Inputmask.escapeRegex(bufferTemplate) + "$"); ) bufferTemplate = bufferTemplate.slice(1);
                                    isValid = (processValue = (processValue = processValue.replace(bufferTemplate, "")).split(""))[pos] === undefined ? {
                                        pos: pos,
                                        remove: pos
                                    } : {
                                        pos: pos
                                    };
                                }
                            } else strict || chrs !== opts.radixPoint || maskset.validPositions[pos - 1] !== undefined || (maskset.buffer[pos] = "0", 
                            isValid = {
                                pos: pos + 1
                            });
                            return isValid;
                        },
                        cardinality: 1
                    },
                    "+": {
                        validator: function(chrs, maskset, pos, strict, opts) {
                            return opts.allowMinus && ("-" === chrs || chrs === opts.negationSymbol.front);
                        },
                        cardinality: 1,
                        placeholder: ""
                    },
                    "-": {
                        validator: function(chrs, maskset, pos, strict, opts) {
                            return opts.allowMinus && chrs === opts.negationSymbol.back;
                        },
                        cardinality: 1,
                        placeholder: ""
                    },
                    ":": {
                        validator: function(chrs, maskset, pos, strict, opts) {
                            var radix = "[" + Inputmask.escapeRegex(opts.radixPoint) + "]", isValid = new RegExp(radix).test(chrs);
                            return isValid && maskset.validPositions[pos] && maskset.validPositions[pos].match.placeholder === opts.radixPoint && (isValid = {
                                caret: pos + 1
                            }), isValid;
                        },
                        cardinality: 1,
                        placeholder: function(opts) {
                            return opts.radixPoint;
                        }
                    }
                },
                onUnMask: function(maskedValue, unmaskedValue, opts) {
                    if ("" === unmaskedValue && !0 === opts.nullable) return unmaskedValue;
                    var processValue = maskedValue.replace(opts.prefix, "");
                    return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""), 
                    "" !== opts.placeholder.charAt(0) && (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), "g"), "0")), 
                    opts.unmaskAsNumber ? ("" !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), ".")), 
                    processValue = processValue.replace(new RegExp("^" + Inputmask.escapeRegex(opts.negationSymbol.front)), "-"), 
                    processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), ""), 
                    Number(processValue)) : processValue;
                },
                isComplete: function(buffer, opts) {
                    var maskedValue = buffer.join("");
                    if (buffer.slice().join("") !== maskedValue) return !1;
                    var processValue = maskedValue.replace(opts.prefix, "");
                    return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""), 
                    "," === opts.radixPoint && (processValue = processValue.replace(Inputmask.escapeRegex(opts.radixPoint), ".")), 
                    isFinite(processValue);
                },
                onBeforeMask: function(initialValue, opts) {
                    if (opts.isNegative = undefined, initialValue = initialValue.toString().charAt(initialValue.length - 1) === opts.radixPoint ? initialValue.toString().substr(0, initialValue.length - 1) : initialValue.toString(), 
                    "" !== opts.radixPoint && isFinite(initialValue)) {
                        var vs = initialValue.split("."), groupSize = "" !== opts.groupSeparator ? parseInt(opts.groupSize) : 0;
                        2 === vs.length && (vs[0].length > groupSize || vs[1].length > groupSize || vs[0].length <= groupSize && vs[1].length < groupSize) && (initialValue = initialValue.replace(".", opts.radixPoint));
                    }
                    var kommaMatches = initialValue.match(/,/g), dotMatches = initialValue.match(/\./g);
                    if (initialValue = dotMatches && kommaMatches ? dotMatches.length > kommaMatches.length ? (initialValue = initialValue.replace(/\./g, "")).replace(",", opts.radixPoint) : kommaMatches.length > dotMatches.length ? (initialValue = initialValue.replace(/,/g, "")).replace(".", opts.radixPoint) : initialValue.indexOf(".") < initialValue.indexOf(",") ? initialValue.replace(/\./g, "") : initialValue.replace(/,/g, "") : initialValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""), 
                    0 === opts.digits && (-1 !== initialValue.indexOf(".") ? initialValue = initialValue.substring(0, initialValue.indexOf(".")) : -1 !== initialValue.indexOf(",") && (initialValue = initialValue.substring(0, initialValue.indexOf(",")))), 
                    "" !== opts.radixPoint && isFinite(opts.digits) && -1 !== initialValue.indexOf(opts.radixPoint)) {
                        var decPart = initialValue.split(opts.radixPoint)[1].match(new RegExp("\\d*"))[0];
                        if (parseInt(opts.digits) < decPart.toString().length) {
                            var digitsFactor = Math.pow(10, parseInt(opts.digits));
                            initialValue = initialValue.replace(Inputmask.escapeRegex(opts.radixPoint), "."), 
                            initialValue = (initialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor).toString().replace(".", opts.radixPoint);
                        }
                    }
                    return initialValue;
                },
                canClearPosition: function(maskset, position, lvp, strict, opts) {
                    var vp = maskset.validPositions[position], canClear = vp.input !== opts.radixPoint || null !== maskset.validPositions[position].match.fn && !1 === opts.decimalProtect || vp.input === opts.radixPoint && maskset.validPositions[position + 1] && null === maskset.validPositions[position + 1].match.fn || isFinite(vp.input) || position === lvp || vp.input === opts.groupSeparator || vp.input === opts.negationSymbol.front || vp.input === opts.negationSymbol.back;
                    return !canClear || "+" !== vp.match.nativeDef && "-" !== vp.match.nativeDef || (opts.isNegative = !1), 
                    canClear;
                },
                onKeyDown: function(e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey) switch (e.keyCode) {
                      case Inputmask.keyCode.UP:
                        $input.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger("setvalue");
                        break;

                      case Inputmask.keyCode.DOWN:
                        $input.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger("setvalue");
                    }
                }
            },
            currency: {
                prefix: "$ ",
                groupSeparator: ",",
                alias: "numeric",
                placeholder: "0",
                autoGroup: !0,
                digits: 2,
                digitsOptional: !1,
                clearMaskOnLostFocus: !1
            },
            decimal: {
                alias: "numeric"
            },
            integer: {
                alias: "numeric",
                digits: 0,
                radixPoint: ""
            },
            percentage: {
                alias: "numeric",
                digits: 2,
                digitsOptional: !0,
                radixPoint: ".",
                placeholder: "0",
                autoGroup: !1,
                min: 0,
                max: 100,
                suffix: " %",
                allowMinus: !1
            }
        }), Inputmask;
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    !function(factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0), __webpack_require__(1) ], 
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function($, Inputmask) {
        function maskSort(a, b) {
            var maska = (a.mask || a).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""), maskb = (b.mask || b).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""), maskas = (a.mask || a).split("#")[0], maskbs = (b.mask || b).split("#")[0];
            return 0 === maskbs.indexOf(maskas) ? -1 : 0 === maskas.indexOf(maskbs) ? 1 : maska.localeCompare(maskb);
        }
        var analyseMaskBase = Inputmask.prototype.analyseMask;
        return Inputmask.prototype.analyseMask = function(mask, regexMask, opts) {
            function reduceVariations(masks, previousVariation, previousmaskGroup) {
                previousVariation = previousVariation || "", previousmaskGroup = previousmaskGroup || maskGroups, 
                "" !== previousVariation && (previousmaskGroup[previousVariation] = {});
                for (var variation = "", maskGroup = previousmaskGroup[previousVariation] || previousmaskGroup, i = masks.length - 1; i >= 0; i--) maskGroup[variation = (mask = masks[i].mask || masks[i]).substr(0, 1)] = maskGroup[variation] || [], 
                maskGroup[variation].unshift(mask.substr(1)), masks.splice(i, 1);
                for (var ndx in maskGroup) maskGroup[ndx].length > 500 && reduceVariations(maskGroup[ndx].slice(), ndx, maskGroup);
            }
            function rebuild(maskGroup) {
                var mask = "", submasks = [];
                for (var ndx in maskGroup) $.isArray(maskGroup[ndx]) ? 1 === maskGroup[ndx].length ? submasks.push(ndx + maskGroup[ndx]) : submasks.push(ndx + opts.groupmarker.start + maskGroup[ndx].join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end) : submasks.push(ndx + rebuild(maskGroup[ndx]));
                return 1 === submasks.length ? mask += submasks[0] : mask += opts.groupmarker.start + submasks.join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end, 
                mask;
            }
            var maskGroups = {};
            return opts.phoneCodes && (opts.phoneCodes && opts.phoneCodes.length > 1e3 && (reduceVariations((mask = mask.substr(1, mask.length - 2)).split(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start)), 
            mask = rebuild(maskGroups)), mask = mask.replace(/9/g, "\\9")), analyseMaskBase.call(this, mask, regexMask, opts);
        }, Inputmask.extendAliases({
            abstractphone: {
                groupmarker: {
                    start: "<",
                    end: ">"
                },
                countrycode: "",
                phoneCodes: [],
                mask: function(opts) {
                    return opts.definitions = {
                        "#": Inputmask.prototype.definitions[9]
                    }, opts.phoneCodes.sort(maskSort);
                },
                keepStatic: !0,
                onBeforeMask: function(value, opts) {
                    var processedValue = value.replace(/^0{1,2}/, "").replace(/[\s]/g, "");
                    return (processedValue.indexOf(opts.countrycode) > 1 || -1 === processedValue.indexOf(opts.countrycode)) && (processedValue = "+" + opts.countrycode + processedValue), 
                    processedValue;
                },
                onUnMask: function(maskedValue, unmaskedValue, opts) {
                    return maskedValue.replace(/[()#-]/g, "");
                },
                inputmode: "tel"
            }
        }), Inputmask;
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    !function(factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0), __webpack_require__(1) ], 
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function($, Inputmask) {
        return Inputmask.extendAliases({
            Regex: {
                mask: "r",
                greedy: !1,
                repeat: "*",
                regex: null,
                regexTokens: null,
                tokenizer: /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
                quantifierFilter: /[0-9]+[^,]/,
                isComplete: function(buffer, opts) {
                    return new RegExp(opts.regex, opts.casing ? "i" : "").test(buffer.join(""));
                },
                definitions: {
                    r: {
                        validator: function(chrs, maskset, pos, strict, opts) {
                            function RegexToken(isGroup, isQuantifier) {
                                this.matches = [], this.isGroup = isGroup || !1, this.isQuantifier = isQuantifier || !1, 
                                this.quantifier = {
                                    min: 1,
                                    max: 1
                                }, this.repeaterPart = void 0;
                            }
                            function validateRegexToken(token, fromGroup) {
                                var isvalid = !1;
                                fromGroup && (regexPart += "(", openGroupCount++);
                                for (var mndx = 0; mndx < token.matches.length; mndx++) {
                                    var matchToken = token.matches[mndx];
                                    if (!0 === matchToken.isGroup) isvalid = validateRegexToken(matchToken, !0); else if (!0 === matchToken.isQuantifier) {
                                        var crrntndx = $.inArray(matchToken, token.matches), matchGroup = token.matches[crrntndx - 1], regexPartBak = regexPart;
                                        if (isNaN(matchToken.quantifier.max)) {
                                            for (;matchToken.repeaterPart && matchToken.repeaterPart !== regexPart && matchToken.repeaterPart.length > regexPart.length && !(isvalid = validateRegexToken(matchGroup, !0)); ) ;
                                            (isvalid = isvalid || validateRegexToken(matchGroup, !0)) && (matchToken.repeaterPart = regexPart), 
                                            regexPart = regexPartBak + matchToken.quantifier.max;
                                        } else {
                                            for (var i = 0, qm = matchToken.quantifier.max - 1; i < qm && !(isvalid = validateRegexToken(matchGroup, !0)); i++) ;
                                            regexPart = regexPartBak + "{" + matchToken.quantifier.min + "," + matchToken.quantifier.max + "}";
                                        }
                                    } else if (void 0 !== matchToken.matches) for (var k = 0; k < matchToken.length && !(isvalid = validateRegexToken(matchToken[k], fromGroup)); k++) ; else {
                                        var testExp;
                                        if ("[" == matchToken.charAt(0)) {
                                            testExp = regexPart, testExp += matchToken;
                                            for (j = 0; j < openGroupCount; j++) testExp += ")";
                                            isvalid = (exp = new RegExp("^(" + testExp + ")$", opts.casing ? "i" : "")).test(bufferStr);
                                        } else for (var l = 0, tl = matchToken.length; l < tl; l++) if ("\\" !== matchToken.charAt(l)) {
                                            testExp = regexPart, testExp = (testExp += matchToken.substr(0, l + 1)).replace(/\|$/, "");
                                            for (var j = 0; j < openGroupCount; j++) testExp += ")";
                                            var exp = new RegExp("^(" + testExp + ")$", opts.casing ? "i" : "");
                                            if (isvalid = exp.test(bufferStr)) break;
                                        }
                                        regexPart += matchToken;
                                    }
                                    if (isvalid) break;
                                }
                                return fromGroup && (regexPart += ")", openGroupCount--), isvalid;
                            }
                            var bufferStr, groupToken, cbuffer = maskset.buffer.slice(), regexPart = "", isValid = !1, openGroupCount = 0;
                            null === opts.regexTokens && function() {
                                var match, m, currentToken = new RegexToken(), opengroups = [];
                                for (opts.regexTokens = []; match = opts.tokenizer.exec(opts.regex); ) switch ((m = match[0]).charAt(0)) {
                                  case "(":
                                    opengroups.push(new RegexToken(!0));
                                    break;

                                  case ")":
                                    groupToken = opengroups.pop(), opengroups.length > 0 ? opengroups[opengroups.length - 1].matches.push(groupToken) : currentToken.matches.push(groupToken);
                                    break;

                                  case "{":
                                  case "+":
                                  case "*":
                                    var quantifierToken = new RegexToken(!1, !0), mq = (m = m.replace(/[{}]/g, "")).split(","), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]), mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
                                    if (quantifierToken.quantifier = {
                                        min: mq0,
                                        max: mq1
                                    }, opengroups.length > 0) {
                                        var matches = opengroups[opengroups.length - 1].matches;
                                        (match = matches.pop()).isGroup || ((groupToken = new RegexToken(!0)).matches.push(match), 
                                        match = groupToken), matches.push(match), matches.push(quantifierToken);
                                    } else (match = currentToken.matches.pop()).isGroup || ((groupToken = new RegexToken(!0)).matches.push(match), 
                                    match = groupToken), currentToken.matches.push(match), currentToken.matches.push(quantifierToken);
                                    break;

                                  default:
                                    opengroups.length > 0 ? opengroups[opengroups.length - 1].matches.push(m) : currentToken.matches.push(m);
                                }
                                currentToken.matches.length > 0 && opts.regexTokens.push(currentToken);
                            }(), cbuffer.splice(pos, 0, chrs), bufferStr = cbuffer.join("");
                            for (var i = 0; i < opts.regexTokens.length; i++) {
                                var regexToken = opts.regexTokens[i];
                                if (isValid = validateRegexToken(regexToken, regexToken.isGroup)) break;
                            }
                            return isValid;
                        },
                        cardinality: 1
                    }
                }
            }
        }), Inputmask;
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    !function(factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(2), __webpack_require__(1) ], 
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function($, Inputmask) {
        return void 0 === $.fn.inputmask && ($.fn.inputmask = function(fn, options) {
            var nptmask, input = this[0];
            if (void 0 === options && (options = {}), "string" == typeof fn) switch (fn) {
              case "unmaskedvalue":
                return input && input.inputmask ? input.inputmask.unmaskedvalue() : $(input).val();

              case "remove":
                return this.each(function() {
                    this.inputmask && this.inputmask.remove();
                });

              case "getemptymask":
                return input && input.inputmask ? input.inputmask.getemptymask() : "";

              case "hasMaskedValue":
                return !(!input || !input.inputmask) && input.inputmask.hasMaskedValue();

              case "isComplete":
                return !input || !input.inputmask || input.inputmask.isComplete();

              case "getmetadata":
                return input && input.inputmask ? input.inputmask.getmetadata() : void 0;

              case "setvalue":
                $(input).val(options), input && void 0 === input.inputmask && $(input).triggerHandler("setvalue");
                break;

              case "option":
                if ("string" != typeof options) return this.each(function() {
                    if (void 0 !== this.inputmask) return this.inputmask.option(options);
                });
                if (input && void 0 !== input.inputmask) return input.inputmask.option(options);
                break;

              default:
                return options.alias = fn, nptmask = new Inputmask(options), this.each(function() {
                    nptmask.mask(this);
                });
            } else {
                if ("object" == (void 0 === fn ? "undefined" : _typeof(fn))) return nptmask = new Inputmask(fn), 
                void 0 === fn.mask && void 0 === fn.alias ? this.each(function() {
                    if (void 0 !== this.inputmask) return this.inputmask.option(fn);
                    nptmask.mask(this);
                }) : this.each(function() {
                    nptmask.mask(this);
                });
                if (void 0 === fn) return this.each(function() {
                    (nptmask = new Inputmask(options)).mask(this);
                });
            }
        }), $.fn.inputmask;
    });
} ]);
/*! Selectric ϟ v1.13.0 (2017-08-22) - git.io/tjl9sQ - Copyright (c) 2017 Leonardo Santos - MIT License */
!function(e){"function"==typeof define&&define.amd?define(["jquery"],e):"object"==typeof module&&module.exports?module.exports=function(t,s){return void 0===s&&(s="undefined"!=typeof window?require("jquery"):require("jquery")(t)),e(s),s}:e(jQuery)}(function(e){"use strict";var t=e(document),s=e(window),l=["a","e","i","o","u","n","c","y"],i=[/[\xE0-\xE5]/g,/[\xE8-\xEB]/g,/[\xEC-\xEF]/g,/[\xF2-\xF6]/g,/[\xF9-\xFC]/g,/[\xF1]/g,/[\xE7]/g,/[\xFD-\xFF]/g],n=function(t,s){var l=this;l.element=t,l.$element=e(t),l.state={multiple:!!l.$element.attr("multiple"),enabled:!1,opened:!1,currValue:-1,selectedIdx:-1,highlightedIdx:-1},l.eventTriggers={open:l.open,close:l.close,destroy:l.destroy,refresh:l.refresh,init:l.init},l.init(s)};n.prototype={utils:{isMobile:function(){return/android|ip(hone|od|ad)/i.test(navigator.userAgent)},escapeRegExp:function(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")},replaceDiacritics:function(e){for(var t=i.length;t--;)e=e.toLowerCase().replace(i[t],l[t]);return e},format:function(e){var t=arguments;return(""+e).replace(/\{(?:(\d+)|(\w+))\}/g,function(e,s,l){return l&&t[1]?t[1][l]:t[s]})},nextEnabledItem:function(e,t){for(;e[t=(t+1)%e.length].disabled;);return t},previousEnabledItem:function(e,t){for(;e[t=(t>0?t:e.length)-1].disabled;);return t},toDash:function(e){return e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()},triggerCallback:function(t,s){var l=s.element,i=s.options["on"+t],n=[l].concat([].slice.call(arguments).slice(1));e.isFunction(i)&&i.apply(l,n),e(l).trigger("selectric-"+this.toDash(t),n)},arrayToClassname:function(t){var s=e.grep(t,function(e){return!!e});return e.trim(s.join(" "))}},init:function(t){var s=this;if(s.options=e.extend(!0,{},e.fn.selectric.defaults,s.options,t),s.utils.triggerCallback("BeforeInit",s),s.destroy(!0),s.options.disableOnMobile&&s.utils.isMobile())return void(s.disableOnMobile=!0);s.classes=s.getClassNames();var l=e("<input/>",{class:s.classes.input,readonly:s.utils.isMobile()}),i=e("<div/>",{class:s.classes.items,tabindex:-1}),n=e("<div/>",{class:s.classes.scroll}),a=e("<div/>",{class:s.classes.prefix,html:s.options.arrowButtonMarkup}),o=e("<span/>",{class:"label"}),r=s.$element.wrap("<div/>").parent().append(a.prepend(o),i,l),u=e("<div/>",{class:s.classes.hideselect});s.elements={input:l,items:i,itemsScroll:n,wrapper:a,label:o,outerWrapper:r},s.options.nativeOnMobile&&s.utils.isMobile()&&(s.elements.input=void 0,u.addClass(s.classes.prefix+"-is-native"),s.$element.on("change",function(){s.refresh()})),s.$element.on(s.eventTriggers).wrap(u),s.originalTabindex=s.$element.prop("tabindex"),s.$element.prop("tabindex",-1),s.populate(),s.activate(),s.utils.triggerCallback("Init",s)},activate:function(){var e=this,t=e.elements.items.closest(":visible").children(":hidden").addClass(e.classes.tempshow),s=e.$element.width();t.removeClass(e.classes.tempshow),e.utils.triggerCallback("BeforeActivate",e),e.elements.outerWrapper.prop("class",e.utils.arrayToClassname([e.classes.wrapper,e.$element.prop("class").replace(/\S+/g,e.classes.prefix+"-$&"),e.options.responsive?e.classes.responsive:""])),e.options.inheritOriginalWidth&&s>0&&e.elements.outerWrapper.width(s),e.unbindEvents(),e.$element.prop("disabled")?(e.elements.outerWrapper.addClass(e.classes.disabled),e.elements.input&&e.elements.input.prop("disabled",!0)):(e.state.enabled=!0,e.elements.outerWrapper.removeClass(e.classes.disabled),e.$li=e.elements.items.removeAttr("style").find("li"),e.bindEvents()),e.utils.triggerCallback("Activate",e)},getClassNames:function(){var t=this,s=t.options.customClass,l={};return e.each("Input Items Open Disabled TempShow HideSelect Wrapper Focus Hover Responsive Above Below Scroll Group GroupLabel".split(" "),function(e,i){var n=s.prefix+i;l[i.toLowerCase()]=s.camelCase?n:t.utils.toDash(n)}),l.prefix=s.prefix,l},setLabel:function(){var t=this,s=t.options.labelBuilder;if(t.state.multiple){var l=e.isArray(t.state.currValue)?t.state.currValue:[t.state.currValue];l=0===l.length?[0]:l;var i=e.map(l,function(s){return e.grep(t.lookupItems,function(e){return e.index===s})[0]});i=e.grep(i,function(t){return i.length>1||0===i.length?""!==e.trim(t.value):t}),i=e.map(i,function(l){return e.isFunction(s)?s(l):t.utils.format(s,l)}),t.options.multiple.maxLabelEntries&&(i.length>=t.options.multiple.maxLabelEntries+1?(i=i.slice(0,t.options.multiple.maxLabelEntries),i.push(e.isFunction(s)?s({text:"..."}):t.utils.format(s,{text:"..."}))):i.slice(i.length-1)),t.elements.label.html(i.join(t.options.multiple.separator))}else{var n=t.lookupItems[t.state.currValue];t.elements.label.html(e.isFunction(s)?s(n):t.utils.format(s,n))}},populate:function(){var t=this,s=t.$element.children(),l=t.$element.find("option"),i=l.filter(":selected"),n=l.index(i),a=0,o=t.state.multiple?[]:0;i.length>1&&t.state.multiple&&(n=[],i.each(function(){n.push(e(this).index())})),t.state.currValue=~n?n:o,t.state.selectedIdx=t.state.currValue,t.state.highlightedIdx=t.state.currValue,t.items=[],t.lookupItems=[],s.length&&(s.each(function(s){var l=e(this);if(l.is("optgroup")){var i={element:l,label:l.prop("label"),groupDisabled:l.prop("disabled"),items:[]};l.children().each(function(s){var l=e(this);i.items[s]=t.getItemData(a,l,i.groupDisabled||l.prop("disabled")),t.lookupItems[a]=i.items[s],a++}),t.items[s]=i}else t.items[s]=t.getItemData(a,l,l.prop("disabled")),t.lookupItems[a]=t.items[s],a++}),t.setLabel(),t.elements.items.append(t.elements.itemsScroll.html(t.getItemsMarkup(t.items))))},getItemData:function(t,s,l){var i=this;return{index:t,element:s,value:s.val(),className:s.prop("class"),text:s.html(),slug:e.trim(i.utils.replaceDiacritics(s.html())),alt:s.attr("data-alt"),selected:s.prop("selected"),disabled:l}},getItemsMarkup:function(t){var s=this,l="<ul>";return e.isFunction(s.options.listBuilder)&&s.options.listBuilder&&(t=s.options.listBuilder(t)),e.each(t,function(t,i){void 0!==i.label?(l+=s.utils.format('<ul class="{1}"><li class="{2}">{3}</li>',s.utils.arrayToClassname([s.classes.group,i.groupDisabled?"disabled":"",i.element.prop("class")]),s.classes.grouplabel,i.element.prop("label")),e.each(i.items,function(e,t){l+=s.getItemMarkup(t.index,t)}),l+="</ul>"):l+=s.getItemMarkup(i.index,i)}),l+"</ul>"},getItemMarkup:function(t,s){var l=this,i=l.options.optionsItemBuilder,n={value:s.value,text:s.text,slug:s.slug,index:s.index};return l.utils.format('<li data-index="{1}" class="{2}">{3}</li>',t,l.utils.arrayToClassname([s.className,t===l.items.length-1?"last":"",s.disabled?"disabled":"",s.selected?"selected":""]),e.isFunction(i)?l.utils.format(i(s,this.$element,t),s):l.utils.format(i,n))},unbindEvents:function(){var e=this;e.elements.wrapper.add(e.$element).add(e.elements.outerWrapper).add(e.elements.input).off(".sl")},bindEvents:function(){var t=this;t.elements.outerWrapper.on("mouseenter.sl mouseleave.sl",function(s){e(this).toggleClass(t.classes.hover,"mouseenter"===s.type),t.options.openOnHover&&(clearTimeout(t.closeTimer),"mouseleave"===s.type?t.closeTimer=setTimeout(e.proxy(t.close,t),t.options.hoverIntentTimeout):t.open())}),t.elements.wrapper.on("click.sl",function(e){t.state.opened?t.close():t.open(e)}),t.options.nativeOnMobile&&t.utils.isMobile()||(t.$element.on("focus.sl",function(){t.elements.input.focus()}),t.elements.input.prop({tabindex:t.originalTabindex,disabled:!1}).on("keydown.sl",e.proxy(t.handleKeys,t)).on("focusin.sl",function(e){t.elements.outerWrapper.addClass(t.classes.focus),t.elements.input.one("blur",function(){t.elements.input.blur()}),t.options.openOnFocus&&!t.state.opened&&t.open(e)}).on("focusout.sl",function(){t.elements.outerWrapper.removeClass(t.classes.focus)}).on("input propertychange",function(){var s=t.elements.input.val(),l=new RegExp("^"+t.utils.escapeRegExp(s),"i");clearTimeout(t.resetStr),t.resetStr=setTimeout(function(){t.elements.input.val("")},t.options.keySearchTimeout),s.length&&e.each(t.items,function(e,s){if(!s.disabled){if(l.test(s.text)||l.test(s.slug))return void t.highlight(e);if(s.alt)for(var i=s.alt.split("|"),n=0;n<i.length&&i[n];n++)if(l.test(i[n].trim()))return void t.highlight(e)}})})),t.$li.on({mousedown:function(e){e.preventDefault(),e.stopPropagation()},click:function(){return t.select(e(this).data("index")),!1}})},handleKeys:function(t){var s=this,l=t.which,i=s.options.keys,n=e.inArray(l,i.previous)>-1,a=e.inArray(l,i.next)>-1,o=e.inArray(l,i.select)>-1,r=e.inArray(l,i.open)>-1,u=s.state.highlightedIdx,p=n&&0===u||a&&u+1===s.items.length,c=0;if(13!==l&&32!==l||t.preventDefault(),n||a){if(!s.options.allowWrap&&p)return;n&&(c=s.utils.previousEnabledItem(s.lookupItems,u)),a&&(c=s.utils.nextEnabledItem(s.lookupItems,u)),s.highlight(c)}if(o&&s.state.opened)return s.select(u),void(s.state.multiple&&s.options.multiple.keepMenuOpen||s.close());r&&!s.state.opened&&s.open()},refresh:function(){var e=this;e.populate(),e.activate(),e.utils.triggerCallback("Refresh",e)},setOptionsDimensions:function(){var e=this,t=e.elements.items.closest(":visible").children(":hidden").addClass(e.classes.tempshow),s=e.options.maxHeight,l=e.elements.items.outerWidth(),i=e.elements.wrapper.outerWidth()-(l-e.elements.items.width());!e.options.expandToItemText||i>l?e.finalWidth=i:(e.elements.items.css("overflow","scroll"),e.elements.outerWrapper.width(9e4),e.finalWidth=e.elements.items.width(),e.elements.items.css("overflow",""),e.elements.outerWrapper.width("")),e.elements.items.width(e.finalWidth).height()>s&&e.elements.items.height(s),t.removeClass(e.classes.tempshow)},isInViewport:function(){var e=this;if(!0===e.options.forceRenderAbove)e.elements.outerWrapper.addClass(e.classes.above);else if(!0===e.options.forceRenderBelow)e.elements.outerWrapper.addClass(e.classes.below);else{var t=s.scrollTop(),l=s.height(),i=e.elements.outerWrapper.offset().top,n=e.elements.outerWrapper.outerHeight(),a=i+n+e.itemsHeight<=t+l,o=i-e.itemsHeight>t,r=!a&&o,u=!r;e.elements.outerWrapper.toggleClass(e.classes.above,r),e.elements.outerWrapper.toggleClass(e.classes.below,u)}},detectItemVisibility:function(t){var s=this,l=s.$li.filter("[data-index]");s.state.multiple&&(t=e.isArray(t)&&0===t.length?0:t,t=e.isArray(t)?Math.min.apply(Math,t):t);var i=l.eq(t).outerHeight(),n=l[t].offsetTop,a=s.elements.itemsScroll.scrollTop(),o=n+2*i;s.elements.itemsScroll.scrollTop(o>a+s.itemsHeight?o-s.itemsHeight:n-i<a?n-i:a)},open:function(s){var l=this;if(l.options.nativeOnMobile&&l.utils.isMobile())return!1;l.utils.triggerCallback("BeforeOpen",l),s&&(s.preventDefault(),l.options.stopPropagation&&s.stopPropagation()),l.state.enabled&&(l.setOptionsDimensions(),e("."+l.classes.hideselect,"."+l.classes.open).children().selectric("close"),l.state.opened=!0,l.itemsHeight=l.elements.items.outerHeight(),l.itemsInnerHeight=l.elements.items.height(),l.elements.outerWrapper.addClass(l.classes.open),l.elements.input.val(""),s&&"focusin"!==s.type&&l.elements.input.focus(),setTimeout(function(){t.on("click.sl",e.proxy(l.close,l)).on("scroll.sl",e.proxy(l.isInViewport,l))},1),l.isInViewport(),l.options.preventWindowScroll&&t.on("mousewheel.sl DOMMouseScroll.sl","."+l.classes.scroll,function(t){var s=t.originalEvent,i=e(this).scrollTop(),n=0;"detail"in s&&(n=-1*s.detail),"wheelDelta"in s&&(n=s.wheelDelta),"wheelDeltaY"in s&&(n=s.wheelDeltaY),"deltaY"in s&&(n=-1*s.deltaY),(i===this.scrollHeight-l.itemsInnerHeight&&n<0||0===i&&n>0)&&t.preventDefault()}),l.detectItemVisibility(l.state.selectedIdx),l.highlight(l.state.multiple?-1:l.state.selectedIdx),l.utils.triggerCallback("Open",l))},close:function(){var e=this;e.utils.triggerCallback("BeforeClose",e),t.off(".sl"),e.elements.outerWrapper.removeClass(e.classes.open),e.state.opened=!1,e.utils.triggerCallback("Close",e)},change:function(){var t=this;t.utils.triggerCallback("BeforeChange",t),t.state.multiple?(e.each(t.lookupItems,function(e){t.lookupItems[e].selected=!1,t.$element.find("option").prop("selected",!1)}),e.each(t.state.selectedIdx,function(e,s){t.lookupItems[s].selected=!0,t.$element.find("option").eq(s).prop("selected",!0)}),t.state.currValue=t.state.selectedIdx,t.setLabel(),t.utils.triggerCallback("Change",t)):t.state.currValue!==t.state.selectedIdx&&(t.$element.prop("selectedIndex",t.state.currValue=t.state.selectedIdx).data("value",t.lookupItems[t.state.selectedIdx].text),t.setLabel(),t.utils.triggerCallback("Change",t))},highlight:function(e){var t=this,s=t.$li.filter("[data-index]").removeClass("highlighted");t.utils.triggerCallback("BeforeHighlight",t),void 0===e||-1===e||t.lookupItems[e].disabled||(s.eq(t.state.highlightedIdx=e).addClass("highlighted"),t.detectItemVisibility(e),t.utils.triggerCallback("Highlight",t))},select:function(t){var s=this,l=s.$li.filter("[data-index]");if(s.utils.triggerCallback("BeforeSelect",s,t),void 0!==t&&-1!==t&&!s.lookupItems[t].disabled){if(s.state.multiple){s.state.selectedIdx=e.isArray(s.state.selectedIdx)?s.state.selectedIdx:[s.state.selectedIdx];var i=e.inArray(t,s.state.selectedIdx);-1!==i?s.state.selectedIdx.splice(i,1):s.state.selectedIdx.push(t),l.removeClass("selected").filter(function(t){return-1!==e.inArray(t,s.state.selectedIdx)}).addClass("selected")}else l.removeClass("selected").eq(s.state.selectedIdx=t).addClass("selected");s.state.multiple&&s.options.multiple.keepMenuOpen||s.close(),s.change(),s.utils.triggerCallback("Select",s,t)}},destroy:function(e){var t=this;t.state&&t.state.enabled&&(t.elements.items.add(t.elements.wrapper).add(t.elements.input).remove(),e||t.$element.removeData("selectric").removeData("value"),t.$element.prop("tabindex",t.originalTabindex).off(".sl").off(t.eventTriggers).unwrap().unwrap(),t.state.enabled=!1)}},e.fn.selectric=function(t){return this.each(function(){var s=e.data(this,"selectric");s&&!s.disableOnMobile?"string"==typeof t&&s[t]?s[t]():s.init(t):e.data(this,"selectric",new n(this,t))})},e.fn.selectric.defaults={onChange:function(t){e(t).change()},maxHeight:300,keySearchTimeout:500,arrowButtonMarkup:'<b class="button">&#x25be;</b>',disableOnMobile:!1,nativeOnMobile:!0,openOnFocus:!0,openOnHover:!1,hoverIntentTimeout:500,expandToItemText:!1,responsive:!1,preventWindowScroll:!0,inheritOriginalWidth:!1,allowWrap:!0,forceRenderAbove:!1,forceRenderBelow:!1,stopPropagation:!0,optionsItemBuilder:"{text}",labelBuilder:"{text}",listBuilder:!1,keys:{previous:[37,38],next:[39,40],select:[9,13,27],open:[13,32,37,38,39,40],close:[9,27]},customClass:{prefix:"selectric",camelCase:!1},multiple:{separator:", ",keepMenuOpen:!0,maxLabelEntries:!1}}});
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(require("jquery")):"function"==typeof define&&define.amd?define(["jquery"],t):t(e.jQuery)}(this,function(e){"use strict";function t(e){return function(t){if(0===t.length)return!1;if(1===t.length)return!0;var n=e(t[0].value);return 0===t.filter(function(t){return 0!==e(t.value).indexOf(n)}).length}}function n(e,t){return function(n,i){var s,o=[];return t(i)&&(s=P.splitTokens(P.split(n,e)),v.each(i,function(t,i){var a=t.value;if(P.stringEncloses(n,a))return!1;var r=P.splitTokens(P.split(a,e));0===v.minus(s,r).length&&o.push(i)})),1===o.length?o[0]:-1}}function i(e,t){var n=e.data&&e.data[t];return n&&new RegExp("^"+P.escapeRegExChars(n)+"(["+C+"]|$)","i").test(e.value)}function s(e,t){var n=/<strong>/;return n.test(t)&&!n.test(e)?t:e}function o(e,t,n,i,o){var a=this;return s(a.highlightMatches(e,n,i,o),a.highlightMatches(t,n,i,o))}function a(e){this.urlSuffix=e.toLowerCase(),this.noSuggestionsHint="Неизвестное значение",this.matchers=[D.matchByNormalizedQuery(),D.matchByWords()]}function r(t,n){var i=this;i.element=t,i.el=e(t),i.suggestions=[],i.badQueries=[],i.selectedIndex=-1,i.currentValue=i.element.value,i.intervalId=0,i.cachedResponse={},i.enrichmentCache={},i.currentRequest=null,i.inputPhase=e.Deferred(),i.fetchPhase=e.Deferred(),i.enrichPhase=e.Deferred(),i.onChangeTimeout=null,i.triggering={},i.$wrapper=null,i.options=e.extend({},L,n),i.classes=S,i.disabled=!1,i.selection=null,i.$viewport=e(window),i.$body=e(document.body),i.type=null,i.status={},i.setupElement(),i.initializer=e.Deferred(),i.el.is(":visible")?i.initializer.resolve():i.deferInitialization(),i.initializer.done(e.proxy(i.initialize,i))}function l(){B.each(K,function(e){e.abort()}),K={}}function u(){J=null,L.geoLocation=X}function c(t){return e.map(t,function(e){var t=B.escapeHtml(e.text);return t&&e.matched&&(t="<strong>"+t+"</strong>"),t}).join("")}function d(t,n){var i=t.split(", ");return 1===i.length?t:e.map(i,function(e){return'<span class="'+n+'">'+e+"</span>"}).join(", ")}function f(t,n){var i=!1;return e.each(t,function(e,t){if(i=t.value==n.value&&t!=n)return!1}),i}function p(e,t){var n=t.selection,i=n&&n.data&&t.bounds;return i&&v.each(t.bounds.all,function(t,s){return i=n.data[t]===e.data[t]}),i}function h(e){var t=e.replace(/^(\d{2})(\d*?)(0+)$/g,"$1$2"),n=t.length,i=-1;return n<=2?i=2:n>2&&n<=5?i=5:n>5&&n<=8?i=8:n>8&&n<=11?i=11:n>11&&n<=15?i=15:n>15&&(i=19),P.padEnd(t,i,"0")}function g(e){this.plan=e.status.plan,this.isMobile=e.isMobile;var t=e.getContainer();this.element=ge.selectByClass(S.promo,t)}function m(){new g(this).show()}e=e&&"default"in e?e.default:e;var y={isArray:function(e){return Array.isArray(e)},isFunction:function(e){return"[object Function]"===Object.prototype.toString.call(e)},isEmptyObject:function(e){return 0===Object.keys(e).length&&e.constructor===Object},isPlainObject:function(e){return void 0!==e&&"object"==typeof e&&null!==e&&!e.nodeType&&e!==e.window&&!(e.constructor&&!Object.prototype.hasOwnProperty.call(e.constructor.prototype,"isPrototypeOf"))}},v={compact:function(e){return e.filter(function(e){return!!e})},each:function(e,t){if(Array.isArray(e))return void e.some(function(e,n){return!1===t(e,n)});Object.keys(e).some(function(n){var i=e[n];return!1===t(i,n)})},intersect:function(e,t){var n=[];return Array.isArray(e)&&Array.isArray(t)?e.filter(function(e){return-1!==t.indexOf(e)}):n},minus:function(e,t){return t&&0!==t.length?e.filter(function(e){return-1===t.indexOf(e)}):e},makeArray:function(e){return y.isArray(e)?Array.prototype.slice.call(e):[e]},minusWithPartialMatching:function(e,t){return t&&0!==t.length?e.filter(function(e){return!t.some(function(t){return 0===t.indexOf(e)})}):e},slice:function(e,t){return Array.prototype.slice.call(e,t)}},b={delay:function(e,t){return setTimeout(e,t||0)}},_={areSame:function e(t,n){var i=!0;return typeof t==typeof n&&("object"==typeof t&&null!=t&&null!=n?(v.each(t,function(t,s){return i=e(t,n[s])}),i):t===n)},assign:function(e,t){if("function"==typeof Object.assign)return Object.assign.apply(null,arguments);if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var n=Object(e),i=1;i<arguments.length;i++){var s=arguments[i];if(null!=s)for(var o in s)Object.prototype.hasOwnProperty.call(s,o)&&(n[o]=s[o])}return n},clone:function(e){return JSON.parse(JSON.stringify(e))},compact:function(e){var t=_.clone(e);return v.each(t,function(e,n){null!==e&&void 0!==e&&""!==e||delete t[n]}),t},fieldsAreNotEmpty:function(e,t){if(!y.isPlainObject(e))return!1;var n=!0;return v.each(t,function(t,i){return n=!!e[t]}),n},getDeepValue:function e(t,n){var i=n.split("."),s=i.shift();return t&&(i.length?e(t[s],i.join(".")):t[s])},indexObjectsById:function(e,t,n){var i={};return v.each(e,function(e,s){var o=e[t],a={};n&&(a[n]=s),i[o]=_.assign(a,e)}),i}},x={ENTER:13,ESC:27,TAB:9,SPACE:32,UP:38,DOWN:40},S={hint:"suggestions-hint",mobile:"suggestions-mobile",nowrap:"suggestions-nowrap",promo:"suggestions-promo",promo_desktop:"suggestions-promo-desktop",selected:"suggestions-selected",suggestion:"suggestions-suggestion",subtext:"suggestions-subtext",subtext_inline:"suggestions-subtext suggestions-subtext_inline",subtext_delimiter:"suggestions-subtext-delimiter",subtext_label:"suggestions-subtext suggestions-subtext_label",removeConstraint:"suggestions-remove",value:"suggestions-value"},w=".suggestions",C="\\s\"'~\\*\\.,:\\|\\[\\]\\(\\)\\{\\}<>№",E=new RegExp("["+C+"]+","g"),k=new RegExp("[\\-\\+\\\\\\?!@#$%^&]+","g"),P={escapeHtml:function(e){var t={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"};return e&&v.each(t,function(t,n){e=e.replace(new RegExp(n,"g"),t)}),e},escapeRegExChars:function(e){return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")},formatToken:function(e){return e&&e.toLowerCase().replace(/[ёЁ]/g,"е")},getWordExtractorRegExp:function(){return new RegExp("([^"+C+"]*)(["+C+"]*)","g")},normalize:function(e,t){return P.split(e,t).join(" ")},padEnd:function(e,t,n){return String.prototype.padEnd?e.padEnd(t,n):(t>>=0,n=String(void 0!==n?n:" "),e.length>t?String(e):(t-=e.length,t>n.length&&(n+=n.repeat(t/n.length)),String(e)+n.slice(0,t)))},split:function(e,t){e=e.toLowerCase(),e=e.replace("ё","е").replace(/(\d+)([а-я]{2,})/g,"$1 $2").replace(/([а-я]+)(\d+)/g,"$1 $2");var n=v.compact(e.split(E)),i=n.pop(),s=v.minus(n,t);return s.push(i),s},splitTokens:function(e){var t=[];return v.each(e,function(e,n){var i=e.split(k);t=t.concat(v.compact(i))}),t},stringEncloses:function(e,t){return e.length>t.length&&-1!==e.toLowerCase().indexOf(t.toLowerCase())},tokenize:function(e,t){var n=v.compact(P.formatToken(e).split(E)),i=v.minus(n,t),s=v.minus(n,i);return n=P.withSubTokens(i.concat(s))},withSubTokens:function(e){var t=[];return v.each(e,function(e,n){var i=e.split(k);t.push(e),i.length>1&&(t=t.concat(v.compact(i)))}),t}},T={Deferred:function(){return e.Deferred()},ajax:function(t){return e.ajax(t)},extend:function(){return e.extend.apply(null,arguments)},isJqObject:function(t){return t instanceof e},param:function(t){return e.param(t)},proxy:function(t,n){return e.proxy(t,n)},select:function(t){return e(t)},supportsCors:function(){return e.support.cors}},V={getDefaultType:function(){return T.supportsCors()?"POST":"GET"},getDefaultContentType:function(){return T.supportsCors()?"application/json":"application/x-www-form-urlencoded"},fixURLProtocol:function(e){return T.supportsCors()?e:e.replace(/^https?:/,location.protocol)},addUrlParams:function(e,t){return e+(/\?/.test(e)?"&":"?")+T.param(t)},serialize:function(e){return T.supportsCors()?JSON.stringify(e,function(e,t){return null===t?void 0:t}):(e=_.compact(e),T.param(e,!0))}},j=function(){var e=0;return function(t){return(t||"")+ ++e}}(),B={escapeRegExChars:P.escapeRegExChars,escapeHtml:P.escapeHtml,formatToken:P.formatToken,normalize:P.normalize,reWordExtractor:P.getWordExtractorRegExp,stringEncloses:P.stringEncloses,addUrlParams:V.addUrlParams,getDefaultContentType:V.getDefaultContentType,getDefaultType:V.getDefaultType,fixURLProtocol:V.fixURLProtocol,serialize:V.serialize,arrayMinus:v.minus,arrayMinusWithPartialMatching:v.minusWithPartialMatching,arraysIntersection:v.intersect,compact:v.compact,each:v.each,makeArray:v.makeArray,slice:v.slice,delay:b.delay,areSame:_.areSame,compactObject:_.compact,getDeepValue:_.getDeepValue,fieldsNotEmpty:_.fieldsAreNotEmpty,indexBy:_.indexObjectsById,isArray:y.isArray,isEmptyObject:y.isEmptyObject,isFunction:y.isFunction,isPlainObject:y.isPlainObject,uniqueId:j},L={autoSelectFirst:!1,serviceUrl:"https://suggestions.dadata.ru/suggestions/api/4_1/rs",url:null,onSearchStart:e.noop,onSearchComplete:e.noop,onSearchError:e.noop,onSuggestionsFetch:null,onSelect:null,onSelectNothing:null,onInvalidateSelection:null,minChars:1,deferRequestBy:100,enrichmentEnabled:!0,params:{},paramName:"query",timeout:3e3,formatResult:null,formatSelected:null,noCache:!1,containerClass:"suggestions-suggestions",tabDisabled:!1,triggerSelectOnSpace:!1,triggerSelectOnEnter:!0,triggerSelectOnBlur:!0,preventBadQueries:!1,hint:"Выберите вариант или продолжите ввод",noSuggestionsHint:null,type:null,requestMode:"suggest",count:5,$helpers:null,headers:null,scrollOnFocus:!0,mobileWidth:980,initializeInterval:100},O=t(function(e){return e}),R=t(function(e){return e.replace(/, (?:д|вл|двлд|к) .+$/,"")}),D={matchByNormalizedQuery:function(e){return function(t,n){var i=P.normalize(t,e),s=[];return v.each(n,function(n,o){var a=n.value.toLowerCase();return!P.stringEncloses(t,a)&&(!(a.indexOf(i)>0)&&void(i===P.normalize(a,e)&&s.push(o)))}),1===s.length?s[0]:-1}},matchByWords:function(e){return n(e,O)},matchByWordsAddress:function(e){return n(e,R)},matchByFields:function(e){return function(t,n){var i=P.splitTokens(P.split(t)),s=[];return 1===n.length&&(e&&v.each(e,function(e,t){var i=_.getDeepValue(n[0],t),o=i&&P.splitTokens(P.split(i,e));o&&o.length&&(s=s.concat(o))}),0===v.minusWithPartialMatching(i,s).length)?0:-1}}},I=["ао","аобл","дом","респ","а/я","аал","автодорога","аллея","арбан","аул","б-р","берег","бугор","вал","вл","волость","въезд","высел","г","городок","гск","д","двлд","днп","дор","дп","ж/д_будка","ж/д_казарм","ж/д_оп","ж/д_платф","ж/д_пост","ж/д_рзд","ж/д_ст","жилзона","жилрайон","жт","заезд","заимка","зона","к","казарма","канал","кв","кв-л","км","кольцо","комн","кордон","коса","кп","край","линия","лпх","м","массив","местность","мкр","мост","н/п","наб","нп","обл","округ","остров","оф","п","п/о","п/р","п/ст","парк","пгт","пер","переезд","пл","пл-ка","платф","погост","полустанок","починок","пр-кт","проезд","промзона","просек","просека","проселок","проток","протока","проулок","р-н","рзд","россия","рп","ряды","с","с/а","с/мо","с/о","с/п","с/с","сад","сквер","сл","снт","спуск","ст","ст-ца","стр","тер","тракт","туп","у","ул","уч-к","ф/х","ферма","х","ш","бульвар","владение","выселки","гаражно-строительный","город","деревня","домовладение","дорога","квартал","километр","комната","корпус","литер","леспромхоз","местечко","микрорайон","набережная","область","переулок","платформа","площадка","площадь","поселение","поселок","проспект","разъезд","район","республика","село","сельсовет","слобода","сооружение","станица","станция","строение","территория","тупик","улица","улус","участок","хутор","шоссе"],q=[{id:"kladr_id",fields:["kladr_id"],forBounds:!1,forLocations:!0},{id:"postal_code",fields:["postal_code"],forBounds:!1,forLocations:!0},{id:"country",fields:["country"],forBounds:!1,forLocations:!0},{id:"region_fias_id",fields:["region_fias_id"],forBounds:!1,forLocations:!0},{id:"region_type_full",fields:["region_type_full"],forBounds:!1,forLocations:!0,kladrFormat:{digits:2,zeros:11},fiasType:"region_fias_id"},{id:"region",fields:["region","region_type","region_type_full","region_with_type"],forBounds:!0,forLocations:!0,kladrFormat:{digits:2,zeros:11},fiasType:"region_fias_id"},{id:"area_fias_id",fields:["area_fias_id"],forBounds:!1,forLocations:!0},{id:"area_type_full",fields:["area_type_full"],forBounds:!1,forLocations:!0,kladrFormat:{digits:5,zeros:8},fiasType:"area_fias_id"},{id:"area",fields:["area","area_type","area_type_full","area_with_type"],forBounds:!0,forLocations:!0,kladrFormat:{digits:5,zeros:8},fiasType:"area_fias_id"},{id:"city_fias_id",fields:["city_fias_id"],forBounds:!1,forLocations:!0},{id:"city_type_full",fields:["city_type_full"],forBounds:!1,forLocations:!0,kladrFormat:{digits:8,zeros:5},fiasType:"city_fias_id"},{id:"city",fields:["city","city_type","city_type_full","city_with_type"],forBounds:!0,forLocations:!0,kladrFormat:{digits:8,zeros:5},fiasType:"city_fias_id"},{id:"city_district_fias_id",fields:["city_district_fias_id"],forBounds:!1,forLocations:!0},{id:"city_district_type_full",fields:["city_district_type_full"],forBounds:!1,forLocations:!0,kladrFormat:{digits:11,zeros:2},fiasType:"city_district_fias_id"},{id:"city_district",fields:["city_district","city_district_type","city_district_type_full","city_district_with_type"],forBounds:!0,forLocations:!0,kladrFormat:{digits:11,zeros:2},fiasType:"city_district_fias_id"},{id:"settlement_fias_id",fields:["settlement_fias_id"],forBounds:!1,forLocations:!0},{id:"settlement_type_full",fields:["settlement_type_full"],forBounds:!1,forLocations:!0,kladrFormat:{digits:11,zeros:2},fiasType:"settlement_fias_id"},{id:"settlement",fields:["settlement","settlement_type","settlement_type_full","settlement_with_type"],forBounds:!0,forLocations:!0,kladrFormat:{digits:11,zeros:2},fiasType:"settlement_fias_id"},{id:"street_fias_id",fields:["street_fias_id"],forBounds:!1,forLocations:!0},{id:"street_type_full",fields:["street_type_full"],forBounds:!1,forLocations:!0,kladrFormat:{digits:15,zeros:2},fiasType:"street_fias_id"},{id:"street",fields:["street","street_type","street_type_full","street_with_type"],forBounds:!0,forLocations:!0,kladrFormat:{digits:15,zeros:2},fiasType:"street_fias_id"},{id:"house",fields:["house","house_type","house_type_full","block","block_type"],forBounds:!0,forLocations:!1,kladrFormat:{digits:19}}],$={urlSuffix:"address",noSuggestionsHint:"Неизвестный адрес",matchers:[D.matchByNormalizedQuery(I),D.matchByWordsAddress(I)],dataComponents:q,dataComponentsById:_.indexObjectsById(q,"id","index"),unformattableTokens:I,enrichmentEnabled:!0,enrichmentMethod:"suggest",enrichmentParams:{count:1,locations:null,locations_boost:null,from_bound:null,to_bound:null},getEnrichmentQuery:function(e){return e.unrestricted_value},geoEnabled:!0,isDataComplete:function(e){var t=[this.bounds.to||"flat"],n=e.data;return!y.isPlainObject(n)||_.fieldsAreNotEmpty(n,t)},composeValue:function(e,t){var n=e.region_with_type||v.compact([e.region,e.region_type]).join(" ")||e.region_type_full,i=e.area_with_type||v.compact([e.area_type,e.area]).join(" ")||e.area_type_full,s=e.city_with_type||v.compact([e.city_type,e.city]).join(" ")||e.city_type_full,o=e.settlement_with_type||v.compact([e.settlement_type,e.settlement]).join(" ")||e.settlement_type_full,a=e.city_district_with_type||v.compact([e.city_district_type,e.city_district]).join(" ")||e.city_district_type_full,r=e.street_with_type||v.compact([e.street_type,e.street]).join(" ")||e.street_type_full,l=v.compact([e.house_type,e.house,e.block_type,e.block]).join(" "),u=v.compact([e.flat_type,e.flat]).join(" "),c=e.postal_box&&"а/я "+e.postal_box;return n===s&&(n=""),t&&t.saveCityDistrict||(t&&t.excludeCityDistrict?a="":a&&!e.city_district_fias_id&&(a="")),v.compact([n,i,s,a,o,r,l,u,c]).join(", ")},formatResult:function(){var e=[],t=!1;return q.forEach(function(n){t&&e.push(n.id),"city_district"===n.id&&(t=!0)}),function(t,n,i,s){var o,a,r,l=this,u=i.data&&i.data.city_district_with_type,c=s&&s.unformattableTokens,d=i.data&&i.data.history_values;return d&&d.length>0&&(o=P.tokenize(n,c),a=this.type.findUnusedTokens(o,t),(r=this.type.getFormattedHistoryValues(a,d))&&(t+=r)),t=l.highlightMatches(t,n,i,s),t=l.wrapFormattedValue(t,i),u&&(!l.bounds.own.length||l.bounds.own.indexOf("street")>=0)&&!y.isEmptyObject(l.copyDataComponents(i.data,e))&&(t+='<div class="'+l.classes.subtext+'">'+l.highlightMatches(u,n,i)+"</div>"),t}}(),findUnusedTokens:function(e,t){return e.filter(function(e){return-1===t.indexOf(e)})},getFormattedHistoryValues:function(e,t){var n=[],i="";return t.forEach(function(t){v.each(e,function(e){if(t.toLowerCase().indexOf(e)>=0)return n.push(t),!1})}),n.length>0&&(i=" (бывш. "+n.join(", ")+")"),i},getSuggestionValue:function(e,t){var n=null;return t.hasSameValues?n=e.options.restrict_value?this.getValueWithinConstraints(e,t.suggestion):e.bounds.own.length?this.getValueWithinBounds(e,t.suggestion):t.suggestion.unrestricted_value:t.hasBeenEnriched&&e.options.restrict_value&&(n=this.getValueWithinConstraints(e,t.suggestion,{excludeCityDistrict:!0})),n},getValueWithinConstraints:function(e,t,n){return this.composeValue(e.getUnrestrictedData(t.data),n)},getValueWithinBounds:function(e,t,n){var i=e.copyDataComponents(t.data,e.bounds.own.concat(["city_district_fias_id"]));return this.composeValue(i,n)}},F={urlSuffix:"fio",noSuggestionsHint:!1,matchers:[D.matchByNormalizedQuery(),D.matchByWords()],fieldNames:{surname:"фамилия",name:"имя",patronymic:"отчество"},isDataComplete:function(e){var t,n=this,s=n.options.params,o=e.data;return y.isFunction(s)&&(s=s.call(n.element,e.value)),s&&s.parts?t=s.parts.map(function(e){return e.toLowerCase()}):(t=["surname","name"],i(e,"surname")&&t.push("patronymic")),_.fieldsAreNotEmpty(o,t)},composeValue:function(e){return v.compact([e.surname,e.name,e.patronymic]).join(" ")}},A={LEGAL:[2,2,5,1],INDIVIDUAL:[2,2,6,2]},z={urlSuffix:"party",noSuggestionsHint:"Неизвестная организация",matchers:[D.matchByFields({value:null,"data.address.value":I,"data.inn":null,"data.ogrn":null})],dataComponents:q,enrichmentEnabled:!0,enrichmentMethod:"findById",enrichmentParams:{count:1,locations_boost:null},getEnrichmentQuery:function(e){return e.data.hid},geoEnabled:!0,formatResult:function(e,t,n,i){var a=this,r=a.type.formatResultInn.call(a,n,t),l=a.highlightMatches(_.getDeepValue(n.data,"ogrn"),t,n),u=s(r,l),c=a.highlightMatches(_.getDeepValue(n.data,"management.name"),t,n),d=_.getDeepValue(n.data,"address.value")||"";return a.isMobile&&((i||(i={})).maxLength=50),e=o.call(a,e,_.getDeepValue(n.data,"name.latin"),t,n,i),e=a.wrapFormattedValue(e,n),d&&(d=d.replace(/^(\d{6}?\s+|Россия,\s+)/i,""),d=a.isMobile?d.replace(new RegExp("^([^"+C+"]+["+C+"]+[^"+C+"]+).*"),"$1"):a.highlightMatches(d,t,n,{unformattableTokens:I})),(u||d||c)&&(e+='<div class="'+a.classes.subtext+'"><span class="'+a.classes.subtext_inline+'">'+(u||"")+"</span>"+(s(d,c)||"")+"</div>"),e},formatResultInn:function(e,t){var n,i,s=this,o=e.data&&e.data.inn,a=A[e.data&&e.data.type],r=/\d/;if(o)return i=s.highlightMatches(o,t,e),a&&(i=i.split(""),n=a.map(function(e){for(var t,n="";e&&(t=i.shift());)n+=t,r.test(t)&&e--;return n}),i=n.join('<span class="'+s.classes.subtext_delimiter+'"></span>')+i.join("")),i}},N={urlSuffix:"email",noSuggestionsHint:!1,matchers:[D.matchByNormalizedQuery()],isQueryRequestable:function(e){return this.options.suggest_local||e.indexOf("@")>=0}},M={urlSuffix:"bank",noSuggestionsHint:"Неизвестный банк",matchers:[D.matchByFields({value:null,"data.bic":null,"data.swift":null})],dataComponents:q,geoEnabled:!0,formatResult:function(e,t,n,i){var s=this,o=s.highlightMatches(_.getDeepValue(n.data,"bic"),t,n),a=_.getDeepValue(n.data,"address.value")||"";return e=s.highlightMatches(e,t,n,i),e=s.wrapFormattedValue(e,n),a&&(a=a.replace(/^\d{6}( РОССИЯ)?, /i,""),a=s.isMobile?a.replace(new RegExp("^([^"+C+"]+["+C+"]+[^"+C+"]+).*"),"$1"):s.highlightMatches(a,t,n,{unformattableTokens:I})),(o||a)&&(e+='<div class="'+s.classes.subtext+'"><span class="'+s.classes.subtext_inline+'">'+o+"</span>"+a+"</div>"),e},formatSelected:function(e){return _.getDeepValue(e,"data.name.payment")||null}},H={NAME:F,ADDRESS:$,PARTY:z,EMAIL:N,BANK:M};H.get=function(e){return H.hasOwnProperty(e)?H[e]:new a(e)},T.extend(L,{suggest_local:!0});var W={chains:{},on:function(e,t){return this.get(e).push(t),this},get:function(e){var t=this.chains;return t[e]||(t[e]=[])}},U={suggest:{defaultParams:{type:B.getDefaultType(),dataType:"json",contentType:B.getDefaultContentType()},addTypeInUrl:!0},detectAddressByIp:{defaultParams:{type:"GET",dataType:"json"},addTypeInUrl:!1},status:{defaultParams:{type:"GET",dataType:"json"},addTypeInUrl:!0},findById:{defaultParams:{type:B.getDefaultType(),dataType:"json",contentType:B.getDefaultContentType()},addTypeInUrl:!0}},Q={suggest:{method:"suggest",userSelect:!0,updateValue:!0,enrichmentEnabled:!0},findById:{method:"findById",userSelect:!1,updateValue:!1,enrichmentEnabled:!1}};r.prototype={initialize:function(){var e=this;e.uniqueId=B.uniqueId("i"),e.createWrapper(),e.notify("initialize"),e.bindWindowEvents(),e.setOptions(),e.fixPosition()},deferInitialization:function(){var e,t=this,n="mouseover focus keydown",i=function(){t.initializer.resolve(),t.enable()};t.initializer.always(function(){t.el.off(n,i),clearInterval(e)}),t.disabled=!0,t.el.on(n,i),e=setInterval(function(){t.el.is(":visible")&&i()},t.options.initializeInterval)},isInitialized:function(){return"resolved"===this.initializer.state()},dispose:function(){var e=this;e.initializer.reject(),e.notify("dispose"),e.el.removeData("suggestions").removeClass("suggestions-input"),e.unbindWindowEvents(),e.removeWrapper(),e.el.trigger("suggestions-dispose")},notify:function(t){var n=this,i=B.slice(arguments,1);return e.map(W.get(t),function(e){return e.apply(n,i)})},createWrapper:function(){var t=this;t.$wrapper=e('<div class="suggestions-wrapper"/>'),t.el.after(t.$wrapper),t.$wrapper.on("mousedown"+w,e.proxy(t.onMousedown,t))},removeWrapper:function(){var t=this;t.$wrapper&&t.$wrapper.remove(),e(t.options.$helpers).off(w)},onMousedown:function(t){var n=this;t.preventDefault(),n.cancelBlur=!0,B.delay(function(){delete n.cancelBlur}),0==e(t.target).closest(".ui-menu-item").length&&B.delay(function(){e(document).one("mousedown",function(t){var i=n.el.add(n.$wrapper).add(n.options.$helpers);n.options.floating&&(i=i.add(n.$container)),i=i.filter(function(){return this===t.target||e.contains(this,t.target)}),i.length||n.hide()})})},bindWindowEvents:function(){var t=this,n=e.proxy(t.fixPosition,t);t.$viewport.on("resize"+w+t.uniqueId,n).on("scroll"+w+t.uniqueId,n)},unbindWindowEvents:function(){this.$viewport.off("resize"+w+this.uniqueId).off("scroll"+w+this.uniqueId)},scrollToTop:function(){var t=this,n=t.options.scrollOnFocus;!0===n&&(n=t.el),n instanceof e&&n.length>0&&e("body,html").animate({scrollTop:n.offset().top},"fast")},setOptions:function(t){var n=this;e.extend(n.options,t),n.type=H.get(n.options.type),e.each({requestMode:Q},function(t,i){if(n[t]=i[n.options[t]],!n[t])throw n.disable(),"`"+t+"` option is incorrect! Must be one of: "+e.map(i,function(e,t){return'"'+t+'"'}).join(", ")}),e(n.options.$helpers).off(w).on("mousedown"+w,e.proxy(n.onMousedown,n)),n.isInitialized()&&n.notify("setOptions")},fixPosition:function(t){var n,i,s=this,o={};s.isMobile=s.$viewport.width()<=s.options.mobileWidth,s.isInitialized()&&(!t||"scroll"!=t.type||s.options.floating||s.isMobile)&&(s.$container.appendTo(s.options.floating?s.$body:s.$wrapper),s.notify("resetPosition"),s.el.css("paddingLeft",""),s.el.css("paddingRight",""),o.paddingLeft=parseFloat(s.el.css("paddingLeft")),o.paddingRight=parseFloat(s.el.css("paddingRight")),e.extend(o,s.el.offset()),o.borderTop="none"==s.el.css("border-top-style")?0:parseFloat(s.el.css("border-top-width")),o.borderLeft="none"==s.el.css("border-left-style")?0:parseFloat(s.el.css("border-left-width")),o.innerHeight=s.el.innerHeight(),o.innerWidth=s.el.innerWidth(),o.outerHeight=s.el.outerHeight(),o.componentsLeft=0,o.componentsRight=0,n=s.$wrapper.offset(),i={top:o.top-n.top,left:o.left-n.left},s.notify("fixPosition",i,o),o.componentsLeft>o.paddingLeft&&s.el.css("paddingLeft",o.componentsLeft+"px"),o.componentsRight>o.paddingRight&&s.el.css("paddingRight",o.componentsRight+"px"))},clearCache:function(){this.cachedResponse={},this.enrichmentCache={},this.badQueries=[]},clear:function(){var e=this,t=e.selection;e.isInitialized()&&(e.clearCache(),e.currentValue="",e.selection=null,e.hide(),e.suggestions=[],e.el.val(""),e.el.trigger("suggestions-clear"),e.notify("clear"),e.trigger("InvalidateSelection",t))},disable:function(){var e=this;e.disabled=!0,e.abortRequest(),e.visible&&e.hide()},enable:function(){this.disabled=!1},isUnavailable:function(){return this.disabled},update:function(){var e=this,t=e.el.val();e.isInitialized()&&(e.currentValue=t,e.isQueryRequestable(t)?e.updateSuggestions(t):e.hide())},setSuggestion:function(t){var n,i,s=this;e.isPlainObject(t)&&e.isPlainObject(t.data)&&(t=e.extend(!0,{},t),s.isUnavailable()&&s.initializer&&"pending"===s.initializer.state()&&(s.initializer.resolve(),s.enable()),s.bounds.own.length&&(s.checkValueBounds(t),n=s.copyDataComponents(t.data,s.bounds.all),t.data.kladr_id&&(n.kladr_id=s.getBoundedKladrId(t.data.kladr_id,s.bounds.all)),t.data=n),s.selection=t,s.suggestions=[t],i=s.getSuggestionValue(t)||"",s.currentValue=i,s.el.val(i),s.abortRequest(),s.el.trigger("suggestions-set"))},fixData:function(){var t=this,n=t.extendedCurrentValue(),i=t.el.val(),s=e.Deferred();s.done(function(e){t.selectSuggestion(e,0,i,{hasBeenEnriched:!0}),t.el.trigger("suggestions-fixdata",e)}).fail(function(){t.selection=null,t.el.trigger("suggestions-fixdata")}),t.isQueryRequestable(n)?(t.currentValue=n,t.getSuggestions(n,{count:1,from_bound:null,to_bound:null}).done(function(e){var t=e[0];t?s.resolve(t):s.reject()}).fail(function(){s.reject()})):s.reject()},extendedCurrentValue:function(){var t=this,n=t.getParentInstance(),i=n&&n.extendedCurrentValue(),s=e.trim(t.el.val());return B.compact([i,s]).join(" ")},getAjaxParams:function(t,n){var i=this,s=e.trim(i.options.token),o=e.trim(i.options.partner),a=i.options.serviceUrl,l=i.options.url,u=U[t],c=e.extend({timeout:i.options.timeout},u.defaultParams),d={};return l?a=l:(/\/$/.test(a)||(a+="/"),a+=t,u.addTypeInUrl&&(a+="/"+i.type.urlSuffix)),a=B.fixURLProtocol(a),e.support.cors?(s&&(d.Authorization="Token "+s),o&&(d["X-Partner"]=o),d["X-Version"]=r.version,c.headers||(c.headers={}),c.xhrFields||(c.xhrFields={}),e.extend(c.headers,i.options.headers,d),c.xhrFields.withCredentials=!1):(s&&(d.token=s),o&&(d.partner=o),d.version=r.version,a=B.addUrlParams(a,d)),c.url=a,e.extend(c,n)},isQueryRequestable:function(e){var t,n=this;return t=e.length>=n.options.minChars,t&&n.type.isQueryRequestable&&(t=n.type.isQueryRequestable.call(n,e)),t},constructRequestParams:function(t,n){var i=this,s=i.options,o=e.isFunction(s.params)?s.params.call(i.element,t):e.extend({},s.params);return i.type.constructRequestParams&&e.extend(o,i.type.constructRequestParams.call(i)),e.each(i.notify("requestParams"),function(t,n){e.extend(o,n)}),o[s.paramName]=t,e.isNumeric(s.count)&&s.count>0&&(o.count=s.count),e.extend(o,n)},updateSuggestions:function(e){var t=this;t.fetchPhase=t.getSuggestions(e).done(function(n){t.assignSuggestions(n,e)})},getSuggestions:function(t,n,i){var s,o=this,a=o.options,r=i&&i.noCallbacks,l=i&&i.useEnrichmentCache,u=i&&i.method||o.requestMode.method,c=o.constructRequestParams(t,n),d=e.param(c||{}),f=e.Deferred();return s=o.cachedResponse[d],s&&e.isArray(s.suggestions)?f.resolve(s.suggestions):o.isBadQuery(t)?f.reject():r||!1!==a.onSearchStart.call(o.element,c)?o.doGetSuggestions(c,u).done(function(e){o.processResponse(e)&&t==o.currentValue?(a.noCache||(l?o.enrichmentCache[t]=e.suggestions[0]:(o.enrichResponse(e,t),o.cachedResponse[d]=e,a.preventBadQueries&&0===e.suggestions.length&&o.badQueries.push(t))),f.resolve(e.suggestions)):f.reject(),r||a.onSearchComplete.call(o.element,t,e.suggestions)}).fail(function(e,n,i){f.reject(),r||"abort"===n||a.onSearchError.call(o.element,t,e,n,i)}):f.reject(),f},doGetSuggestions:function(t,n){var i=this,s=e.ajax(i.getAjaxParams(n,{data:B.serialize(t)}));return i.abortRequest(),i.currentRequest=s,i.notify("request"),s.always(function(){i.currentRequest=null,i.notify("request")}),s},isBadQuery:function(t){if(!this.options.preventBadQueries)return!1;var n=!1;return e.each(this.badQueries,function(e,i){return!(n=0===t.indexOf(i))}),n},abortRequest:function(){var e=this;e.currentRequest&&e.currentRequest.abort()},processResponse:function(t){var n,i=this;return!(!t||!e.isArray(t.suggestions))&&(i.verifySuggestionsFormat(t.suggestions),i.setUnrestrictedValues(t.suggestions),e.isFunction(i.options.onSuggestionsFetch)&&(n=i.options.onSuggestionsFetch.call(i.element,t.suggestions),e.isArray(n)&&(t.suggestions=n)),!0)},verifySuggestionsFormat:function(t){"string"==typeof t[0]&&e.each(t,function(e,n){t[e]={value:n,data:null}})},getSuggestionValue:function(t,n){var i,s=this,o=s.options.formatSelected||s.type.formatSelected,a=n&&n.hasSameValues,r=n&&n.hasBeenEnriched,l=null;return e.isFunction(o)&&(i=o.call(s,t)),"string"!=typeof i&&(i=t.value,s.type.getSuggestionValue&&null!==(l=s.type.getSuggestionValue(s,{suggestion:t,hasSameValues:a,hasBeenEnriched:r}))&&(i=l)),i},hasSameValues:function(t){var n=!1;return e.each(this.suggestions,function(e,i){if(i.value===t.value&&i!==t)return n=!0,!1}),n},assignSuggestions:function(e,t){var n=this;n.suggestions=e,n.notify("assignSuggestions",t)},shouldRestrictValues:function(){var e=this;return e.options.restrict_value&&e.constraints&&1==Object.keys(e.constraints).length},setUnrestrictedValues:function(t){var n=this,i=n.shouldRestrictValues(),s=n.getFirstConstraintLabel();e.each(t,function(e,t){t.unrestricted_value||(t.unrestricted_value=i?s+", "+t.value:t.value)})},areSuggestionsSame:function(e,t){return e&&t&&e.value===t.value&&B.areSame(e.data,t.data)},getNoSuggestionsHint:function(){var e=this;return!1!==e.options.noSuggestionsHint&&(e.options.noSuggestionsHint||e.type.noSuggestionsHint)}};var Z={setupElement:function(){this.el.attr("autocomplete","off").attr("autocorrect","off").attr("autocapitalize","off").attr("spellcheck","false").addClass("suggestions-input").css("box-sizing","border-box")},bindElementEvents:function(){var t=this;t.el.on("keydown"+w,e.proxy(t.onElementKeyDown,t)),t.el.on(["keyup"+w,"cut"+w,"paste"+w,"input"+w].join(" "),e.proxy(t.onElementKeyUp,t)),t.el.on("blur"+w,e.proxy(t.onElementBlur,t)),t.el.on("focus"+w,e.proxy(t.onElementFocus,t))},unbindElementEvents:function(){this.el.off(w)},onElementBlur:function(){var e=this;if(e.cancelBlur)return void(e.cancelBlur=!1);e.options.triggerSelectOnBlur?e.isUnavailable()||e.selectCurrentValue({noSpace:!0}).always(function(){e.hide()}):e.hide(),e.fetchPhase.abort&&e.fetchPhase.abort()},onElementFocus:function(){var t=this;t.cancelFocus||B.delay(e.proxy(t.completeOnFocus,t)),t.cancelFocus=!1},onElementKeyDown:function(e){var t=this;if(!t.isUnavailable())if(t.visible){switch(e.which){case x.ESC:t.el.val(t.currentValue),t.hide(),t.abortRequest();break;case x.TAB:if(!1===t.options.tabDisabled)return;break;case x.ENTER:t.options.triggerSelectOnEnter&&t.selectCurrentValue();break;case x.SPACE:return void(t.options.triggerSelectOnSpace&&t.isCursorAtEnd()&&(e.preventDefault(),t.selectCurrentValue({continueSelecting:!0,dontEnrich:!0}).fail(function(){t.currentValue+=" ",t.el.val(t.currentValue),t.proceedChangedValue()})));case x.UP:t.moveUp();break;case x.DOWN:t.moveDown();break;default:return}e.stopImmediatePropagation(),e.preventDefault()}else switch(e.which){case x.DOWN:t.suggest();break;case x.ENTER:t.options.triggerSelectOnEnter&&t.triggerOnSelectNothing()}},onElementKeyUp:function(e){var t=this;if(!t.isUnavailable()){switch(e.which){case x.UP:case x.DOWN:case x.ENTER:return}clearTimeout(t.onChangeTimeout),t.inputPhase.reject(),t.currentValue!==t.el.val()&&t.proceedChangedValue()}},proceedChangedValue:function(){var t=this;t.abortRequest(),t.inputPhase=e.Deferred().done(e.proxy(t.onValueChange,t)),t.options.deferRequestBy>0?t.onChangeTimeout=B.delay(function(){t.inputPhase.resolve()},t.options.deferRequestBy):t.inputPhase.resolve()},
onValueChange:function(){var e,t=this;t.selection&&(e=t.selection,t.selection=null,t.trigger("InvalidateSelection",e)),t.selectedIndex=-1,t.update(),t.notify("valueChange")},completeOnFocus:function(){var e=this;e.isUnavailable()||e.isElementFocused()&&(e.fixPosition(),e.update(),e.isMobile&&(e.setCursorAtEnd(),e.scrollToTop()))},isElementFocused:function(){return document.activeElement===this.element},isElementDisabled:function(){return Boolean(this.element.getAttribute("disabled")||this.element.getAttribute("readonly"))},isCursorAtEnd:function(){var e,t,n=this,i=n.el.val().length;try{if("number"==typeof(e=n.element.selectionStart))return e===i}catch(e){}return!document.selection||(t=document.selection.createRange(),t.moveStart("character",-i),i===t.text.length)},setCursorAtEnd:function(){var e=this.element;try{e.selectionEnd=e.selectionStart=e.value.length,e.scrollLeft=e.scrollWidth}catch(t){e.value=e.value}}};e.extend(r.prototype,Z),W.on("initialize",Z.bindElementEvents).on("dispose",Z.unbindElementEvents);var K={};l();var G={checkStatus:function(){function e(e){B.isFunction(t.options.onSearchError)&&t.options.onSearchError.call(t.element,null,s,"error",e)}var t=this,n=t.options.token&&t.options.token.trim()||"",i=t.options.type+n,s=K[i];s||(s=K[i]=T.ajax(t.getAjaxParams("status"))),s.done(function(n,i,s){if(n.search){var o=s.getResponseHeader("X-Plan");n.plan=o,T.extend(t.status,n)}else e("Service Unavailable")}).fail(function(){e(s.statusText)})}};r.resetTokens=l,T.extend(r.prototype,G),W.on("setOptions",G.checkStatus);var J,X=!0,Y={checkLocation:function(){var t=this,n=t.options.geoLocation;t.type.geoEnabled&&n&&(t.geoLocation=e.Deferred(),e.isPlainObject(n)||e.isArray(n)?t.geoLocation.resolve(n):(J||(J=e.ajax(t.getAjaxParams("detectAddressByIp"))),J.done(function(e){var n=e&&e.location&&e.location.data;n&&n.kladr_id?t.geoLocation.resolve(n):t.geoLocation.reject()}).fail(function(){t.geoLocation.reject()})))},getGeoLocation:function(){return this.geoLocation},constructParams:function(){var t=this,n={};return t.geoLocation&&e.isFunction(t.geoLocation.promise)&&"resolved"==t.geoLocation.state()&&t.geoLocation.done(function(t){n.locations_boost=e.makeArray(t)}),n}};"GET"!=B.getDefaultType()&&(e.extend(L,{geoLocation:X}),e.extend(r,{resetLocation:u}),e.extend(r.prototype,{getGeoLocation:Y.getGeoLocation}),W.on("setOptions",Y.checkLocation).on("requestParams",Y.constructParams));var ee={enrichSuggestion:function(t,n){var i=this,s=e.Deferred();if(!i.options.enrichmentEnabled||!i.type.enrichmentEnabled||!i.requestMode.enrichmentEnabled||n&&n.dontEnrich)return s.resolve(t);if(t.data&&null!=t.data.qc)return s.resolve(t);i.disableDropdown();var o=i.type.getEnrichmentQuery(t),a=i.type.enrichmentParams,r={noCallbacks:!0,useEnrichmentCache:!0,method:i.type.enrichmentMethod};return i.currentValue=o,i.enrichPhase=i.getSuggestions(o,a,r).always(function(){i.enableDropdown()}).done(function(e){var n=e&&e[0];s.resolve(n||t,!!n)}).fail(function(){s.resolve(t)}),s},enrichResponse:function(t,n){var i=this,s=i.enrichmentCache[n];s&&e.each(t.suggestions,function(e,i){if(i.value===n)return t.suggestions[e]=s,!1})}};e.extend(r.prototype,ee);var te={width:"auto",floating:!1},ne={createContainer:function(){var t=this,n="."+t.classes.suggestion,i=t.options,s=e("<div/>").addClass(i.containerClass).css({position:"absolute",display:"none"});t.$container=s,s.on("click"+w,n,e.proxy(t.onSuggestionClick,t))},getContainer:function(){return this.$container.get(0)},removeContainer:function(){var e=this;e.options.floating&&e.$container.remove()},setContainerOptions:function(){var t=this;t.$container.off("mousedown.suggestions"),t.options.floating&&t.$container.on("mousedown.suggestions",e.proxy(t.onMousedown,t))},onSuggestionClick:function(t){var n,i=this,s=e(t.target);if(!i.dropdownDisabled){for(i.cancelFocus=!0,i.el.focus();s.length&&!(n=s.attr("data-index"));)s=s.closest("."+i.classes.suggestion);n&&!isNaN(n)&&i.select(+n)}},setDropdownPosition:function(e,t){var n,i=this,s=i.$viewport.scrollLeft();i.isMobile?(n=i.options.floating?{left:s+"px",top:t.top+t.outerHeight+"px"}:{left:e.left-t.left+s+"px",top:e.top+t.outerHeight+"px"},n.width=i.$viewport.width()+"px"):(n=i.options.floating?{left:t.left+"px",top:t.top+t.borderTop+t.innerHeight+"px"}:{left:e.left+"px",top:e.top+t.borderTop+t.innerHeight+"px"},B.delay(function(){var e=i.options.width;"auto"===e&&(e=i.el.outerWidth()),i.$container.outerWidth(e)})),i.$container.toggleClass(i.classes.mobile,i.isMobile).css(n),i.containerItemsPadding=t.left+t.borderLeft+t.paddingLeft-s},setItemsPositions:function(){var e=this;e.getSuggestionsItems().css("paddingLeft",e.isMobile?e.containerItemsPadding+"px":"")},getSuggestionsItems:function(){return this.$container.children("."+this.classes.suggestion)},toggleDropdownEnabling:function(e){this.dropdownDisabled=!e,this.$container.attr("disabled",!e)},disableDropdown:function(){this.toggleDropdownEnabling(!1)},enableDropdown:function(){this.toggleDropdownEnabling(!0)},hasSuggestionsToChoose:function(){var t=this;return t.suggestions.length>1||1===t.suggestions.length&&(!t.selection||e.trim(t.suggestions[0].value)!==e.trim(t.selection.value))},suggest:function(){var t=this,n=t.options,i=[];if(t.requestMode.userSelect){if(t.hasSuggestionsToChoose())!t.isMobile&&n.hint&&t.suggestions.length&&i.push('<div class="'+t.classes.hint+'">'+n.hint+"</div>"),t.selectedIndex=-1,t.suggestions.forEach(function(e,n){e==t.selection&&(t.selectedIndex=n),t.buildSuggestionHtml(e,n,i)});else{if(t.suggestions.length)return void t.hide();var s=t.getNoSuggestionsHint();if(!s)return void t.hide();i.push('<div class="'+t.classes.hint+'">'+s+"</div>")}i.push('<div class="'+S.promo+'"></div>'),i.push("</div>"),t.$container.html(i.join("")),n.autoSelectFirst&&-1===t.selectedIndex&&(t.selectedIndex=0),-1!==t.selectedIndex&&t.getSuggestionsItems().eq(t.selectedIndex).addClass(t.classes.selected),e.isFunction(n.beforeRender)&&n.beforeRender.call(t.element,t.$container),t.$container.show(),t.visible=!0,t.fixPosition(),t.setItemsPositions()}},buildSuggestionHtml:function(e,t,n){n.push('<div class="'+this.classes.suggestion+'" data-index="'+t+'">');var i=this.options.formatResult||this.type.formatResult||this.formatResult;n.push(i.call(this,e.value,this.currentValue,e,{unformattableTokens:this.type.unformattableTokens}));var s=this.makeSuggestionLabel(this.suggestions,e);s&&n.push('<span class="'+this.classes.subtext_label+'">'+B.escapeHtml(s)+"</span>"),n.push("</div>")},wrapFormattedValue:function(e,t){var n=this,i=B.getDeepValue(t.data,"state.status");return'<span class="'+n.classes.value+'"'+(i?' data-suggestion-status="'+i+'"':"")+">"+e+"</span>"},formatResult:function(e,t,n,i){var s=this;return e=s.highlightMatches(e,t,n,i),s.wrapFormattedValue(e,n)},highlightMatches:function(t,n,i,s){var o,a,r,l,u,f,p,h=this,g=[],m=s&&s.unformattableTokens,y=s&&s.maxLength,v=B.reWordExtractor();if(!t)return"";for(o=P.tokenize(n,m),a=e.map(o,function(e){return new RegExp("^((.*)([\\-\\+\\\\\\?!@#$%^&]+))?("+B.escapeRegExChars(e)+")([^\\-\\+\\\\\\?!@#$%^&]*[\\-\\+\\\\\\?!@#$%^&]*)","i")});(r=v.exec(t))&&r[0];)l=r[1],g.push({text:l,hasUpperCase:l.toLowerCase()!==l,formatted:B.formatToken(l),matchable:!0}),r[2]&&g.push({text:r[2]});for(u=0;u<g.length;u++)f=g[u],!f.matchable||f.matched||-1!==e.inArray(f.formatted,m)&&!f.hasUpperCase||e.each(a,function(e,t){var n,i=t.exec(f.formatted),s=u+1;if(i)return i={before:i[1]||"",beforeText:i[2]||"",beforeDelimiter:i[3]||"",text:i[4]||"",after:i[5]||""},i.before&&(g.splice(u,0,{text:f.text.substr(0,i.beforeText.length),formatted:i.beforeText,matchable:!0},{text:i.beforeDelimiter}),s+=2,n=i.before.length,f.text=f.text.substr(n),f.formatted=f.formatted.substr(n),u--),n=i.text.length+i.after.length,f.formatted.length>n&&(g.splice(s,0,{text:f.text.substr(n),formatted:f.formatted.substr(n),matchable:!0}),f.text=f.text.substr(0,n),f.formatted=f.formatted.substr(0,n)),i.after&&(n=i.text.length,g.splice(s,0,{text:f.text.substr(n),formatted:f.formatted.substr(n)}),f.text=f.text.substr(0,n),f.formatted=f.formatted.substr(0,n)),f.matched=!0,!1});if(y){for(u=0;u<g.length&&y>=0;u++)f=g[u],(y-=f.text.length)<0&&(f.text=f.text.substr(0,f.text.length+y)+"...");g.length=u}return p=c(g),d(p,h.classes.nowrap)},makeSuggestionLabel:function(t,n){var i,s,o=this,a=o.type.fieldNames,r={},l=B.reWordExtractor(),u=[];if(a&&f(t,n)&&n.data&&(e.each(a,function(e){var t=n.data[e];t&&(r[e]=B.formatToken(t))}),!e.isEmptyObject(r))){for(;(i=l.exec(B.formatToken(n.value)))&&(s=i[1]);)e.each(r,function(e,t){if(t==s)return u.push(a[e]),delete r[e],!1});if(u.length)return u.join(", ")}},hide:function(){var e=this;e.visible=!1,e.selectedIndex=-1,e.$container.hide().empty()},activate:function(e){var t,n,i=this,s=i.classes.selected;return!i.dropdownDisabled&&(n=i.getSuggestionsItems(),n.removeClass(s),i.selectedIndex=e,-1!==i.selectedIndex&&n.length>i.selectedIndex)?(t=n.eq(i.selectedIndex),t.addClass(s),t):null},deactivate:function(e){var t=this;t.dropdownDisabled||(t.selectedIndex=-1,t.getSuggestionsItems().removeClass(t.classes.selected),e&&t.el.val(t.currentValue))},moveUp:function(){var e=this;if(!e.dropdownDisabled)return-1===e.selectedIndex?void(e.suggestions.length&&e.adjustScroll(e.suggestions.length-1)):0===e.selectedIndex?void e.deactivate(!0):void e.adjustScroll(e.selectedIndex-1)},moveDown:function(){var e=this;if(!e.dropdownDisabled)return e.selectedIndex===e.suggestions.length-1?void e.deactivate(!0):void e.adjustScroll(e.selectedIndex+1)},adjustScroll:function(e){var t,n,i,s=this,o=s.activate(e),a=s.$container.scrollTop();o&&o.length&&(t=o.position().top,t<0?s.$container.scrollTop(a+t):(n=t+o.outerHeight(),i=s.$container.innerHeight(),n>i&&s.$container.scrollTop(a-i+n)),s.el.val(s.suggestions[e].value))}};e.extend(L,te),e.extend(r.prototype,ne),W.on("initialize",ne.createContainer).on("dispose",ne.removeContainer).on("setOptions",ne.setContainerOptions).on("fixPosition",ne.setDropdownPosition).on("fixPosition",ne.setItemsPositions).on("assignSuggestions",ne.suggest);var ie={addon:null},se={NONE:"none",SPINNER:"spinner",CLEAR:"clear"},oe=function(e){var t=T.select('<span class="suggestions-addon"/>');this.owner=e,this.$el=t,this.type=se.NONE,this.visible=!1,this.initialPadding=null,t.on("click",T.proxy(this,"onClick"))};oe.prototype={checkType:function(){var e=this.owner.options.addon,t=!1;v.each(se,function(n,i){if(t=n==e)return!1}),t||(e=this.owner.isMobile?se.CLEAR:se.SPINNER),e!=this.type&&(this.type=e,this.$el.attr("data-addon-type",e),this.toggle(!0))},isEnabled:function(){return!this.owner.isElementDisabled()},toggle:function(e){var t;switch(this.type){case se.CLEAR:t=!!this.owner.currentValue;break;case se.SPINNER:t=!!this.owner.currentRequest;break;default:t=!1}this.isEnabled()||(t=!1),t!=this.visible&&(this.visible=t,t?this.show(e):this.hide(e))},show:function(e){var t=this,n={opacity:1};e?(this.$el.show().css(n),this.showBackground(!0)):this.$el.stop(!0,!0).delay(50).queue(function(){t.$el.show(),t.showBackground(),t.$el.dequeue()}).animate(n,"fast")},hide:function(e){var t=this,n={opacity:0};e&&this.$el.hide().css(n),this.$el.stop(!0).animate(n,{duration:"fast",complete:function(){t.$el.hide(),t.hideBackground()}})},fixPosition:function(e,t){var n=t.innerHeight;this.checkType(),this.$el.css({left:e.left+t.borderLeft+t.innerWidth-n+"px",top:e.top+t.borderTop+"px",height:n,width:n}),this.initialPadding=t.paddingRight,this.width=n,this.visible&&(t.componentsRight+=n)},showBackground:function(e){var t=this.owner.el,n={paddingRight:this.width};this.width>this.initialPadding&&(this.stopBackground(),e?t.css(n):t.animate(n,{duration:"fast",queue:"addon"}).dequeue("addon"))},hideBackground:function(e){var t=this.owner.el,n={paddingRight:this.initialPadding};this.width>this.initialPadding&&(this.stopBackground(!0),e?t.css(n):t.delay(1e3,"addon").animate(n,{duration:"fast",queue:"addon"}).dequeue("addon"))},stopBackground:function(e){this.owner.el.stop("addon",!0,e)},onClick:function(e){this.isEnabled()&&this.type==se.CLEAR&&this.owner.clear()}};var ae={createAddon:function(){var e=new oe(this);this.$wrapper.append(e.$el),this.addon=e},fixAddonPosition:function(e,t){this.addon.fixPosition(e,t)},checkAddonType:function(){this.addon.checkType()},checkAddonVisibility:function(){this.addon.toggle()},stopBackground:function(){this.addon.stopBackground()}};T.extend(L,ie),W.on("initialize",ae.createAddon).on("setOptions",ae.checkAddonType).on("fixPosition",ae.fixAddonPosition).on("clear",ae.checkAddonVisibility).on("valueChange",ae.checkAddonVisibility).on("request",ae.checkAddonVisibility).on("resetPosition",ae.stopBackground);var re={constraints:null,restrict_value:!1},le=["region_fias_id","area_fias_id","city_fias_id","city_district_fias_id","settlement_fias_id","street_fias_id"],ue=function(e,t){var n,i,s=this,o={};s.instance=t,s.fields={},s.specificity=-1,y.isPlainObject(e)&&t.type.dataComponents&&v.each(t.type.dataComponents,function(t,n){var i=t.id;t.forLocations&&e[i]&&(s.fields[i]=e[i],s.specificity=n)}),n=Object.keys(s.fields),i=v.intersect(n,le),i.length?(v.each(i,function(e,t){o[e]=s.fields[e]}),s.fields=o,s.specificity=s.getFiasSpecificity(i)):s.fields.kladr_id&&(s.fields={kladr_id:s.fields.kladr_id},s.significantKladr=h(s.fields.kladr_id),s.specificity=s.getKladrSpecificity(s.significantKladr))};T.extend(ue.prototype,{getLabel:function(){return this.instance.type.composeValue(this.fields,{saveCityDistrict:!0})},getFields:function(){return this.fields},isValid:function(){return!y.isEmptyObject(this.fields)},getKladrSpecificity:function(e){var t=-1,n=e.length;return v.each(this.instance.type.dataComponents,function(e,i){e.kladrFormat&&n===e.kladrFormat.digits&&(t=i)}),t},getFiasSpecificity:function(e){var t=-1;return v.each(this.instance.type.dataComponents,function(n,i){n.fiasType&&e.indexOf(n.fiasType)>-1&&t<i&&(t=i)}),t},containsData:function(e){var t=!0;return this.fields.kladr_id?!!e.kladr_id&&0===e.kladr_id.indexOf(this.significantKladr):(v.each(this.fields,function(n,i){return t=!!e[i]&&e[i].toLowerCase()===n.toLowerCase()}),t)}}),r.ConstraintLocation=ue;var ce=function(e,t){this.id=j("c"),this.deletable=!!e.deletable,this.instance=t;var n=v.makeArray(e&&(e.locations||e.restrictions));this.locations=n.map(function(e){return new ue(e,t)}),this.locations=this.locations.filter(function(e){return e.isValid()}),this.label=e.label,null==this.label&&t.type.composeValue&&(this.label=this.locations.map(function(e){return e.getLabel()}).join(", ")),this.label&&this.isValid()&&(this.$el=T.select(document.createElement("li")).append(T.select(document.createElement("span")).text(this.label)).attr("data-constraint-id",this.id),this.deletable&&this.$el.append(T.select(document.createElement("span")).addClass(t.classes.removeConstraint)))};T.extend(ce.prototype,{isValid:function(){return this.locations.length>0},getFields:function(){return this.locations.map(function(e){return e.getFields()})}});var de={createConstraints:function(){var e=this;e.constraints={},e.$constraints=T.select('<ul class="suggestions-constraints"/>'),e.$wrapper.append(e.$constraints),e.$constraints.on("click","."+e.classes.removeConstraint,T.proxy(e.onConstraintRemoveClick,e))},setConstraintsPosition:function(e,t){var n=this;n.$constraints.css({left:e.left+t.borderLeft+t.paddingLeft+"px",top:e.top+t.borderTop+Math.round((t.innerHeight-n.$constraints.height())/2)+"px"}),t.componentsLeft+=n.$constraints.outerWidth(!0)+t.paddingLeft},onConstraintRemoveClick:function(e){var t=this,n=T.select(e.target).closest("li"),i=n.attr("data-constraint-id");delete t.constraints[i],t.update(),n.fadeOut("fast",function(){t.removeConstraint(i)})},setupConstraints:function(){var e,t=this,n=t.options.constraints;if(!n)return void t.unbindFromParent();T.isJqObject(n)||"string"==typeof n||"number"==typeof n.nodeType?(e=T.select(n),e.is(t.constraints)||(t.unbindFromParent(),e.is(t.el)||(t.constraints=e,t.bindToParent()))):(t._constraintsUpdating=!0,v.each(t.constraints,function(e,n){t.removeConstraint(n)}),v.each(v.makeArray(n),function(e,n){t.addConstraint(e)}),t._constraintsUpdating=!1,t.fixPosition())},filteredLocation:function(e){var t=[],n={};if(v.each(this.type.dataComponents,function(){this.forLocations&&t.push(this.id)}),y.isPlainObject(e)&&v.each(e,function(e,i){e&&t.indexOf(i)>=0&&(n[i]=e)}),!y.isEmptyObject(n))return n.kladr_id?{kladr_id:n.kladr_id}:n},addConstraint:function(e){var t=this;e=new ce(e,t),e.isValid()&&(t.constraints[e.id]=e,e.$el&&(t.$constraints.append(e.$el),t._constraintsUpdating||t.fixPosition()))},removeConstraint:function(e){var t=this;delete t.constraints[e],t.$constraints.children('[data-constraint-id="'+e+'"]').remove(),t._constraintsUpdating||t.fixPosition()},constructConstraintsParams:function(){for(var e,t,n=this,i=[],s=n.constraints,o={};T.isJqObject(s)&&(e=s.suggestions())&&!(t=_.getDeepValue(e,"selection.data"));)s=e.constraints;return T.isJqObject(s)?(t=new ue(t,e).getFields())&&(n.bounds.own.indexOf("city")>-1&&delete t.city_fias_id,o.locations=[t],o.restrict_value=!0):s&&(v.each(s,function(e,t){i=i.concat(e.getFields())}),i.length&&(o.locations=i,o.restrict_value=n.options.restrict_value)),o},getFirstConstraintLabel:function(){var e=this,t=y.isPlainObject(e.constraints)&&Object.keys(e.constraints)[0];return t?e.constraints[t].label:""},bindToParent:function(){var e=this;e.constraints.on(["suggestions-select."+e.uniqueId,"suggestions-invalidateselection."+e.uniqueId,"suggestions-clear."+e.uniqueId].join(" "),T.proxy(e.onParentSelectionChanged,e)).on("suggestions-dispose."+e.uniqueId,T.proxy(e.onParentDispose,e))},unbindFromParent:function(){var e=this,t=e.constraints;T.isJqObject(t)&&t.off("."+e.uniqueId)},onParentSelectionChanged:function(e,t,n){("suggestions-select"!==e.type||n)&&this.clear()},onParentDispose:function(e){this.unbindFromParent()},getParentInstance:function(){return T.isJqObject(this.constraints)&&this.constraints.suggestions()},shareWithParent:function(e){var t=this.getParentInstance();t&&t.type===this.type&&!p(e,t)&&(t.shareWithParent(e),t.setSuggestion(e))},getUnrestrictedData:function(e){var t=this,n=[],i={},s=-1;return v.each(t.constraints,function(t,n){v.each(t.locations,function(t,n){t.containsData(e)&&t.specificity>s&&(s=t.specificity)})}),s>=0?(e.region_kladr_id&&e.region_kladr_id===e.city_kladr_id&&n.push.apply(n,t.type.dataComponentsById.city.fields),v.each(t.type.dataComponents.slice(0,s+1),function(e,t){n.push.apply(n,e.fields)}),v.each(e,function(e,t){-1===n.indexOf(t)&&(i[t]=e)})):i=e,i}};T.extend(L,re),T.extend(r.prototype,de),"GET"!=V.getDefaultType()&&W.on("initialize",de.createConstraints).on("setOptions",de.setupConstraints).on("fixPosition",de.setConstraintsPosition).on("requestParams",de.constructConstraintsParams).on("dispose",de.unbindFromParent);var fe={proceedQuery:function(e){var t=this;e.length>=t.options.minChars?t.updateSuggestions(e):t.hide()},selectCurrentValue:function(e){var t=this,n=T.Deferred();return t.inputPhase.resolve(),t.fetchPhase.done(function(){var i;t.selection&&!t.visible?n.reject():(i=t.findSuggestionIndex(),t.select(i,e),-1===i?n.reject():n.resolve(i))}).fail(function(){n.reject()}),n},selectFoundSuggestion:function(){var e=this;e.requestMode.userSelect||e.select(0)},findSuggestionIndex:function(){var e,t=this,n=t.selectedIndex;return-1===n&&(e=t.el.val().trim())&&t.type.matchers.some(function(i){return-1!==(n=i(e,t.suggestions))}),n},select:function(e,t){var n,i=this,s=i.suggestions[e],o=t&&t.continueSelecting,a=i.currentValue;if(!i.triggering.Select){if(!s)return o||i.selection||i.triggerOnSelectNothing(),void i.onSelectComplete(o);n=i.hasSameValues(s),i.enrichSuggestion(s,t).done(function(s,o){var r=T.extend({hasBeenEnriched:o,hasSameValues:n},t);i.selectSuggestion(s,e,a,r)})}},selectSuggestion:function(e,t,n,i){var s=this,o=i.continueSelecting,a=!s.type.isDataComplete||s.type.isDataComplete.call(s,e),r=s.selection;s.triggering.Select||(s.type.alwaysContinueSelecting&&(o=!0),a&&(o=!1),i.hasBeenEnriched&&s.suggestions[t]&&(s.suggestions[t].data=e.data),s.requestMode.updateValue&&(s.checkValueBounds(e),s.currentValue=s.getSuggestionValue(e,i),!s.currentValue||i.noSpace||a||(s.currentValue+=" "),s.el.val(s.currentValue)),s.currentValue?(s.selection=e,s.areSuggestionsSame(e,r)||s.trigger("Select",e,s.currentValue!=n),s.requestMode.userSelect&&s.onSelectComplete(o)):(s.selection=null,s.triggerOnSelectNothing()),s.shareWithParent(e))},onSelectComplete:function(e){var t=this;e?(t.selectedIndex=-1,t.updateSuggestions(t.currentValue)):t.hide()},triggerOnSelectNothing:function(){var e=this;e.triggering.SelectNothing||e.trigger("SelectNothing",e.currentValue)},trigger:function(e){var t=this,n=B.slice(arguments,1),i=t.options["on"+e];t.triggering[e]=!0,B.isFunction(i)&&i.apply(t.element,n),t.el.trigger.call(t.el,"suggestions-"+e.toLowerCase(),n),t.triggering[e]=!1}};T.extend(r.prototype,fe),W.on("assignSuggestions",fe.selectFoundSuggestion);var pe={bounds:null},he={setupBounds:function(){this.bounds={from:null,to:null}},setBoundsOptions:function(){var t,n,i=this,s=[],o=e.trim(i.options.bounds).split("-"),a=o[0],r=o[o.length-1],l=[],u=[];i.type.dataComponents&&e.each(i.type.dataComponents,function(){this.forBounds&&s.push(this.id)}),-1===e.inArray(a,s)&&(a=null),n=e.inArray(r,s),-1!==n&&n!==s.length-1||(r=null),(a||r)&&(t=!a,e.each(s,function(e,n){if(n==a&&(t=!0),u.push(n),t&&l.push(n),n==r)return!1})),i.bounds.from=a,i.bounds.to=r,i.bounds.all=u,i.bounds.own=l},constructBoundsParams:function(){var e=this,t={};return e.bounds.from&&(t.from_bound={value:e.bounds.from}),e.bounds.to&&(t.to_bound={value:e.bounds.to}),t},checkValueBounds:function(e){var t,n=this;if(n.bounds.own.length&&n.type.composeValue){var i=n.bounds.own.slice(0);1===i.length&&"city_district"===i[0]&&i.push("city_district_fias_id"),t=n.copyDataComponents(e.data,i),e.value=n.type.composeValue(t)}},copyDataComponents:function(t,n){var i={},s=this.type.dataComponentsById;return s&&e.each(n,function(n,o){e.each(s[o].fields,function(e,n){null!=t[n]&&(i[n]=t[n])})}),i},getBoundedKladrId:function(t,n){var i,s=n[n.length-1];return e.each(this.type.dataComponents,function(e,t){if(t.id===s)return i=t.kladrFormat,!1}),t.substr(0,i.digits)+new Array((i.zeros||0)+1).join("0")}};e.extend(L,pe),e.extend(r.prototype,he),W.on("initialize",he.setupBounds).on("setOptions",he.setBoundsOptions).on("requestParams",he.constructBoundsParams);var ge={selectByClass:function(e,t){var n="."+e;return t?t.querySelector(n):document.querySelector(n)},addClass:function(e,t){var n=e.className.split(" ");-1===n.indexOf(t)&&n.push(t),e.className=n.join(" ")},setStyle:function(e,t,n){e.style[t]=n},listenTo:function(e,t,n,i){e.addEventListener(t,i,!1),n&&(eventsByNamespace[n]||(eventsByNamespace[n]=[]),eventsByNamespace[n].push({eventName:t,element:e,callback:i}))},stopListeningNamespace:function(e){var t=eventsByNamespace[e];t&&t.forEach(function(e){e.element.removeEventListener(e.eventName,e.callback,!1)})}};g.prototype.show=function(){"FREE"===this.plan&&this.element&&(this.setStyles(),this.setHtml())},g.prototype.setStyles=function(){this.element.style.display="block",this.isMobile||this.element.classList.add(S.promo_desktop)},g.prototype.setHtml=function(){this.element.innerHTML='<a target="_blank" href="https://dadata.ru/suggestions"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 167.55 38.92"><defs><style>.cls-1{fill:#cdcccc;}.cls-2{fill:#ef4741;}.cls-3{fill:#fff;}</style></defs><title>dadata-logo</title><path class="cls-1" d="M192.61,153.07H196v-3.15h-3.39Zm9.55-14.46v-2.45h-3v16.91h3.14V142.2a4.39,4.39,0,0,1,4.23-3.7h1.75v-2.69h-1.54C203.75,135.81,202.35,137.76,202.16,138.61Zm20.2-2.45v11.3a5,5,0,0,1-4.65,3.66,7.19,7.19,0,0,1-2-.23,2,2,0,0,1-1.12-.6,2.38,2.38,0,0,1-.44-.86,4.38,4.38,0,0,1-.1-1V136.16h-3.14v12.4a4.83,4.83,0,0,0,1.26,3.65q1.26,1.21,4.61,1.21c3.38,0,4.62-.91,5.56-2.34v2h3.14V136.16Z" transform="translate(-57.96 -122.27)"/><rect class="cls-2" width="131.91" height="38.92" rx="3" ry="3"/><path class="cls-3" d="M119.34,130.39h-9.18v22.68h10.23c3.84,0,10.18-.35,10.18-6.88v-8.91C130.56,130.74,123.18,130.39,119.34,130.39Zm5.77,15.2c0,3.27-2.38,3.6-5.09,3.6h-4.41V134.27H119c2.71,0,6.14.33,6.14,3.6Zm-48-15.2H68v22.68H78.18c3.84,0,10.18-.35,10.18-6.88v-8.91C88.36,130.74,81,130.39,77.14,130.39Zm5.77,15.2c0,3.27-2.38,3.6-5.09,3.6H73.41V134.27h3.36c2.71,0,6.14.33,6.14,3.6Zm74-14.32h-5.1V148a6.28,6.28,0,0,0,.4,2.36,4,4,0,0,0,1,1.54,4.56,4.56,0,0,0,1.57.88,8.16,8.16,0,0,0,1.85.42q.89.08,2.08.09a24.23,24.23,0,0,0,2.83-.17v-2.87h-1.82a3.08,3.08,0,0,1-2.31-.61,3.79,3.79,0,0,1-.52-2.36V139h4.65v-3.14h-4.65Zm21,5.68q-1.82-1.14-6.5-1.13h-5.92v.25l.73,2.9h5.19a5,5,0,0,1,2.5.5,2.37,2.37,0,0,1,.72,2v1.15H168.9q-3,0-4.12,1.17T163.62,148c0,2.21.37,3.14,1.12,3.84s2.2,1.22,4.48,1.22h7.06c1.76,0,3.45-.83,3.45-2.82v-8.81Q179.73,138.08,177.91,136.94Zm-3.29,13.3h-3.35a4.27,4.27,0,0,1-2.22-.35q-.44-.35-.44-2t.42-2.06a3.55,3.55,0,0,1,2.1-.38h3.49Zm-27.5-13.3q-1.82-1.14-6.5-1.13h-5.92v.25l.73,2.9h5.19a5,5,0,0,1,2.5.5,2.38,2.38,0,0,1,.72,2v1.15h-5.73q-3,0-4.12,1.17T132.84,148c0,2.21.37,3.14,1.12,3.84s2.2,1.22,4.48,1.22h7.06c1.77,0,3.45-.83,3.45-2.82v-8.81Q148.94,138.08,147.13,136.94Zm-3.28,13.3h-3.35a4.27,4.27,0,0,1-2.22-.35q-.44-.35-.44-2t.42-2.06a3.55,3.55,0,0,1,2.1-.38h3.49Zm-38.92-13.3q-1.82-1.14-6.5-1.13H92.5v.25l.73,2.9h5.19a5,5,0,0,1,2.5.5,2.38,2.38,0,0,1,.72,2v1.15H95.91q-3,0-4.12,1.17T90.63,148c0,2.21.37,3.14,1.12,3.84s2.2,1.22,4.48,1.22h7.06c1.77,0,3.45-.83,3.45-2.82v-8.81Q106.74,138.08,104.92,136.94Zm-3.28,13.3H98.29a4.27,4.27,0,0,1-2.22-.35q-.44-.35-.44-2t.42-2.06a3.55,3.55,0,0,1,2.1-.38h3.49Z" transform="translate(-57.96 -122.27)"/></svg></a>'},W.on("assignSuggestions",m),r.defaultOptions=L,r.version="18.10.1",e.Suggestions=r,e.fn.suggestions=function(t,n){return 0===arguments.length?this.first().data("suggestions"):this.each(function(){var i=e(this),s=i.data("suggestions");"string"==typeof t?s&&"function"==typeof s[t]&&s[t](n):(s&&s.dispose&&s.dispose(),s=new r(this,t),i.data("suggestions",s))})}});
/*!
 * perfect-scrollbar v1.4.0
 * (c) 2018 Hyunje Jun
 * @license MIT
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.PerfectScrollbar = factory());
}(this, (function () { 'use strict';

function get(element) {
  return getComputedStyle(element);
}

function set(element, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === 'number') {
      val = val + "px";
    }
    element.style[key] = val;
  }
  return element;
}

function div(className) {
  var div = document.createElement('div');
  div.className = className;
  return div;
}

var elMatches =
  typeof Element !== 'undefined' &&
  (Element.prototype.matches ||
    Element.prototype.webkitMatchesSelector ||
    Element.prototype.mozMatchesSelector ||
    Element.prototype.msMatchesSelector);

function matches(element, query) {
  if (!elMatches) {
    throw new Error('No element matching method supported');
  }

  return elMatches.call(element, query);
}

function remove(element) {
  if (element.remove) {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
}

function queryChildren(element, selector) {
  return Array.prototype.filter.call(element.children, function (child) { return matches(child, selector); }
  );
}

var cls = {
  main: 'ps',
  element: {
    thumb: function (x) { return ("ps__thumb-" + x); },
    rail: function (x) { return ("ps__rail-" + x); },
    consuming: 'ps__child--consume',
  },
  state: {
    focus: 'ps--focus',
    clicking: 'ps--clicking',
    active: function (x) { return ("ps--active-" + x); },
    scrolling: function (x) { return ("ps--scrolling-" + x); },
  },
};

/*
 * Helper methods
 */
var scrollingClassTimeout = { x: null, y: null };

function addScrollingClass(i, x) {
  var classList = i.element.classList;
  var className = cls.state.scrolling(x);

  if (classList.contains(className)) {
    clearTimeout(scrollingClassTimeout[x]);
  } else {
    classList.add(className);
  }
}

function removeScrollingClass(i, x) {
  scrollingClassTimeout[x] = setTimeout(
    function () { return i.isAlive && i.element.classList.remove(cls.state.scrolling(x)); },
    i.settings.scrollingThreshold
  );
}

function setScrollingClassInstantly(i, x) {
  addScrollingClass(i, x);
  removeScrollingClass(i, x);
}

var EventElement = function EventElement(element) {
  this.element = element;
  this.handlers = {};
};

var prototypeAccessors = { isEmpty: { configurable: true } };

EventElement.prototype.bind = function bind (eventName, handler) {
  if (typeof this.handlers[eventName] === 'undefined') {
    this.handlers[eventName] = [];
  }
  this.handlers[eventName].push(handler);
  this.element.addEventListener(eventName, handler, false);
};

EventElement.prototype.unbind = function unbind (eventName, target) {
    var this$1 = this;

  this.handlers[eventName] = this.handlers[eventName].filter(function (handler) {
    if (target && handler !== target) {
      return true;
    }
    this$1.element.removeEventListener(eventName, handler, false);
    return false;
  });
};

EventElement.prototype.unbindAll = function unbindAll () {
    var this$1 = this;

  for (var name in this$1.handlers) {
    this$1.unbind(name);
  }
};

prototypeAccessors.isEmpty.get = function () {
    var this$1 = this;

  return Object.keys(this.handlers).every(
    function (key) { return this$1.handlers[key].length === 0; }
  );
};

Object.defineProperties( EventElement.prototype, prototypeAccessors );

var EventManager = function EventManager() {
  this.eventElements = [];
};

EventManager.prototype.eventElement = function eventElement (element) {
  var ee = this.eventElements.filter(function (ee) { return ee.element === element; })[0];
  if (!ee) {
    ee = new EventElement(element);
    this.eventElements.push(ee);
  }
  return ee;
};

EventManager.prototype.bind = function bind (element, eventName, handler) {
  this.eventElement(element).bind(eventName, handler);
};

EventManager.prototype.unbind = function unbind (element, eventName, handler) {
  var ee = this.eventElement(element);
  ee.unbind(eventName, handler);

  if (ee.isEmpty) {
    // remove
    this.eventElements.splice(this.eventElements.indexOf(ee), 1);
  }
};

EventManager.prototype.unbindAll = function unbindAll () {
  this.eventElements.forEach(function (e) { return e.unbindAll(); });
  this.eventElements = [];
};

EventManager.prototype.once = function once (element, eventName, handler) {
  var ee = this.eventElement(element);
  var onceHandler = function (evt) {
    ee.unbind(eventName, onceHandler);
    handler(evt);
  };
  ee.bind(eventName, onceHandler);
};

function createEvent(name) {
  if (typeof window.CustomEvent === 'function') {
    return new CustomEvent(name);
  } else {
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(name, false, false, undefined);
    return evt;
  }
}

var processScrollDiff = function(
  i,
  axis,
  diff,
  useScrollingClass,
  forceFireReachEvent
) {
  if ( useScrollingClass === void 0 ) useScrollingClass = true;
  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;

  var fields;
  if (axis === 'top') {
    fields = [
      'contentHeight',
      'containerHeight',
      'scrollTop',
      'y',
      'up',
      'down' ];
  } else if (axis === 'left') {
    fields = [
      'contentWidth',
      'containerWidth',
      'scrollLeft',
      'x',
      'left',
      'right' ];
  } else {
    throw new Error('A proper axis should be provided');
  }

  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);
};

function processScrollDiff$1(
  i,
  diff,
  ref,
  useScrollingClass,
  forceFireReachEvent
) {
  var contentHeight = ref[0];
  var containerHeight = ref[1];
  var scrollTop = ref[2];
  var y = ref[3];
  var up = ref[4];
  var down = ref[5];
  if ( useScrollingClass === void 0 ) useScrollingClass = true;
  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;

  var element = i.element;

  // reset reach
  i.reach[y] = null;

  // 1 for subpixel rounding
  if (element[scrollTop] < 1) {
    i.reach[y] = 'start';
  }

  // 1 for subpixel rounding
  if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
    i.reach[y] = 'end';
  }

  if (diff) {
    element.dispatchEvent(createEvent(("ps-scroll-" + y)));

    if (diff < 0) {
      element.dispatchEvent(createEvent(("ps-scroll-" + up)));
    } else if (diff > 0) {
      element.dispatchEvent(createEvent(("ps-scroll-" + down)));
    }

    if (useScrollingClass) {
      setScrollingClassInstantly(i, y);
    }
  }

  if (i.reach[y] && (diff || forceFireReachEvent)) {
    element.dispatchEvent(createEvent(("ps-" + y + "-reach-" + (i.reach[y]))));
  }
}

function toInt(x) {
  return parseInt(x, 10) || 0;
}

function isEditable(el) {
  return (
    matches(el, 'input,[contenteditable]') ||
    matches(el, 'select,[contenteditable]') ||
    matches(el, 'textarea,[contenteditable]') ||
    matches(el, 'button,[contenteditable]')
  );
}

function outerWidth(element) {
  var styles = get(element);
  return (
    toInt(styles.width) +
    toInt(styles.paddingLeft) +
    toInt(styles.paddingRight) +
    toInt(styles.borderLeftWidth) +
    toInt(styles.borderRightWidth)
  );
}

var env = {
  isWebKit:
    typeof document !== 'undefined' &&
    'WebkitAppearance' in document.documentElement.style,
  supportsTouch:
    typeof window !== 'undefined' &&
    ('ontouchstart' in window ||
      (window.DocumentTouch && document instanceof window.DocumentTouch)),
  supportsIePointer:
    typeof navigator !== 'undefined' && navigator.msMaxTouchPoints,
  isChrome:
    typeof navigator !== 'undefined' &&
    /Chrome/i.test(navigator && navigator.userAgent),
};

var updateGeometry = function(i) {
  var element = i.element;
  var roundedScrollTop = Math.floor(element.scrollTop);

  i.containerWidth = element.clientWidth;
  i.containerHeight = element.clientHeight;
  i.contentWidth = element.scrollWidth;
  i.contentHeight = element.scrollHeight;

  if (!element.contains(i.scrollbarXRail)) {
    // clean up and append
    queryChildren(element, cls.element.rail('x')).forEach(function (el) { return remove(el); }
    );
    element.appendChild(i.scrollbarXRail);
  }
  if (!element.contains(i.scrollbarYRail)) {
    // clean up and append
    queryChildren(element, cls.element.rail('y')).forEach(function (el) { return remove(el); }
    );
    element.appendChild(i.scrollbarYRail);
  }

  if (
    !i.settings.suppressScrollX &&
    i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth
  ) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(
      i,
      toInt(i.railXWidth * i.containerWidth / i.contentWidth)
    );
    i.scrollbarXLeft = toInt(
      (i.negativeScrollAdjustment + element.scrollLeft) *
        (i.railXWidth - i.scrollbarXWidth) /
        (i.contentWidth - i.containerWidth)
    );
  } else {
    i.scrollbarXActive = false;
  }

  if (
    !i.settings.suppressScrollY &&
    i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight
  ) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(
      i,
      toInt(i.railYHeight * i.containerHeight / i.contentHeight)
    );
    i.scrollbarYTop = toInt(
      roundedScrollTop *
        (i.railYHeight - i.scrollbarYHeight) /
        (i.contentHeight - i.containerHeight)
    );
  } else {
    i.scrollbarYActive = false;
  }

  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }
  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }

  updateCss(element, i);

  if (i.scrollbarXActive) {
    element.classList.add(cls.state.active('x'));
  } else {
    element.classList.remove(cls.state.active('x'));
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element.scrollLeft = 0;
  }
  if (i.scrollbarYActive) {
    element.classList.add(cls.state.active('y'));
  } else {
    element.classList.remove(cls.state.active('y'));
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    element.scrollTop = 0;
  }
};

function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }
  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }
  return thumbSize;
}

function updateCss(element, i) {
  var xRailOffset = { width: i.railXWidth };
  var roundedScrollTop = Math.floor(element.scrollTop);

  if (i.isRtl) {
    xRailOffset.left =
      i.negativeScrollAdjustment +
      element.scrollLeft +
      i.containerWidth -
      i.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
  }
  set(i.scrollbarXRail, xRailOffset);

  var yRailOffset = { top: roundedScrollTop, height: i.railYHeight };
  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right =
        i.contentWidth -
        (i.negativeScrollAdjustment + element.scrollLeft) -
        i.scrollbarYRight -
        i.scrollbarYOuterWidth;
    } else {
      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left =
        i.negativeScrollAdjustment +
        element.scrollLeft +
        i.containerWidth * 2 -
        i.contentWidth -
        i.scrollbarYLeft -
        i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
    }
  }
  set(i.scrollbarYRail, yRailOffset);

  set(i.scrollbarX, {
    left: i.scrollbarXLeft,
    width: i.scrollbarXWidth - i.railBorderXWidth,
  });
  set(i.scrollbarY, {
    top: i.scrollbarYTop,
    height: i.scrollbarYHeight - i.railBorderYWidth,
  });
}

var clickRail = function(i) {
  i.event.bind(i.scrollbarY, 'mousedown', function (e) { return e.stopPropagation(); });
  i.event.bind(i.scrollbarYRail, 'mousedown', function (e) {
    var positionTop =
      e.pageY -
      window.pageYOffset -
      i.scrollbarYRail.getBoundingClientRect().top;
    var direction = positionTop > i.scrollbarYTop ? 1 : -1;

    i.element.scrollTop += direction * i.containerHeight;
    updateGeometry(i);

    e.stopPropagation();
  });

  i.event.bind(i.scrollbarX, 'mousedown', function (e) { return e.stopPropagation(); });
  i.event.bind(i.scrollbarXRail, 'mousedown', function (e) {
    var positionLeft =
      e.pageX -
      window.pageXOffset -
      i.scrollbarXRail.getBoundingClientRect().left;
    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;

    i.element.scrollLeft += direction * i.containerWidth;
    updateGeometry(i);

    e.stopPropagation();
  });
};

var dragThumb = function(i) {
  bindMouseScrollHandler(i, [
    'containerWidth',
    'contentWidth',
    'pageX',
    'railXWidth',
    'scrollbarX',
    'scrollbarXWidth',
    'scrollLeft',
    'x',
    'scrollbarXRail' ]);
  bindMouseScrollHandler(i, [
    'containerHeight',
    'contentHeight',
    'pageY',
    'railYHeight',
    'scrollbarY',
    'scrollbarYHeight',
    'scrollTop',
    'y',
    'scrollbarYRail' ]);
};

function bindMouseScrollHandler(
  i,
  ref
) {
  var containerHeight = ref[0];
  var contentHeight = ref[1];
  var pageY = ref[2];
  var railYHeight = ref[3];
  var scrollbarY = ref[4];
  var scrollbarYHeight = ref[5];
  var scrollTop = ref[6];
  var y = ref[7];
  var scrollbarYRail = ref[8];

  var element = i.element;

  var startingScrollTop = null;
  var startingMousePageY = null;
  var scrollBy = null;

  function mouseMoveHandler(e) {
    element[scrollTop] =
      startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);
    addScrollingClass(i, y);
    updateGeometry(i);

    e.stopPropagation();
    e.preventDefault();
  }

  function mouseUpHandler() {
    removeScrollingClass(i, y);
    i[scrollbarYRail].classList.remove(cls.state.clicking);
    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
  }

  i.event.bind(i[scrollbarY], 'mousedown', function (e) {
    startingScrollTop = element[scrollTop];
    startingMousePageY = e[pageY];
    scrollBy =
      (i[contentHeight] - i[containerHeight]) /
      (i[railYHeight] - i[scrollbarYHeight]);

    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

    i[scrollbarYRail].classList.add(cls.state.clicking);

    e.stopPropagation();
    e.preventDefault();
  });
}

var keyboard = function(i) {
  var element = i.element;

  var elementHovered = function () { return matches(element, ':hover'); };
  var scrollbarFocused = function () { return matches(i.scrollbarX, ':focus') || matches(i.scrollbarY, ':focus'); };

  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if (
        (scrollTop === 0 && deltaY > 0) ||
        (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)
      ) {
        return !i.settings.wheelPropagation;
      }
    }

    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if (
        (scrollLeft === 0 && deltaX < 0) ||
        (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)
      ) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }

  i.event.bind(i.ownerDocument, 'keydown', function (e) {
    if (
      (e.isDefaultPrevented && e.isDefaultPrevented()) ||
      e.defaultPrevented
    ) {
      return;
    }

    if (!elementHovered() && !scrollbarFocused()) {
      return;
    }

    var activeElement = document.activeElement
      ? document.activeElement
      : i.ownerDocument.activeElement;
    if (activeElement) {
      if (activeElement.tagName === 'IFRAME') {
        activeElement = activeElement.contentDocument.activeElement;
      } else {
        // go deeper if element is a webcomponent
        while (activeElement.shadowRoot) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
      }
      if (isEditable(activeElement)) {
        return;
      }
    }

    var deltaX = 0;
    var deltaY = 0;

    switch (e.which) {
      case 37: // left
        if (e.metaKey) {
          deltaX = -i.contentWidth;
        } else if (e.altKey) {
          deltaX = -i.containerWidth;
        } else {
          deltaX = -30;
        }
        break;
      case 38: // up
        if (e.metaKey) {
          deltaY = i.contentHeight;
        } else if (e.altKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = 30;
        }
        break;
      case 39: // right
        if (e.metaKey) {
          deltaX = i.contentWidth;
        } else if (e.altKey) {
          deltaX = i.containerWidth;
        } else {
          deltaX = 30;
        }
        break;
      case 40: // down
        if (e.metaKey) {
          deltaY = -i.contentHeight;
        } else if (e.altKey) {
          deltaY = -i.containerHeight;
        } else {
          deltaY = -30;
        }
        break;
      case 32: // space bar
        if (e.shiftKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = -i.containerHeight;
        }
        break;
      case 33: // page up
        deltaY = i.containerHeight;
        break;
      case 34: // page down
        deltaY = -i.containerHeight;
        break;
      case 36: // home
        deltaY = i.contentHeight;
        break;
      case 35: // end
        deltaY = -i.contentHeight;
        break;
      default:
        return;
    }

    if (i.settings.suppressScrollX && deltaX !== 0) {
      return;
    }
    if (i.settings.suppressScrollY && deltaY !== 0) {
      return;
    }

    element.scrollTop -= deltaY;
    element.scrollLeft += deltaX;
    updateGeometry(i);

    if (shouldPreventDefault(deltaX, deltaY)) {
      e.preventDefault();
    }
  });
};

var wheel = function(i) {
  var element = i.element;

  function shouldPreventDefault(deltaX, deltaY) {
    var roundedScrollTop = Math.floor(element.scrollTop);
    var isTop = element.scrollTop === 0;
    var isBottom =
      roundedScrollTop + element.offsetHeight === element.scrollHeight;
    var isLeft = element.scrollLeft === 0;
    var isRight =
      element.scrollLeft + element.offsetWidth === element.scrollWidth;

    var hitsBound;

    // pick axis with primary direction
    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      hitsBound = isTop || isBottom;
    } else {
      hitsBound = isLeft || isRight;
    }

    return hitsBound ? !i.settings.wheelPropagation : true;
  }

  function getDeltaFromEvent(e) {
    var deltaX = e.deltaX;
    var deltaY = -1 * e.deltaY;

    if (typeof deltaX === 'undefined' || typeof deltaY === 'undefined') {
      // OS X Safari
      deltaX = -1 * e.wheelDeltaX / 6;
      deltaY = e.wheelDeltaY / 6;
    }

    if (e.deltaMode && e.deltaMode === 1) {
      // Firefox in deltaMode 1: Line scrolling
      deltaX *= 10;
      deltaY *= 10;
    }

    if (deltaX !== deltaX && deltaY !== deltaY /* NaN checks */) {
      // IE in some mouse drivers
      deltaX = 0;
      deltaY = e.wheelDelta;
    }

    if (e.shiftKey) {
      // reverse axis with shift key
      return [-deltaY, -deltaX];
    }
    return [deltaX, deltaY];
  }

  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    // FIXME: this is a workaround for <select> issue in FF and IE #571
    if (!env.isWebKit && element.querySelector('select:focus')) {
      return true;
    }

    if (!element.contains(target)) {
      return false;
    }

    var cursor = target;

    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }

      var style = get(cursor);
      var overflow = [style.overflow, style.overflowX, style.overflowY].join(
        ''
      );

      // if scrollable
      if (overflow.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (
            !(cursor.scrollTop === 0 && deltaY > 0) &&
            !(cursor.scrollTop === maxScrollTop && deltaY < 0)
          ) {
            return true;
          }
        }
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (
            !(cursor.scrollLeft === 0 && deltaX < 0) &&
            !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)
          ) {
            return true;
          }
        }
      }

      cursor = cursor.parentNode;
    }

    return false;
  }

  function mousewheelHandler(e) {
    var ref = getDeltaFromEvent(e);
    var deltaX = ref[0];
    var deltaY = ref[1];

    if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {
      return;
    }

    var shouldPrevent = false;
    if (!i.settings.useBothWheelAxes) {
      // deltaX will only be used for horizontal scrolling and deltaY will
      // only be used for vertical scrolling - this is the default
      element.scrollTop -= deltaY * i.settings.wheelSpeed;
      element.scrollLeft += deltaX * i.settings.wheelSpeed;
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      // only vertical scrollbar is active and useBothWheelAxes option is
      // active, so let's scroll vertical bar using both mouse wheel axes
      if (deltaY) {
        element.scrollTop -= deltaY * i.settings.wheelSpeed;
      } else {
        element.scrollTop += deltaX * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      // useBothWheelAxes and only horizontal bar is active, so use both
      // wheel axes for horizontal bar
      if (deltaX) {
        element.scrollLeft += deltaX * i.settings.wheelSpeed;
      } else {
        element.scrollLeft -= deltaY * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    }

    updateGeometry(i);

    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent && !e.ctrlKey) {
      e.stopPropagation();
      e.preventDefault();
    }
  }

  if (typeof window.onwheel !== 'undefined') {
    i.event.bind(element, 'wheel', mousewheelHandler);
  } else if (typeof window.onmousewheel !== 'undefined') {
    i.event.bind(element, 'mousewheel', mousewheelHandler);
  }
};

var touch = function(i) {
  if (!env.supportsTouch && !env.supportsIePointer) {
    return;
  }

  var element = i.element;

  function shouldPrevent(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    var scrollLeft = element.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);

    if (magnitudeY > magnitudeX) {
      // user is perhaps trying to swipe up/down the page

      if (
        (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight) ||
        (deltaY > 0 && scrollTop === 0)
      ) {
        // set prevent for mobile Chrome refresh
        return window.scrollY === 0 && deltaY > 0 && env.isChrome;
      }
    } else if (magnitudeX > magnitudeY) {
      // user is perhaps trying to swipe left/right across the page

      if (
        (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth) ||
        (deltaX > 0 && scrollLeft === 0)
      ) {
        return true;
      }
    }

    return true;
  }

  function applyTouchMove(differenceX, differenceY) {
    element.scrollTop -= differenceY;
    element.scrollLeft -= differenceX;

    updateGeometry(i);
  }

  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;

  function getTouch(e) {
    if (e.targetTouches) {
      return e.targetTouches[0];
    } else {
      // Maybe IE pointer
      return e;
    }
  }

  function shouldHandle(e) {
    if (e.pointerType && e.pointerType === 'pen' && e.buttons === 0) {
      return false;
    }
    if (e.targetTouches && e.targetTouches.length === 1) {
      return true;
    }
    if (
      e.pointerType &&
      e.pointerType !== 'mouse' &&
      e.pointerType !== e.MSPOINTER_TYPE_MOUSE
    ) {
      return true;
    }
    return false;
  }

  function touchStart(e) {
    if (!shouldHandle(e)) {
      return;
    }

    var touch = getTouch(e);

    startOffset.pageX = touch.pageX;
    startOffset.pageY = touch.pageY;

    startTime = new Date().getTime();

    if (easingLoop !== null) {
      clearInterval(easingLoop);
    }
  }

  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!element.contains(target)) {
      return false;
    }

    var cursor = target;

    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }

      var style = get(cursor);
      var overflow = [style.overflow, style.overflowX, style.overflowY].join(
        ''
      );

      // if scrollable
      if (overflow.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (
            !(cursor.scrollTop === 0 && deltaY > 0) &&
            !(cursor.scrollTop === maxScrollTop && deltaY < 0)
          ) {
            return true;
          }
        }
        var maxScrollLeft = cursor.scrollLeft - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (
            !(cursor.scrollLeft === 0 && deltaX < 0) &&
            !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)
          ) {
            return true;
          }
        }
      }

      cursor = cursor.parentNode;
    }

    return false;
  }

  function touchMove(e) {
    if (shouldHandle(e)) {
      var touch = getTouch(e);

      var currentOffset = { pageX: touch.pageX, pageY: touch.pageY };

      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;

      if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {
        return;
      }

      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;

      var currentTime = new Date().getTime();

      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }

      if (shouldPrevent(differenceX, differenceY)) {
        e.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (i.settings.swipeEasing) {
      clearInterval(easingLoop);
      easingLoop = setInterval(function() {
        if (i.isInitialized) {
          clearInterval(easingLoop);
          return;
        }

        if (!speed.x && !speed.y) {
          clearInterval(easingLoop);
          return;
        }

        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }

        applyTouchMove(speed.x * 30, speed.y * 30);

        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }

  if (env.supportsTouch) {
    i.event.bind(element, 'touchstart', touchStart);
    i.event.bind(element, 'touchmove', touchMove);
    i.event.bind(element, 'touchend', touchEnd);
  } else if (env.supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(element, 'pointerdown', touchStart);
      i.event.bind(element, 'pointermove', touchMove);
      i.event.bind(element, 'pointerup', touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(element, 'MSPointerDown', touchStart);
      i.event.bind(element, 'MSPointerMove', touchMove);
      i.event.bind(element, 'MSPointerUp', touchEnd);
    }
  }
};

var defaultSettings = function () { return ({
  handlers: ['click-rail', 'drag-thumb', 'keyboard', 'wheel', 'touch'],
  maxScrollbarLength: null,
  minScrollbarLength: null,
  scrollingThreshold: 1000,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0,
  suppressScrollX: false,
  suppressScrollY: false,
  swipeEasing: true,
  useBothWheelAxes: false,
  wheelPropagation: true,
  wheelSpeed: 1,
}); };

var handlers = {
  'click-rail': clickRail,
  'drag-thumb': dragThumb,
  keyboard: keyboard,
  wheel: wheel,
  touch: touch,
};

var PerfectScrollbar = function PerfectScrollbar(element, userSettings) {
  var this$1 = this;
  if ( userSettings === void 0 ) userSettings = {};

  if (typeof element === 'string') {
    element = document.querySelector(element);
  }

  if (!element || !element.nodeName) {
    throw new Error('no element is specified to initialize PerfectScrollbar');
  }

  this.element = element;

  element.classList.add(cls.main);

  this.settings = defaultSettings();
  for (var key in userSettings) {
    this$1.settings[key] = userSettings[key];
  }

  this.containerWidth = null;
  this.containerHeight = null;
  this.contentWidth = null;
  this.contentHeight = null;

  var focus = function () { return element.classList.add(cls.state.focus); };
  var blur = function () { return element.classList.remove(cls.state.focus); };

  this.isRtl = get(element).direction === 'rtl';
  this.isNegativeScroll = (function () {
    var originalScrollLeft = element.scrollLeft;
    var result = null;
    element.scrollLeft = -1;
    result = element.scrollLeft < 0;
    element.scrollLeft = originalScrollLeft;
    return result;
  })();
  this.negativeScrollAdjustment = this.isNegativeScroll
    ? element.scrollWidth - element.clientWidth
    : 0;
  this.event = new EventManager();
  this.ownerDocument = element.ownerDocument || document;

  this.scrollbarXRail = div(cls.element.rail('x'));
  element.appendChild(this.scrollbarXRail);
  this.scrollbarX = div(cls.element.thumb('x'));
  this.scrollbarXRail.appendChild(this.scrollbarX);
  this.scrollbarX.setAttribute('tabindex', 0);
  this.event.bind(this.scrollbarX, 'focus', focus);
  this.event.bind(this.scrollbarX, 'blur', blur);
  this.scrollbarXActive = null;
  this.scrollbarXWidth = null;
  this.scrollbarXLeft = null;
  var railXStyle = get(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
  if (isNaN(this.scrollbarXBottom)) {
    this.isScrollbarXUsingBottom = false;
    this.scrollbarXTop = toInt(railXStyle.top);
  } else {
    this.isScrollbarXUsingBottom = true;
  }
  this.railBorderXWidth =
    toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
  // Set rail to display:block to calculate margins
  set(this.scrollbarXRail, { display: 'block' });
  this.railXMarginWidth =
    toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
  set(this.scrollbarXRail, { display: '' });
  this.railXWidth = null;
  this.railXRatio = null;

  this.scrollbarYRail = div(cls.element.rail('y'));
  element.appendChild(this.scrollbarYRail);
  this.scrollbarY = div(cls.element.thumb('y'));
  this.scrollbarYRail.appendChild(this.scrollbarY);
  this.scrollbarY.setAttribute('tabindex', 0);
  this.event.bind(this.scrollbarY, 'focus', focus);
  this.event.bind(this.scrollbarY, 'blur', blur);
  this.scrollbarYActive = null;
  this.scrollbarYHeight = null;
  this.scrollbarYTop = null;
  var railYStyle = get(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(railYStyle.right, 10);
  if (isNaN(this.scrollbarYRight)) {
    this.isScrollbarYUsingRight = false;
    this.scrollbarYLeft = toInt(railYStyle.left);
  } else {
    this.isScrollbarYUsingRight = true;
  }
  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
  this.railBorderYWidth =
    toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
  set(this.scrollbarYRail, { display: 'block' });
  this.railYMarginHeight =
    toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
  set(this.scrollbarYRail, { display: '' });
  this.railYHeight = null;
  this.railYRatio = null;

  this.reach = {
    x:
      element.scrollLeft <= 0
        ? 'start'
        : element.scrollLeft >= this.contentWidth - this.containerWidth
          ? 'end'
          : null,
    y:
      element.scrollTop <= 0
        ? 'start'
        : element.scrollTop >= this.contentHeight - this.containerHeight
          ? 'end'
          : null,
  };

  this.isAlive = true;

  this.settings.handlers.forEach(function (handlerName) { return handlers[handlerName](this$1); });

  this.lastScrollTop = Math.floor(element.scrollTop); // for onScroll only
  this.lastScrollLeft = element.scrollLeft; // for onScroll only
  this.event.bind(this.element, 'scroll', function (e) { return this$1.onScroll(e); });
  updateGeometry(this);
};

PerfectScrollbar.prototype.update = function update () {
  if (!this.isAlive) {
    return;
  }

  // Recalcuate negative scrollLeft adjustment
  this.negativeScrollAdjustment = this.isNegativeScroll
    ? this.element.scrollWidth - this.element.clientWidth
    : 0;

  // Recalculate rail margins
  set(this.scrollbarXRail, { display: 'block' });
  set(this.scrollbarYRail, { display: 'block' });
  this.railXMarginWidth =
    toInt(get(this.scrollbarXRail).marginLeft) +
    toInt(get(this.scrollbarXRail).marginRight);
  this.railYMarginHeight =
    toInt(get(this.scrollbarYRail).marginTop) +
    toInt(get(this.scrollbarYRail).marginBottom);

  // Hide scrollbars not to affect scrollWidth and scrollHeight
  set(this.scrollbarXRail, { display: 'none' });
  set(this.scrollbarYRail, { display: 'none' });

  updateGeometry(this);

  processScrollDiff(this, 'top', 0, false, true);
  processScrollDiff(this, 'left', 0, false, true);

  set(this.scrollbarXRail, { display: '' });
  set(this.scrollbarYRail, { display: '' });
};

PerfectScrollbar.prototype.onScroll = function onScroll (e) {
  if (!this.isAlive) {
    return;
  }

  updateGeometry(this);
  processScrollDiff(this, 'top', this.element.scrollTop - this.lastScrollTop);
  processScrollDiff(
    this,
    'left',
    this.element.scrollLeft - this.lastScrollLeft
  );

  this.lastScrollTop = Math.floor(this.element.scrollTop);
  this.lastScrollLeft = this.element.scrollLeft;
};

PerfectScrollbar.prototype.destroy = function destroy () {
  if (!this.isAlive) {
    return;
  }

  this.event.unbindAll();
  remove(this.scrollbarX);
  remove(this.scrollbarY);
  remove(this.scrollbarXRail);
  remove(this.scrollbarYRail);
  this.removePsClasses();

  // unset elements
  this.element = null;
  this.scrollbarX = null;
  this.scrollbarY = null;
  this.scrollbarXRail = null;
  this.scrollbarYRail = null;

  this.isAlive = false;
};

PerfectScrollbar.prototype.removePsClasses = function removePsClasses () {
  this.element.className = this.element.className
    .split(' ')
    .filter(function (name) { return !name.match(/^ps([-_].+|)$/); })
    .join(' ');
};

return PerfectScrollbar;

})));

/*!
 * 
 *         SimpleBar.js - v2.6.1
 *         Scrollbars, simpler.
 *         https://grsmto.github.io/simplebar/
 *         
 *         Made by Adrien Grsmto from a fork by Jonathan Nicol
 *         Under MIT License
 *       
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.SimpleBar=e():t.SimpleBar=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var n={};return e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=27)}([function(t,e,n){var r=n(23)("wks"),i=n(12),o=n(1).Symbol,s="function"==typeof o;(t.exports=function(t){return r[t]||(r[t]=s&&o[t]||(s?o:i)("Symbol."+t))}).store=r},function(t,e){var n=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=n)},function(t,e){var n={}.hasOwnProperty;t.exports=function(t,e){return n.call(t,e)}},function(t,e){var n=t.exports={version:"2.5.1"};"number"==typeof __e&&(__e=n)},function(t,e,n){var r=n(5),i=n(11);t.exports=n(7)?function(t,e,n){return r.f(t,e,i(1,n))}:function(t,e,n){return t[e]=n,t}},function(t,e,n){var r=n(6),i=n(33),o=n(34),s=Object.defineProperty;e.f=n(7)?Object.defineProperty:function(t,e,n){if(r(t),e=o(e,!0),r(n),i)try{return s(t,e,n)}catch(t){}if("get"in n||"set"in n)throw TypeError("Accessors not supported!");return"value"in n&&(t[e]=n.value),t}},function(t,e,n){var r=n(10);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,e,n){t.exports=!n(16)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,e){var n=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:n)(t)}},function(t,e){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,e){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,e){t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},function(t,e){var n=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++n+r).toString(36))}},function(t,e){t.exports={}},function(t,e,n){var r=n(23)("keys"),i=n(12);t.exports=function(t){return r[t]||(r[t]=i(t))}},function(t,e,n){var r=n(1),i=n(3),o=n(4),s=n(18),c=n(19),a=function(t,e,n){var u,l,f,h,d=t&a.F,p=t&a.G,v=t&a.S,b=t&a.P,y=t&a.B,m=p?r:v?r[e]||(r[e]={}):(r[e]||{}).prototype,g=p?i:i[e]||(i[e]={}),E=g.prototype||(g.prototype={});p&&(n=e);for(u in n)l=!d&&m&&void 0!==m[u],f=(l?m:n)[u],h=y&&l?c(f,r):b&&"function"==typeof f?c(Function.call,f):f,m&&s(m,u,f,t&a.U),g[u]!=f&&o(g,u,h),b&&E[u]!=f&&(E[u]=f)};r.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,e){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,e,n){var r=n(10),i=n(1).document,o=r(i)&&r(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,e,n){var r=n(1),i=n(4),o=n(2),s=n(12)("src"),c=Function.toString,a=(""+c).split("toString");n(3).inspectSource=function(t){return c.call(t)},(t.exports=function(t,e,n,c){var u="function"==typeof n;u&&(o(n,"name")||i(n,"name",e)),t[e]!==n&&(u&&(o(n,s)||i(n,s,t[e]?""+t[e]:a.join(String(e)))),t===r?t[e]=n:c?t[e]?t[e]=n:i(t,e,n):(delete t[e],i(t,e,n)))})(Function.prototype,"toString",function(){return"function"==typeof this&&this[s]||c.call(this)})},function(t,e,n){var r=n(35);t.exports=function(t,e,n){if(r(t),void 0===e)return t;switch(n){case 1:return function(n){return t.call(e,n)};case 2:return function(n,r){return t.call(e,n,r)};case 3:return function(n,r,i){return t.call(e,n,r,i)}}return function(){return t.apply(e,arguments)}}},function(t,e,n){var r=n(41),i=n(9);t.exports=function(t){return r(i(t))}},function(t,e){var n={}.toString;t.exports=function(t){return n.call(t).slice(8,-1)}},function(t,e,n){var r=n(8),i=Math.min;t.exports=function(t){return t>0?i(r(t),9007199254740991):0}},function(t,e,n){var r=n(1),i=r["__core-js_shared__"]||(r["__core-js_shared__"]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,e){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,e,n){var r=n(5).f,i=n(2),o=n(0)("toStringTag");t.exports=function(t,e,n){t&&!i(t=n?t:t.prototype,o)&&r(t,o,{configurable:!0,value:e})}},function(t,e,n){var r=n(9);t.exports=function(t){return Object(r(t))}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function s(t,e,n){return e&&o(t.prototype,e),n&&o(t,n),t}Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0,n(28);var c=r(n(53)),a=r(n(54)),u=r(n(56));n(57),Object.assign=n(58);var l=function(){function t(e,n){i(this,t),this.el=e,this.flashTimeout,this.contentEl,this.scrollContentEl,this.dragOffset={x:0,y:0},this.isVisible={x:!0,y:!0},this.scrollOffsetAttr={x:"scrollLeft",y:"scrollTop"},this.sizeAttr={x:"offsetWidth",y:"offsetHeight"},this.scrollSizeAttr={x:"scrollWidth",y:"scrollHeight"},this.offsetAttr={x:"left",y:"top"},this.globalObserver,this.mutationObserver,this.resizeObserver,this.currentAxis,this.isRtl,this.options=Object.assign({},t.defaultOptions,n),this.classNames=this.options.classNames,this.scrollbarWidth=(0,c.default)(),this.offsetSize=20,this.flashScrollbar=this.flashScrollbar.bind(this),this.onDragY=this.onDragY.bind(this),this.onDragX=this.onDragX.bind(this),this.onScrollY=this.onScrollY.bind(this),this.onScrollX=this.onScrollX.bind(this),this.drag=this.drag.bind(this),this.onEndDrag=this.onEndDrag.bind(this),this.onMouseEnter=this.onMouseEnter.bind(this),this.recalculate=(0,a.default)(this.recalculate,100,{leading:!0}),this.init()}return s(t,[{key:"init",value:function(){this.el.SimpleBar=this,this.initDOM(),this.scrollbarX=this.trackX.querySelector(".".concat(this.classNames.scrollbar)),this.scrollbarY=this.trackY.querySelector(".".concat(this.classNames.scrollbar)),this.isRtl="rtl"===getComputedStyle(this.contentEl).direction,this.scrollContentEl.style[this.isRtl?"paddingLeft":"paddingRight"]="".concat(this.scrollbarWidth||this.offsetSize,"px"),this.scrollContentEl.style.marginBottom="-".concat(2*this.scrollbarWidth||this.offsetSize,"px"),this.contentEl.style.paddingBottom="".concat(this.scrollbarWidth||this.offsetSize,"px"),0!==this.scrollbarWidth&&(this.contentEl.style[this.isRtl?"marginLeft":"marginRight"]="-".concat(this.scrollbarWidth,"px")),this.recalculate(),this.initListeners()}},{key:"initDOM",value:function(){var t=this;if(Array.from(this.el.children).filter(function(e){return e.classList.contains(t.classNames.scrollContent)}).length)this.trackX=this.el.querySelector(".".concat(this.classNames.track,".horizontal")),this.trackY=this.el.querySelector(".".concat(this.classNames.track,".vertical")),this.scrollContentEl=this.el.querySelector(".".concat(this.classNames.scrollContent)),this.contentEl=this.el.querySelector(".".concat(this.classNames.content));else{for(this.scrollContentEl=document.createElement("div"),this.contentEl=document.createElement("div"),this.scrollContentEl.classList.add(this.classNames.scrollContent),this.contentEl.classList.add(this.classNames.content);this.el.firstChild;)this.contentEl.appendChild(this.el.firstChild);this.scrollContentEl.appendChild(this.contentEl),this.el.appendChild(this.scrollContentEl)}if(!this.trackX||!this.trackY){var e=document.createElement("div"),n=document.createElement("div");e.classList.add(this.classNames.track),n.classList.add(this.classNames.scrollbar),e.appendChild(n),this.trackX=e.cloneNode(!0),this.trackX.classList.add("horizontal"),this.trackY=e.cloneNode(!0),this.trackY.classList.add("vertical"),this.el.insertBefore(this.trackX,this.el.firstChild),this.el.insertBefore(this.trackY,this.el.firstChild)}this.el.setAttribute("data-simplebar","init")}},{key:"initListeners",value:function(){var t=this;this.options.autoHide&&this.el.addEventListener("mouseenter",this.onMouseEnter),this.scrollbarY.addEventListener("mousedown",this.onDragY),this.scrollbarX.addEventListener("mousedown",this.onDragX),this.scrollContentEl.addEventListener("scroll",this.onScrollY),this.contentEl.addEventListener("scroll",this.onScrollX),"undefined"!=typeof MutationObserver&&(this.mutationObserver=new MutationObserver(function(e){e.forEach(function(e){(t.isChildNode(e.target)||e.addedNodes.length)&&t.recalculate()})}),this.mutationObserver.observe(this.el,{attributes:!0,childList:!0,characterData:!0,subtree:!0})),this.resizeObserver=new u.default(this.recalculate.bind(this)),this.resizeObserver.observe(this.el)}},{key:"removeListeners",value:function(){this.options.autoHide&&this.el.removeEventListener("mouseenter",this.onMouseEnter),this.scrollbarX.removeEventListener("mousedown",this.onDragX),this.scrollbarY.removeEventListener("mousedown",this.onDragY),this.scrollContentEl.removeEventListener("scroll",this.onScrollY),this.contentEl.removeEventListener("scroll",this.onScrollX),this.mutationObserver.disconnect(),this.resizeObserver.disconnect()}},{key:"onDragX",value:function(t){this.onDrag(t,"x")}},{key:"onDragY",value:function(t){this.onDrag(t,"y")}},{key:"onDrag",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"y";t.preventDefault();var n="y"===e?this.scrollbarY:this.scrollbarX,r="y"===e?t.pageY:t.pageX;this.dragOffset[e]=r-n.getBoundingClientRect()[this.offsetAttr[e]],this.currentAxis=e,document.addEventListener("mousemove",this.drag),document.addEventListener("mouseup",this.onEndDrag)}},{key:"drag",value:function(t){var e,n,r;t.preventDefault(),"y"===this.currentAxis?(e=t.pageY,n=this.trackY,r=this.scrollContentEl):(e=t.pageX,n=this.trackX,r=this.contentEl);var i=e-n.getBoundingClientRect()[this.offsetAttr[this.currentAxis]]-this.dragOffset[this.currentAxis],o=i/n[this.sizeAttr[this.currentAxis]],s=o*this.contentEl[this.scrollSizeAttr[this.currentAxis]];r[this.scrollOffsetAttr[this.currentAxis]]=s}},{key:"onEndDrag",value:function(){document.removeEventListener("mousemove",this.drag),document.removeEventListener("mouseup",this.onEndDrag)}},{key:"resizeScrollbar",value:function(){var t,e,n,r,i,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"y";"x"===o?(t=this.trackX,e=this.scrollbarX,n=this.contentEl[this.scrollOffsetAttr[o]],r=this.contentSizeX,i=this.scrollbarXSize):(t=this.trackY,e=this.scrollbarY,n=this.scrollContentEl[this.scrollOffsetAttr[o]],r=this.contentSizeY,i=this.scrollbarYSize);var s=i/r,c=n/(r-i),a=Math.max(~~(s*i),this.options.scrollbarMinSize),u=~~((i-a)*c);this.isVisible[o]=i<r,this.isVisible[o]||this.options.forceVisible?(t.style.visibility="visible",this.options.forceVisible?e.style.visibility="hidden":e.style.visibility="visible","x"===o?(e.style.left="".concat(u,"px"),e.style.width="".concat(a,"px")):(e.style.top="".concat(u,"px"),e.style.height="".concat(a,"px"))):t.style.visibility="hidden"}},{key:"onScrollX",value:function(){this.flashScrollbar("x")}},{key:"onScrollY",value:function(){this.flashScrollbar("y")}},{key:"onMouseEnter",value:function(){this.flashScrollbar("x"),this.flashScrollbar("y")}},{key:"flashScrollbar",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"y";this.resizeScrollbar(t),this.showScrollbar(t)}},{key:"showScrollbar",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"y";this.isVisible[t]&&("x"===t?this.scrollbarX.classList.add("visible"):this.scrollbarY.classList.add("visible"),this.options.autoHide&&("number"==typeof this.flashTimeout&&window.clearTimeout(this.flashTimeout),this.flashTimeout=window.setTimeout(this.hideScrollbar.bind(this),1e3)))}},{key:"hideScrollbar",value:function(){this.scrollbarX.classList.remove("visible"),this.scrollbarY.classList.remove("visible"),"number"==typeof this.flashTimeout&&window.clearTimeout(this.flashTimeout)}},{key:"recalculate",value:function(){this.contentSizeX=this.contentEl[this.scrollSizeAttr.x],this.contentSizeY=this.contentEl[this.scrollSizeAttr.y]-(this.scrollbarWidth||this.offsetSize),this.scrollbarXSize=this.trackX[this.sizeAttr.x],this.scrollbarYSize=this.trackY[this.sizeAttr.y],this.resizeScrollbar("x"),this.resizeScrollbar("y"),this.options.autoHide||(this.showScrollbar("x"),this.showScrollbar("y"))}},{key:"getScrollElement",value:function(){return"y"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"y")?this.scrollContentEl:this.contentEl}},{key:"getContentElement",value:function(){return this.contentEl}},{key:"unMount",value:function(){this.removeListeners(),this.el.SimpleBar=null}},{key:"isChildNode",value:function(t){return null!==t&&(t===this.el||this.isChildNode(t.parentNode))}}],[{key:"initHtmlApi",value:function(){this.initDOMLoadedElements=this.initDOMLoadedElements.bind(this),"undefined"!=typeof MutationObserver&&(this.globalObserver=new MutationObserver(function(e){e.forEach(function(e){Array.from(e.addedNodes).forEach(function(e){1===e.nodeType&&(e.hasAttribute("data-simplebar")?!e.SimpleBar&&new t(e,t.getElOptions(e)):Array.from(e.querySelectorAll("[data-simplebar]")).forEach(function(e){!e.SimpleBar&&new t(e,t.getElOptions(e))}))}),Array.from(e.removedNodes).forEach(function(t){1===t.nodeType&&(t.hasAttribute("data-simplebar")?t.SimpleBar&&t.SimpleBar.unMount():Array.from(t.querySelectorAll("[data-simplebar]")).forEach(function(t){t.SimpleBar&&t.SimpleBar.unMount()}))})})}),this.globalObserver.observe(document,{childList:!0,subtree:!0})),"complete"===document.readyState||"loading"!==document.readyState&&!document.documentElement.doScroll?window.setTimeout(this.initDOMLoadedElements.bind(this)):(document.addEventListener("DOMContentLoaded",this.initDOMLoadedElements),window.addEventListener("load",this.initDOMLoadedElements))}},{key:"getElOptions",value:function(e){return Object.keys(t.htmlAttributes).reduce(function(n,r){var i=t.htmlAttributes[r];return e.hasAttribute(i)&&(n[r]=JSON.parse(e.getAttribute(i)||!0)),n},{})}},{key:"removeObserver",value:function(){this.globalObserver.disconnect()}},{key:"initDOMLoadedElements",value:function(){document.removeEventListener("DOMContentLoaded",this.initDOMLoadedElements),window.removeEventListener("load",this.initDOMLoadedElements),Array.from(document.querySelectorAll("[data-simplebar]")).forEach(function(e){e.SimpleBar||new t(e,t.getElOptions(e))})}},{key:"defaultOptions",get:function(){return{autoHide:!0,forceVisible:!1,classNames:{content:"simplebar-content",scrollContent:"simplebar-scroll-content",scrollbar:"simplebar-scrollbar",track:"simplebar-track"},scrollbarMinSize:25}}},{key:"htmlAttributes",get:function(){return{autoHide:"data-simplebar-auto-hide",forceVisible:"data-simplebar-force-visible",scrollbarMinSize:"data-simplebar-scrollbar-min-size"}}}]),t}();e.default=l,l.initHtmlApi()},function(t,e,n){n(29),n(46),t.exports=n(3).Array.from},function(t,e,n){"use strict";var r=n(30)(!0);n(31)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,e=this._t,n=this._i;return n>=e.length?{value:void 0,done:!0}:(t=r(e,n),this._i+=t.length,{value:t,done:!1})})},function(t,e,n){var r=n(8),i=n(9);t.exports=function(t){return function(e,n){var o,s,c=String(i(e)),a=r(n),u=c.length;return a<0||a>=u?t?"":void 0:(o=c.charCodeAt(a),o<55296||o>56319||a+1===u||(s=c.charCodeAt(a+1))<56320||s>57343?t?c.charAt(a):o:t?c.slice(a,a+2):s-56320+(o-55296<<10)+65536)}}},function(t,e,n){"use strict";var r=n(32),i=n(15),o=n(18),s=n(4),c=n(2),a=n(13),u=n(36),l=n(25),f=n(45),h=n(0)("iterator"),d=!([].keys&&"next"in[].keys()),p=function(){return this};t.exports=function(t,e,n,v,b,y,m){u(n,e,v);var g,E,O,_=function(t){if(!d&&t in A)return A[t];switch(t){case"keys":case"values":return function(){return new n(this,t)}}return function(){return new n(this,t)}},x=e+" Iterator",w="values"==b,S=!1,A=t.prototype,k=A[h]||A["@@iterator"]||b&&A[b],j=k||_(b),M=b?w?_("entries"):j:void 0,L="Array"==e?A.entries||k:k;if(L&&(O=f(L.call(new t)))!==Object.prototype&&O.next&&(l(O,x,!0),r||c(O,h)||s(O,h,p)),w&&k&&"values"!==k.name&&(S=!0,j=function(){return k.call(this)}),r&&!m||!d&&!S&&A[h]||s(A,h,j),a[e]=j,a[x]=p,b)if(g={values:w?j:_("values"),keys:y?j:_("keys"),entries:M},m)for(E in g)E in A||o(A,E,g[E]);else i(i.P+i.F*(d||S),e,g);return g}},function(t,e){t.exports=!1},function(t,e,n){t.exports=!n(7)&&!n(16)(function(){return 7!=Object.defineProperty(n(17)("div"),"a",{get:function(){return 7}}).a})},function(t,e,n){var r=n(10);t.exports=function(t,e){if(!r(t))return t;var n,i;if(e&&"function"==typeof(n=t.toString)&&!r(i=n.call(t)))return i;if("function"==typeof(n=t.valueOf)&&!r(i=n.call(t)))return i;if(!e&&"function"==typeof(n=t.toString)&&!r(i=n.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,e){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,e,n){"use strict";var r=n(37),i=n(11),o=n(25),s={};n(4)(s,n(0)("iterator"),function(){return this}),t.exports=function(t,e,n){t.prototype=r(s,{next:i(1,n)}),o(t,e+" Iterator")}},function(t,e,n){var r=n(6),i=n(38),o=n(24),s=n(14)("IE_PROTO"),c=function(){},a=function(){var t,e=n(17)("iframe"),r=o.length;for(e.style.display="none",n(44).appendChild(e),e.src="javascript:",t=e.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;r--;)delete a.prototype[o[r]];return a()};t.exports=Object.create||function(t,e){var n;return null!==t?(c.prototype=r(t),n=new c,c.prototype=null,n[s]=t):n=a(),void 0===e?n:i(n,e)}},function(t,e,n){var r=n(5),i=n(6),o=n(39);t.exports=n(7)?Object.defineProperties:function(t,e){i(t);for(var n,s=o(e),c=s.length,a=0;c>a;)r.f(t,n=s[a++],e[n]);return t}},function(t,e,n){var r=n(40),i=n(24);t.exports=Object.keys||function(t){return r(t,i)}},function(t,e,n){var r=n(2),i=n(20),o=n(42)(!1),s=n(14)("IE_PROTO");t.exports=function(t,e){var n,c=i(t),a=0,u=[];for(n in c)n!=s&&r(c,n)&&u.push(n);for(;e.length>a;)r(c,n=e[a++])&&(~o(u,n)||u.push(n));return u}},function(t,e,n){var r=n(21);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,e,n){var r=n(20),i=n(22),o=n(43);t.exports=function(t){return function(e,n,s){var c,a=r(e),u=i(a.length),l=o(s,u);if(t&&n!=n){for(;u>l;)if((c=a[l++])!=c)return!0}else for(;u>l;l++)if((t||l in a)&&a[l]===n)return t||l||0;return!t&&-1}}},function(t,e,n){var r=n(8),i=Math.max,o=Math.min;t.exports=function(t,e){return t=r(t),t<0?i(t+e,0):o(t,e)}},function(t,e,n){var r=n(1).document;t.exports=r&&r.documentElement},function(t,e,n){var r=n(2),i=n(26),o=n(14)("IE_PROTO"),s=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),r(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?s:null}},function(t,e,n){"use strict";var r=n(19),i=n(15),o=n(26),s=n(47),c=n(48),a=n(22),u=n(49),l=n(50);i(i.S+i.F*!n(52)(function(t){Array.from(t)}),"Array",{from:function(t){var e,n,i,f,h=o(t),d="function"==typeof this?this:Array,p=arguments.length,v=p>1?arguments[1]:void 0,b=void 0!==v,y=0,m=l(h);if(b&&(v=r(v,p>2?arguments[2]:void 0,2)),void 0==m||d==Array&&c(m))for(e=a(h.length),n=new d(e);e>y;y++)u(n,y,b?v(h[y],y):h[y]);else for(f=m.call(h),n=new d;!(i=f.next()).done;y++)u(n,y,b?s(f,v,[i.value,y],!0):i.value);return n.length=y,n}})},function(t,e,n){var r=n(6);t.exports=function(t,e,n,i){try{return i?e(r(n)[0],n[1]):e(n)}catch(e){var o=t.return;throw void 0!==o&&r(o.call(t)),e}}},function(t,e,n){var r=n(13),i=n(0)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(r.Array===t||o[i]===t)}},function(t,e,n){"use strict";var r=n(5),i=n(11);t.exports=function(t,e,n){e in t?r.f(t,e,i(0,n)):t[e]=n}},function(t,e,n){var r=n(51),i=n(0)("iterator"),o=n(13);t.exports=n(3).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[r(t)]}},function(t,e,n){var r=n(21),i=n(0)("toStringTag"),o="Arguments"==r(function(){return arguments}()),s=function(t,e){try{return t[e]}catch(t){}};t.exports=function(t){var e,n,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(n=s(e=Object(t),i))?n:o?r(e):"Object"==(c=r(e))&&"function"==typeof e.callee?"Arguments":c}},function(t,e,n){var r=n(0)("iterator"),i=!1;try{var o=[7][r]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,e){if(!e&&!i)return!1;var n=!1;try{var o=[7],s=o[r]();s.next=function(){return{done:n=!0}},o[r]=function(){return s},t(o)}catch(t){}return n}},function(t,e,n){var r,i,o;/*! scrollbarWidth.js v0.1.3 | felixexter | MIT | https://github.com/felixexter/scrollbarWidth */
!function(n,s){i=[],r=s,void 0!==(o="function"==typeof r?r.apply(e,i):r)&&(t.exports=o)}(0,function(){"use strict";function t(){if("undefined"==typeof document)return 0;var t,e=document.body,n=document.createElement("div"),r=n.style;return r.position="absolute",r.top=r.left="-9999px",r.width=r.height="100px",r.overflow="scroll",e.appendChild(n),t=n.offsetWidth-n.clientWidth,e.removeChild(n),t}return t})},function(t,e,n){(function(e){function n(t,e,n){function i(e){var n=v,r=b;return v=b=void 0,w=e,m=t.apply(r,n)}function o(t){return w=t,g=setTimeout(l,e),S?i(t):m}function a(t){var n=t-x,r=t-w,i=e-n;return A?O(i,y-r):i}function u(t){var n=t-x,r=t-w;return void 0===x||n>=e||n<0||A&&r>=y}function l(){var t=_();if(u(t))return f(t);g=setTimeout(l,a(t))}function f(t){return g=void 0,k&&v?i(t):(v=b=void 0,m)}function h(){void 0!==g&&clearTimeout(g),w=0,v=x=b=g=void 0}function d(){return void 0===g?m:f(_())}function p(){var t=_(),n=u(t);if(v=arguments,b=this,x=t,n){if(void 0===g)return o(x);if(A)return g=setTimeout(l,e),i(x)}return void 0===g&&(g=setTimeout(l,e)),m}var v,b,y,m,g,x,w=0,S=!1,A=!1,k=!0;if("function"!=typeof t)throw new TypeError(c);return e=s(e)||0,r(n)&&(S=!!n.leading,A="maxWait"in n,y=A?E(s(n.maxWait)||0,e):y,k="trailing"in n?!!n.trailing:k),p.cancel=h,p.flush=d,p}function r(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function i(t){return!!t&&"object"==typeof t}function o(t){return"symbol"==typeof t||i(t)&&g.call(t)==u}function s(t){if("number"==typeof t)return t;if(o(t))return a;if(r(t)){var e="function"==typeof t.valueOf?t.valueOf():t;t=r(e)?e+"":e}if("string"!=typeof t)return 0===t?t:+t;t=t.replace(l,"");var n=h.test(t);return n||d.test(t)?p(t.slice(2),n?2:8):f.test(t)?a:+t}var c="Expected a function",a=NaN,u="[object Symbol]",l=/^\s+|\s+$/g,f=/^[-+]0x[0-9a-f]+$/i,h=/^0b[01]+$/i,d=/^0o[0-7]+$/i,p=parseInt,v="object"==typeof e&&e&&e.Object===Object&&e,b="object"==typeof self&&self&&self.Object===Object&&self,y=v||b||Function("return this")(),m=Object.prototype,g=m.toString,E=Math.max,O=Math.min,_=function(){return y.Date.now()};t.exports=n}).call(e,n(55))},function(t,e){var n;n=function(){return this}();try{n=n||Function("return this")()||(0,eval)("this")}catch(t){"object"==typeof window&&(n=window)}t.exports=n},function(t,e,n){"use strict";function r(t){return parseFloat(t)||0}function i(t){return Array.prototype.slice.call(arguments,1).reduce(function(e,n){return e+r(t["border-"+n+"-width"])},0)}function o(t){for(var e=["top","right","bottom","left"],n={},i=0,o=e;i<o.length;i+=1){var s=o[i],c=t["padding-"+s];n[s]=r(c)}return n}function s(t){var e=t.getBBox();return f(0,0,e.width,e.height)}function c(t){var e=t.clientWidth,n=t.clientHeight;if(!e&&!n)return _;var s=getComputedStyle(t),c=o(s),u=c.left+c.right,l=c.top+c.bottom,h=r(s.width),d=r(s.height);if("border-box"===s.boxSizing&&(Math.round(h+u)!==e&&(h-=i(s,"left","right")+u),Math.round(d+l)!==n&&(d-=i(s,"top","bottom")+l)),!a(t)){var p=Math.round(h+u)-e,v=Math.round(d+l)-n;1!==Math.abs(p)&&(h-=p),1!==Math.abs(v)&&(d-=v)}return f(c.left,c.top,h,d)}function a(t){return t===document.documentElement}function u(t){return d?x(t)?s(t):c(t):_}function l(t){var e=t.x,n=t.y,r=t.width,i=t.height,o="undefined"!=typeof DOMRectReadOnly?DOMRectReadOnly:Object,s=Object.create(o.prototype);return O(s,{x:e,y:n,width:r,height:i,top:n,right:e+r,bottom:i+n,left:e}),s}function f(t,e,n,r){return{x:t,y:e,width:n,height:r}}Object.defineProperty(e,"__esModule",{value:!0});var h=function(){function t(t,e){var n=-1;return t.some(function(t,r){return t[0]===e&&(n=r,!0)}),n}return"undefined"!=typeof Map?Map:function(){function e(){this.__entries__=[]}var n={size:{}};return n.size.get=function(){return this.__entries__.length},e.prototype.get=function(e){var n=t(this.__entries__,e),r=this.__entries__[n];return r&&r[1]},e.prototype.set=function(e,n){var r=t(this.__entries__,e);~r?this.__entries__[r][1]=n:this.__entries__.push([e,n])},e.prototype.delete=function(e){var n=this.__entries__,r=t(n,e);~r&&n.splice(r,1)},e.prototype.has=function(e){return!!~t(this.__entries__,e)},e.prototype.clear=function(){this.__entries__.splice(0)},e.prototype.forEach=function(t,e){void 0===e&&(e=null);for(var n=0,r=this.__entries__;n<r.length;n+=1){var i=r[n];t.call(e,i[1],i[0])}},Object.defineProperties(e.prototype,n),e}()}(),d="undefined"!=typeof window&&"undefined"!=typeof document&&window.document===document,p=function(){return"function"==typeof requestAnimationFrame?requestAnimationFrame:function(t){return setTimeout(function(){return t(Date.now())},1e3/60)}}(),v=2,b=function(t,e){function n(){o&&(o=!1,t()),s&&i()}function r(){p(n)}function i(){var t=Date.now();if(o){if(t-c<v)return;s=!0}else o=!0,s=!1,setTimeout(r,e);c=t}var o=!1,s=!1,c=0;return i},y=["top","right","bottom","left","width","height","size","weight"],m="undefined"!=typeof navigator&&/Trident\/.*rv:11/.test(navigator.userAgent),g="undefined"!=typeof MutationObserver&&!m,E=function(){this.connected_=!1,this.mutationEventsAdded_=!1,this.mutationsObserver_=null,this.observers_=[],this.onTransitionEnd_=this.onTransitionEnd_.bind(this),this.refresh=b(this.refresh.bind(this),20)};E.prototype.addObserver=function(t){~this.observers_.indexOf(t)||this.observers_.push(t),this.connected_||this.connect_()},E.prototype.removeObserver=function(t){var e=this.observers_,n=e.indexOf(t);~n&&e.splice(n,1),!e.length&&this.connected_&&this.disconnect_()},E.prototype.refresh=function(){this.updateObservers_()&&this.refresh()},E.prototype.updateObservers_=function(){var t=this.observers_.filter(function(t){return t.gatherActive(),t.hasActive()});return t.forEach(function(t){return t.broadcastActive()}),t.length>0},E.prototype.connect_=function(){d&&!this.connected_&&(document.addEventListener("transitionend",this.onTransitionEnd_),window.addEventListener("resize",this.refresh),g?(this.mutationsObserver_=new MutationObserver(this.refresh),this.mutationsObserver_.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})):(document.addEventListener("DOMSubtreeModified",this.refresh),this.mutationEventsAdded_=!0),this.connected_=!0)},E.prototype.disconnect_=function(){d&&this.connected_&&(document.removeEventListener("transitionend",this.onTransitionEnd_),window.removeEventListener("resize",this.refresh),this.mutationsObserver_&&this.mutationsObserver_.disconnect(),this.mutationEventsAdded_&&document.removeEventListener("DOMSubtreeModified",this.refresh),this.mutationsObserver_=null,this.mutationEventsAdded_=!1,this.connected_=!1)},E.prototype.onTransitionEnd_=function(t){var e=t.propertyName;y.some(function(t){return!!~e.indexOf(t)})&&this.refresh()},E.getInstance=function(){return this.instance_||(this.instance_=new E),this.instance_},E.instance_=null;var O=function(t,e){for(var n=0,r=Object.keys(e);n<r.length;n+=1){var i=r[n];Object.defineProperty(t,i,{value:e[i],enumerable:!1,writable:!1,configurable:!0})}return t},_=f(0,0,0,0),x=function(){return"undefined"!=typeof SVGGraphicsElement?function(t){return t instanceof SVGGraphicsElement}:function(t){return t instanceof SVGElement&&"function"==typeof t.getBBox}}(),w=function(t){this.broadcastWidth=0,this.broadcastHeight=0,this.contentRect_=f(0,0,0,0),this.target=t};w.prototype.isActive=function(){var t=u(this.target);return this.contentRect_=t,t.width!==this.broadcastWidth||t.height!==this.broadcastHeight},w.prototype.broadcastRect=function(){var t=this.contentRect_;return this.broadcastWidth=t.width,this.broadcastHeight=t.height,t};var S=function(t,e){var n=l(e);O(this,{target:t,contentRect:n})},A=function(t,e,n){if("function"!=typeof t)throw new TypeError("The callback provided as parameter 1 is not a function.");this.activeObservations_=[],this.observations_=new h,this.callback_=t,this.controller_=e,this.callbackCtx_=n};A.prototype.observe=function(t){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!=typeof Element&&Element instanceof Object){if(!(t instanceof Element))throw new TypeError('parameter 1 is not of type "Element".');var e=this.observations_;e.has(t)||(e.set(t,new w(t)),this.controller_.addObserver(this),this.controller_.refresh())}},A.prototype.unobserve=function(t){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!=typeof Element&&Element instanceof Object){if(!(t instanceof Element))throw new TypeError('parameter 1 is not of type "Element".');var e=this.observations_;e.has(t)&&(e.delete(t),e.size||this.controller_.removeObserver(this))}},A.prototype.disconnect=function(){this.clearActive(),this.observations_.clear(),this.controller_.removeObserver(this)},A.prototype.gatherActive=function(){var t=this;this.clearActive(),this.observations_.forEach(function(e){e.isActive()&&t.activeObservations_.push(e)})},A.prototype.broadcastActive=function(){if(this.hasActive()){var t=this.callbackCtx_,e=this.activeObservations_.map(function(t){return new S(t.target,t.broadcastRect())});this.callback_.call(t,e,t),this.clearActive()}},A.prototype.clearActive=function(){this.activeObservations_.splice(0)},A.prototype.hasActive=function(){return this.activeObservations_.length>0};var k="undefined"!=typeof WeakMap?new WeakMap:new h,j=function(t){if(!(this instanceof j))throw new TypeError("Cannot call a class as a function");if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");var e=E.getInstance(),n=new A(t,e,this);k.set(this,n)};["observe","unobserve","disconnect"].forEach(function(t){j.prototype[t]=function(){return(e=k.get(this))[t].apply(e,arguments);var e}});var M=function(){return"undefined"!=typeof ResizeObserver?ResizeObserver:j}();e.default=M},function(t,e){},function(t,e,n){"use strict";function r(t){if(null===t||void 0===t)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(t)}/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var i=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;t.exports=function(){try{if(!Object.assign)return!1;var t=new String("abc");if(t[5]="de","5"===Object.getOwnPropertyNames(t)[0])return!1;for(var e={},n=0;n<10;n++)e["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(e).map(function(t){return e[t]}).join(""))return!1;var r={};return"abcdefghijklmnopqrst".split("").forEach(function(t){r[t]=t}),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},r)).join("")}catch(t){return!1}}()?Object.assign:function(t,e){for(var n,c,a=r(t),u=1;u<arguments.length;u++){n=Object(arguments[u]);for(var l in n)o.call(n,l)&&(a[l]=n[l]);if(i){c=i(n);for(var f=0;f<c.length;f++)s.call(n,c[f])&&(a[c[f]]=n[c[f]])}}return a}}]).default});
(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define('SnazzyInfoWindow', ['module', 'exports'], factory);
    } else if (typeof exports !== "undefined") {
        factory(module, exports);
    } else {
        var mod = {
            exports: {}
        };
        factory(mod, mod.exports);
        global.SnazzyInfoWindow = mod.exports;
    }
})(this, function (module, exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    // Global variables
    var _classPrefix = 'si-';
    var _root2 = 1.41421356237;
    var _inverseRoot2 = 0.7071067811865474;
    var _eventPrefix = 'snazzy-info-window-';
    var _defaultShadow = {
        h: '0px',
        v: '3px',
        blur: '6px',
        spread: '0px',
        color: '#000'
    };
    var _defaultOptions = {
        placement: 'top',
        pointer: true,
        openOnMarkerClick: true,
        closeOnMapClick: true,
        closeWhenOthersOpen: false,
        showCloseButton: true,
        panOnOpen: true,
        edgeOffset: {
            top: 20,
            right: 20,
            bottom: 20,
            left: 20
        }
    };

    // Copy keys from the source into the target
    function copyKeys(target, source) {
        if (target && source) {
            Object.keys(source).forEach(function (key) {
                target[key] = source[key];
            });
        }
    }

    // We need to safely merge options from the defaults. This will make
    // sure settings like edgeOffset are properly assigned.
    function mergeDefaultOptions(opts) {
        var copy = {};
        copyKeys(copy, _defaultOptions);
        copyKeys(copy, opts);
        Object.keys(_defaultOptions).forEach(function (key) {
            var obj = _defaultOptions[key];
            if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
                var objCopy = {};
                copyKeys(objCopy, obj);
                copyKeys(objCopy, copy[key]);
                copy[key] = objCopy;
            }
        });
        return copy;
    }

    // Parse a css attribute into the numeric portion and the units
    function parseAttribute(attribute, defaultValue) {
        // 1em, 1.0em, 0.1em, .1em, 1.    em
        var re = /^(-{0,1}\.{0,1}\d+(\.\d+)?)[\s|\.]*(\w*)$/;
        if (attribute && re.test(attribute)) {
            var match = re.exec(attribute);
            var number = match[1];
            var units = match[3] || 'px';
            return { value: number * 1, units: units, original: attribute };
        }
        if (defaultValue) {
            return parseAttribute(defaultValue);
        }
        return { original: defaultValue };
    }

    // Set the html of a container. Should support both raw text and a single
    // DOM Element.
    function setHTML(container, content) {
        if (container) {
            // Clear out everything in the container
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            if (content) {
                if (typeof content === 'string') {
                    container.innerHTML = content;
                } else {
                    container.appendChild(content);
                }
            }
        }
    }

    // Get the opposite of a given placement
    function oppositePlacement(p) {
        if (p === 'top') {
            return 'bottom';
        } else if (p === 'bottom') {
            return 'top';
        } else if (p === 'left') {
            return 'right';
        } else if (p === 'right') {
            return 'left';
        }
        return p;
    }

    // Return the placement with the first letter capitalized
    function capitalizePlacement(p) {
        return p.charAt(0).toUpperCase() + p.slice(1);
    }

    // Convert the value into a Google Map LatLng
    function toLatLng(v) {
        if (v !== undefined && v !== null) {
            if (v instanceof google.maps.LatLng) {
                return v;
            } else if (v.lat !== undefined && v.lng !== undefined) {
                return new google.maps.LatLng(v);
            }
        }
        return null;
    }

    // Export SnazzyInfoWindow even if google is not yet defined.
    var getGoogleClass = function getGoogleClass() {
        return typeof google !== 'undefined' ? google.maps.OverlayView : function noop() {};
    };

    var SnazzyInfoWindow = function (_getGoogleClass) {
        _inherits(SnazzyInfoWindow, _getGoogleClass);

        function SnazzyInfoWindow(opts) {
            _classCallCheck(this, SnazzyInfoWindow);

            var _this = _possibleConstructorReturn(this, (SnazzyInfoWindow.__proto__ || Object.getPrototypeOf(SnazzyInfoWindow)).call(this, opts));

            if (typeof google === 'undefined') {
                console.warn('Snazzy Info Window: Google Maps is not defined!'); //eslint-disable-line
                return _possibleConstructorReturn(_this);
            }
            // Private properties
            _this._html = null;
            _this._opts = mergeDefaultOptions(opts);
            _this._callbacks = _this._opts.callbacks || {};
            _this._marker = _this._opts.marker;
            _this._map = _this._opts.map;
            _this._position = toLatLng(_this._opts.position);
            _this._isOpen = false;
            _this._listeners = [];

            // This listener remains active when the info window is closed.
            if (_this._marker && _this._opts.openOnMarkerClick) {
                _this.trackListener(google.maps.event.addListener(_this._marker, 'click', function () {
                    if (!_this.getMap()) {
                        _this.open();
                    }
                }), true);
            }

            // When using a position the default option for the offset is 0
            if (_this._position && !_this._opts.offset) {
                _this._opts.offset = {
                    top: '0px',
                    left: '0px'
                };
            }

            // Validate the placement option
            var p = opts.placement || _this._opts.position;
            // The position variable was renamed to placement so we must type check
            if (typeof p === 'string' || p instanceof String) {
                p = p.toLowerCase();
            }
            if (p !== 'top' && p !== 'bottom' && p !== 'left' && p !== 'right') {
                _this._opts.placement = _defaultOptions.placement;
            } else {
                _this._opts.placement = p;
            }

            // Validate the position option
            p = _this._opts.position;
            if (p !== undefined && p !== null && typeof p !== 'string' && !(p instanceof String)) {
                _this._opts.position = p;
            }

            // Validate the other options
            if (_this._opts.border === undefined || _this._opts.border === true) {
                _this._opts.border = {};
            }
            if (_this._opts.pointer === undefined) {
                _this._opts.pointer = _defaultOptions.pointer;
            }
            if (_this._opts.shadow === undefined || _this._opts.shadow === true) {
                _this._opts.shadow = {};
            }
            return _this;
        }

        // Activate the specified callback and return the result


        _createClass(SnazzyInfoWindow, [{
            key: 'activateCallback',
            value: function activateCallback(callback) {
                var lambda = this._callbacks[callback];
                return lambda ? lambda.apply(this) : undefined;
            }
        }, {
            key: 'trackListener',
            value: function trackListener(listener, persistent) {
                this._listeners.push({ listener: listener, persistent: persistent });
            }
        }, {
            key: 'clearListeners',
            value: function clearListeners(clearPersistent) {
                if (this._listeners) {
                    this._listeners.forEach(function (e) {
                        if (clearPersistent || !e.persistent) {
                            google.maps.event.removeListener(e.listener);
                            e.listener = null;
                        }
                    });
                    this._listeners = this._listeners.filter(function (e) {
                        return e.listener != null;
                    });
                }
            }
        }, {
            key: 'isOpen',
            value: function isOpen() {
                return this._isOpen;
            }
        }, {
            key: 'open',
            value: function open() {
                var result = this.activateCallback('beforeOpen');
                if (result !== undefined && !result) {
                    return;
                }
                if (this._marker) {
                    this.setMap(this._marker.getMap());
                } else if (this._map && this._position) {
                    this.setMap(this._map);
                }
            }
        }, {
            key: 'close',
            value: function close() {
                var result = this.activateCallback('beforeClose');
                if (result !== undefined && !result) {
                    return;
                }
                this.clearListeners();
                this.setMap(null);
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                if (this.getMap()) {
                    this.setMap(null);
                }
                // Make sure to clear all persistent listeners
                this.clearListeners(true);
            }
        }, {
            key: 'setContent',
            value: function setContent(content) {
                this._opts.content = content;
                if (this._html && this._html.content) {
                    setHTML(this._html.content, content);
                }
            }
        }, {
            key: 'setPosition',
            value: function setPosition(latLng) {
                this._position = toLatLng(latLng);
                if (this._isOpen && this._position) {
                    this.draw();
                    this.resize();
                    this.reposition();
                }
            }
        }, {
            key: 'setWrapperClass',
            value: function setWrapperClass(wrapperClass) {
                if (this._html && this._html.wrapper) {
                    var w = this._html.wrapper;
                    w.className = _classPrefix + 'wrapper-' + this._opts.placement;
                    if (this._opts.border) {
                        w.className += ' ' + _classPrefix + 'has-border';
                    }
                    if (wrapperClass) {
                        w.className += ' ' + wrapperClass;
                    }
                }
                this._opts.wrapperClass = wrapperClass;
            }
        }, {
            key: 'getWrapper',
            value: function getWrapper() {
                if (this._html) {
                    return this._html.wrapper;
                }
                return null;
            }
        }, {
            key: 'draw',
            value: function draw() {
                if (!this.getMap() || !this._html) {
                    return;
                }
                if (!this._marker && !this._position) {
                    return;
                }

                // 1. Assign offset
                var offset = this._opts.offset;
                if (offset) {
                    if (offset.left) {
                        this._html.wrapper.style.marginLeft = offset.left;
                    }
                    if (offset.top) {
                        this._html.wrapper.style.marginTop = offset.top;
                    }
                }
                // 2. Set the background color
                var bg = this._opts.backgroundColor;
                if (bg) {
                    this._html.contentWrapper.style.backgroundColor = bg;
                    if (this._opts.pointer) {
                        this._html.pointerBg.style['border' + capitalizePlacement(this._opts.placement) + 'Color'] = bg;
                    }
                }
                // 3. Padding
                if (this._opts.padding) {
                    this._html.contentWrapper.style.padding = this._opts.padding;
                    if (this._opts.shadow) {
                        this._html.shadowFrame.style.padding = this._opts.padding;
                    }
                }
                // 4. Border radius
                if (this._opts.borderRadius) {
                    this._html.contentWrapper.style.borderRadius = this._opts.borderRadius;
                    if (this._opts.shadow) {
                        this._html.shadowFrame.style.borderRadius = this._opts.borderRadius;
                    }
                }
                // 5. Font Size
                if (this._opts.fontSize) {
                    this._html.wrapper.style.fontSize = this._opts.fontSize;
                }
                // 6. Font Color
                if (this._opts.fontColor) {
                    this._html.contentWrapper.style.color = this._opts.fontColor;
                }
                // 7. Pointer
                // Check if the pointer is enabled. Also make sure the value isn't just the boolean true.
                if (this._opts.pointer && this._opts.pointer !== true) {
                    if (this._opts.shadow) {
                        this._html.shadowPointer.style.width = this._opts.pointer;
                        this._html.shadowPointer.style.height = this._opts.pointer;
                    }
                    if (this._html.pointerBorder) {
                        this._html.pointerBorder.style.borderWidth = this._opts.pointer;
                    }
                    this._html.pointerBg.style.borderWidth = this._opts.pointer;
                }

                // 8. Border
                if (this._opts.border) {
                    // Calculate the border width
                    var bWidth = 0;
                    if (this._opts.border.width !== undefined) {
                        bWidth = parseAttribute(this._opts.border.width, '0px');
                        this._html.contentWrapper.style.borderWidth = bWidth.value + bWidth.units;
                    }
                    bWidth = Math.round((this._html.contentWrapper.offsetWidth - this._html.contentWrapper.clientWidth) / 2.0);
                    bWidth = parseAttribute(bWidth + 'px', '0px');

                    if (this._opts.pointer) {
                        // Calculate the pointer length
                        var pLength = Math.min(this._html.pointerBorder.offsetHeight, this._html.pointerBorder.offsetWidth);
                        pLength = parseAttribute(pLength + 'px', '0px');

                        var triangleDiff = Math.round(bWidth.value * (_root2 - 1));
                        triangleDiff = Math.min(triangleDiff, pLength.value);

                        this._html.pointerBg.style.borderWidth = pLength.value - triangleDiff + pLength.units;

                        var reverseP = capitalizePlacement(oppositePlacement(this._opts.placement));
                        this._html.pointerBg.style['margin' + reverseP] = triangleDiff + bWidth.units;
                        this._html.pointerBg.style[this._opts.placement] = -bWidth.value + bWidth.units;
                    }
                    var color = this._opts.border.color;
                    if (color) {
                        this._html.contentWrapper.style.borderColor = color;
                        if (this._html.pointerBorder) {
                            this._html.pointerBorder.style['border' + capitalizePlacement(this._opts.placement) + 'Color'] = color;
                        }
                    }
                }
                // 9. Shadow
                if (this._opts.shadow) {
                    // Check if any of the shadow settings have actually been set
                    var shadow = this._opts.shadow;
                    var isSet = function isSet(attribute) {
                        var v = shadow[attribute];
                        return v !== undefined && v != null;
                    };

                    if (isSet('h') || isSet('v') || isSet('blur') || isSet('spread') || isSet('color')) {
                        var hOffset = parseAttribute(shadow.h, _defaultShadow.h);
                        var vOffset = parseAttribute(shadow.v, _defaultShadow.v);
                        var blur = parseAttribute(shadow.blur, _defaultShadow.blur);
                        var spread = parseAttribute(shadow.spread, _defaultShadow.spread);
                        var _color = shadow.color || _defaultShadow.color;
                        var formatBoxShadow = function formatBoxShadow(h, v) {
                            return h + ' ' + v + ' ' + blur.original + ' ' + spread.original + ' ' + _color;
                        };

                        this._html.shadowFrame.style.boxShadow = formatBoxShadow(hOffset.original, vOffset.original);

                        // Correctly rotate the shadows before the css transform
                        var hRotated = _inverseRoot2 * (hOffset.value - vOffset.value) + hOffset.units;
                        var vRotated = _inverseRoot2 * (hOffset.value + vOffset.value) + vOffset.units;
                        if (this._html.shadowPointerInner) {
                            this._html.shadowPointerInner.style.boxShadow = formatBoxShadow(hRotated, vRotated);
                        }
                    }
                    if (this._opts.shadow.opacity) {
                        this._html.shadowWrapper.style.opacity = this._opts.shadow.opacity;
                    }
                }

                var divPixel = this.getProjection().fromLatLngToDivPixel(this._position || this._marker.position);
                if (divPixel) {
                    this._html.floatWrapper.style.top = Math.floor(divPixel.y) + 'px';
                    this._html.floatWrapper.style.left = Math.floor(divPixel.x) + 'px';
                }
                if (!this._isOpen) {
                    this._isOpen = true;
                    this.resize();
                    this.reposition();
                    this.activateCallback('afterOpen');
                    google.maps.event.trigger(this.getMap(), _eventPrefix + 'opened', this);
                }
            }
        }, {
            key: 'onAdd',
            value: function onAdd() {
                var _this2 = this;

                if (this._html) {
                    return;
                }
                // Used for creating new elements
                var applyCss = function applyCss(element, args) {
                    if (element && args) {
                        for (var i = 0; i < args.length; i++) {
                            var className = args[i];
                            if (className) {
                                if (element.className) {
                                    element.className += ' ';
                                }
                                element.className += _classPrefix + className;
                            }
                        }
                    }
                };
                var newElement = function newElement() {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }

                    var element = document.createElement('div');
                    applyCss(element, args);
                    return element;
                };

                this._html = {};

                // 1. Create the wrapper
                this._html.wrapper = newElement();
                this.setWrapperClass(this._opts.wrapperClass);

                // 2. Create the shadow
                if (this._opts.shadow) {
                    this._html.shadowWrapper = newElement('shadow-wrapper-' + this._opts.placement);
                    this._html.shadowFrame = newElement('frame', 'shadow-frame');
                    this._html.shadowWrapper.appendChild(this._html.shadowFrame);

                    if (this._opts.pointer) {
                        this._html.shadowPointer = newElement('shadow-pointer-' + this._opts.placement);
                        this._html.shadowPointerInner = newElement('shadow-inner-pointer-' + this._opts.placement);
                        this._html.shadowPointer.appendChild(this._html.shadowPointerInner);
                        this._html.shadowWrapper.appendChild(this._html.shadowPointer);
                    }

                    this._html.wrapper.appendChild(this._html.shadowWrapper);
                }

                // 3. Create the content
                this._html.contentWrapper = newElement('frame', 'content-wrapper');
                this._html.content = newElement('content');
                if (this._opts.content) {
                    setHTML(this._html.content, this._opts.content);
                }

                // 4. Create the close button
                if (this._opts.showCloseButton) {
                    if (this._opts.closeButtonMarkup) {
                        var d = document.createElement('div');
                        setHTML(d, this._opts.closeButtonMarkup);
                        this._html.closeButton = d.firstChild;
                    } else {
                        this._html.closeButton = document.createElement('button');
                        this._html.closeButton.setAttribute('type', 'button');
                        this._html.closeButton.innerHTML = '&#215;';
                        applyCss(this._html.closeButton, ['close-button']);
                    }
                    this._html.contentWrapper.appendChild(this._html.closeButton);
                }
                this._html.contentWrapper.appendChild(this._html.content);
                this._html.wrapper.appendChild(this._html.contentWrapper);

                // 5. Create the pointer
                if (this._opts.pointer) {
                    if (this._opts.border) {
                        this._html.pointerBorder = newElement('pointer-' + this._opts.placement, 'pointer-border-' + this._opts.placement);
                        this._html.wrapper.appendChild(this._html.pointerBorder);
                    }
                    this._html.pointerBg = newElement('pointer-' + this._opts.placement, 'pointer-bg-' + this._opts.placement);
                    this._html.wrapper.appendChild(this._html.pointerBg);
                }

                // Create an outer wrapper
                this._html.floatWrapper = newElement('float-wrapper');
                this._html.floatWrapper.appendChild(this._html.wrapper);

                // Add the wrapper to the Google Maps float pane
                this.getPanes().floatPane.appendChild(this._html.floatWrapper);

                // Now add all the event listeners
                var map = this.getMap();
                this.clearListeners();
                if (this._opts.closeOnMapClick) {
                    this.trackListener(google.maps.event.addListener(map, 'click', function () {
                        _this2.close();
                    }));
                }
                if (this._opts.closeWhenOthersOpen) {
                    this.trackListener(google.maps.event.addListener(map, _eventPrefix + 'opened', function (other) {
                        if (_this2 !== other) {
                            _this2.close();
                        }
                    }));
                }

                // Clear out the previous map bounds
                this._previousWidth = null;
                this._previousHeight = null;
                this.trackListener(google.maps.event.addListener(map, 'bounds_changed', function () {
                    var d = map.getDiv();
                    var ow = d.offsetWidth;
                    var oh = d.offsetHeight;
                    var pw = _this2._previousWidth;
                    var ph = _this2._previousHeight;
                    if (pw === null || ph === null || pw !== ow || ph !== oh) {
                        _this2._previousWidth = ow;
                        _this2._previousHeight = oh;
                        _this2.resize();
                    }
                }));

                // Marker moves
                if (this._marker) {
                    this.trackListener(google.maps.event.addListener(this._marker, 'position_changed', function () {
                        _this2.draw();
                    }));
                }

                // Close button
                if (this._opts.showCloseButton && !this._opts.closeButtonMarkup) {
                    this.trackListener(google.maps.event.addDomListener(this._html.closeButton, 'click', function (e) {
                        e.cancelBubble = true;
                        if (e.stopPropagation) {
                            e.stopPropagation();
                        }
                        _this2.close();
                    }));
                }

                // Stop the mouse event propagation
                var mouseEvents = ['click', 'dblclick', 'rightclick', 'contextmenu', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'touchstart', 'touchend', 'touchmove', 'wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];
                mouseEvents.forEach(function (event) {
                    _this2.trackListener(google.maps.event.addDomListener(_this2._html.wrapper, event, function (e) {
                        e.cancelBubble = true;
                        if (e.stopPropagation) {
                            e.stopPropagation();
                        }
                    }));
                });

                this.activateCallback('open');
            }
        }, {
            key: 'onRemove',
            value: function onRemove() {
                this.activateCallback('close');
                if (this._html) {
                    var parent = this._html.floatWrapper.parentElement;
                    if (parent) {
                        parent.removeChild(this._html.floatWrapper);
                    }
                    this._html = null;
                }
                this._isOpen = false;
                this.activateCallback('afterClose');
            }
        }, {
            key: 'getMapInnerBounds',
            value: function getMapInnerBounds() {
                var mb = this.getMap().getDiv().getBoundingClientRect();
                var mib = {
                    top: mb.top + this._opts.edgeOffset.top,
                    right: mb.right - this._opts.edgeOffset.right,
                    bottom: mb.bottom - this._opts.edgeOffset.bottom,
                    left: mb.left + this._opts.edgeOffset.left
                };
                mib.width = mib.right - mib.left;
                mib.height = mib.bottom - mib.top;
                return mib;
            }
        }, {
            key: 'reposition',
            value: function reposition() {
                if (!this._opts.panOnOpen || !this._html) {
                    return;
                }
                var mib = this.getMapInnerBounds();
                var wb = this._html.wrapper.getBoundingClientRect();
                var dx = 0;
                var dy = 0;
                if (mib.left >= wb.left) {
                    dx = wb.left - mib.left;
                } else if (mib.right <= wb.right) {
                    dx = wb.left - (mib.right - wb.width);
                }
                if (mib.top >= wb.top) {
                    dy = wb.top - mib.top;
                } else if (mib.bottom <= wb.bottom) {
                    dy = wb.top - (mib.bottom - wb.height);
                }
                if (dx !== 0 || dy !== 0) {
                    this.getMap().panBy(dx, dy);
                }
            }
        }, {
            key: 'resize',
            value: function resize() {
                if (!this._html) {
                    return;
                }
                var mib = this.getMapInnerBounds();
                // Handle the max width
                var maxWidth = mib.width;
                if (this._opts.maxWidth !== undefined) {
                    maxWidth = Math.min(maxWidth, this._opts.maxWidth);
                }
                maxWidth -= this._html.wrapper.offsetWidth - this._html.content.offsetWidth;
                this._html.content.style.maxWidth = maxWidth + 'px';

                // Handle the max height
                var maxHeight = mib.height;
                if (this._opts.maxHeight !== undefined) {
                    maxHeight = Math.min(maxHeight, this._opts.maxHeight);
                }
                maxHeight -= this._html.wrapper.offsetHeight - this._html.content.offsetHeight;
                this._html.content.style.maxHeight = maxHeight + 'px';
            }
        }]);

        return SnazzyInfoWindow;
    }(getGoogleClass());

    exports.default = SnazzyInfoWindow;
    module.exports = exports['default'];
});
!function e(u, c, a) {
  function s(r, t) {
    if (!c[r]) {
      if (!u[r]) {
        var n = "function" == typeof require && require;
        if (!t && n) return n(r, !0);
        if (f) return f(r, !0);
        var i = new Error("Cannot find module '" + r + "'");
        throw i.code = "MODULE_NOT_FOUND", i;
      }

      var o = c[r] = {
        exports: {}
      };
      u[r][0].call(o.exports, function (t) {
        var n = u[r][1][t];
        return s(n || t);
      }, o, o.exports, e, u, c, a);
    }

    return c[r].exports;
  }

  for (var f = "function" == typeof require && require, t = 0; t < a.length; t++) s(a[t]);

  return s;
}({
  1: [function (t, n, r) {
    "use strict";

    t(2);

    var e = function _interopRequireDefault(t) {
      return t && t.__esModule ? t : {
        default: t
      };
    }(t(15));

    e.default._babelPolyfill && "undefined" != typeof console && console.warn && console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended and may have consequences if different versions of the polyfills are applied sequentially. If you do need to load the polyfill more than once, use @babel/polyfill/noConflict instead to bypass the warning."), e.default._babelPolyfill = !0;
  }, {
    15: 15,
    2: 2
  }],
  2: [function (t, n, r) {
    "use strict";

    t(3), t(5), t(4), t(11), t(10), t(13), t(12), t(14), t(7), t(8), t(6), t(9), t(306), t(307);
  }, {
    10: 10,
    11: 11,
    12: 12,
    13: 13,
    14: 14,
    3: 3,
    306: 306,
    307: 307,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9
  }],
  3: [function (t, n, r) {
    t(278), t(214), t(216), t(215), t(218), t(220), t(225), t(219), t(217), t(227), t(226), t(222), t(223), t(221), t(213), t(224), t(228), t(229), t(180), t(182), t(181), t(231), t(230), t(201), t(211), t(212), t(202), t(203), t(204), t(205), t(206), t(207), t(208), t(209), t(210), t(184), t(185), t(186), t(187), t(188), t(189), t(190), t(191), t(192), t(193), t(194), t(195), t(196), t(197), t(198), t(199), t(200), t(265), t(270), t(277), t(268), t(260), t(261), t(266), t(271), t(273), t(256), t(257), t(258), t(259), t(262), t(263), t(264), t(267), t(269), t(272), t(274), t(275), t(276), t(175), t(177), t(176), t(179), t(178), t(163), t(161), t(168), t(165), t(171), t(173), t(160), t(167), t(157), t(172), t(155), t(170), t(169), t(162), t(166), t(154), t(156), t(159), t(158), t(174), t(164), t(247), t(248), t(254), t(249), t(250), t(251), t(252), t(253), t(232), t(183), t(255), t(290), t(291), t(279), t(280), t(285), t(288), t(289), t(283), t(286), t(284), t(287), t(281), t(282), t(233), t(234), t(235), t(236), t(237), t(240), t(238), t(239), t(241), t(242), t(243), t(244), t(246), t(245), n.exports = t(52);
  }, {
    154: 154,
    155: 155,
    156: 156,
    157: 157,
    158: 158,
    159: 159,
    160: 160,
    161: 161,
    162: 162,
    163: 163,
    164: 164,
    165: 165,
    166: 166,
    167: 167,
    168: 168,
    169: 169,
    170: 170,
    171: 171,
    172: 172,
    173: 173,
    174: 174,
    175: 175,
    176: 176,
    177: 177,
    178: 178,
    179: 179,
    180: 180,
    181: 181,
    182: 182,
    183: 183,
    184: 184,
    185: 185,
    186: 186,
    187: 187,
    188: 188,
    189: 189,
    190: 190,
    191: 191,
    192: 192,
    193: 193,
    194: 194,
    195: 195,
    196: 196,
    197: 197,
    198: 198,
    199: 199,
    200: 200,
    201: 201,
    202: 202,
    203: 203,
    204: 204,
    205: 205,
    206: 206,
    207: 207,
    208: 208,
    209: 209,
    210: 210,
    211: 211,
    212: 212,
    213: 213,
    214: 214,
    215: 215,
    216: 216,
    217: 217,
    218: 218,
    219: 219,
    220: 220,
    221: 221,
    222: 222,
    223: 223,
    224: 224,
    225: 225,
    226: 226,
    227: 227,
    228: 228,
    229: 229,
    230: 230,
    231: 231,
    232: 232,
    233: 233,
    234: 234,
    235: 235,
    236: 236,
    237: 237,
    238: 238,
    239: 239,
    240: 240,
    241: 241,
    242: 242,
    243: 243,
    244: 244,
    245: 245,
    246: 246,
    247: 247,
    248: 248,
    249: 249,
    250: 250,
    251: 251,
    252: 252,
    253: 253,
    254: 254,
    255: 255,
    256: 256,
    257: 257,
    258: 258,
    259: 259,
    260: 260,
    261: 261,
    262: 262,
    263: 263,
    264: 264,
    265: 265,
    266: 266,
    267: 267,
    268: 268,
    269: 269,
    270: 270,
    271: 271,
    272: 272,
    273: 273,
    274: 274,
    275: 275,
    276: 276,
    277: 277,
    278: 278,
    279: 279,
    280: 280,
    281: 281,
    282: 282,
    283: 283,
    284: 284,
    285: 285,
    286: 286,
    287: 287,
    288: 288,
    289: 289,
    290: 290,
    291: 291,
    52: 52
  }],
  4: [function (t, n, r) {
    t(292), n.exports = t(52).Array.flatMap;
  }, {
    292: 292,
    52: 52
  }],
  5: [function (t, n, r) {
    t(293), n.exports = t(52).Array.includes;
  }, {
    293: 293,
    52: 52
  }],
  6: [function (t, n, r) {
    t(294), n.exports = t(52).Object.entries;
  }, {
    294: 294,
    52: 52
  }],
  7: [function (t, n, r) {
    t(295), n.exports = t(52).Object.getOwnPropertyDescriptors;
  }, {
    295: 295,
    52: 52
  }],
  8: [function (t, n, r) {
    t(296), n.exports = t(52).Object.values;
  }, {
    296: 296,
    52: 52
  }],
  9: [function (t, n, r) {
    "use strict";

    t(232), t(297), n.exports = t(52).Promise.finally;
  }, {
    232: 232,
    297: 297,
    52: 52
  }],
  10: [function (t, n, r) {
    t(298), n.exports = t(52).String.padEnd;
  }, {
    298: 298,
    52: 52
  }],
  11: [function (t, n, r) {
    t(299), n.exports = t(52).String.padStart;
  }, {
    299: 299,
    52: 52
  }],
  12: [function (t, n, r) {
    t(301), n.exports = t(52).String.trimRight;
  }, {
    301: 301,
    52: 52
  }],
  13: [function (t, n, r) {
    t(300), n.exports = t(52).String.trimLeft;
  }, {
    300: 300,
    52: 52
  }],
  14: [function (t, n, r) {
    t(302), n.exports = t(151).f("asyncIterator");
  }, {
    151: 151,
    302: 302
  }],
  15: [function (t, n, r) {
    t(32), n.exports = t(18).global;
  }, {
    18: 18,
    32: 32
  }],
  16: [function (t, n, r) {
    n.exports = function (t) {
      if ("function" != typeof t) throw TypeError(t + " is not a function!");
      return t;
    };
  }, {}],
  17: [function (t, n, r) {
    var e = t(28);

    n.exports = function (t) {
      if (!e(t)) throw TypeError(t + " is not an object!");
      return t;
    };
  }, {
    28: 28
  }],
  18: [function (t, n, r) {
    var e = n.exports = {
      version: "2.6.5"
    };
    "number" == typeof __e && (__e = e);
  }, {}],
  19: [function (t, n, r) {
    var o = t(16);

    n.exports = function (e, i, t) {
      if (o(e), void 0 === i) return e;

      switch (t) {
        case 1:
          return function (t) {
            return e.call(i, t);
          };

        case 2:
          return function (t, n) {
            return e.call(i, t, n);
          };

        case 3:
          return function (t, n, r) {
            return e.call(i, t, n, r);
          };
      }

      return function () {
        return e.apply(i, arguments);
      };
    };
  }, {
    16: 16
  }],
  20: [function (t, n, r) {
    n.exports = !t(23)(function () {
      return 7 != Object.defineProperty({}, "a", {
        get: function () {
          return 7;
        }
      }).a;
    });
  }, {
    23: 23
  }],
  21: [function (t, n, r) {
    var e = t(28),
        i = t(24).document,
        o = e(i) && e(i.createElement);

    n.exports = function (t) {
      return o ? i.createElement(t) : {};
    };
  }, {
    24: 24,
    28: 28
  }],
  22: [function (t, n, r) {
    var y = t(24),
        g = t(18),
        d = t(19),
        x = t(26),
        m = t(25),
        b = "prototype",
        S = function (t, n, r) {
      var e,
          i,
          o,
          u = t & S.F,
          c = t & S.G,
          a = t & S.S,
          f = t & S.P,
          s = t & S.B,
          l = t & S.W,
          h = c ? g : g[n] || (g[n] = {}),
          p = h[b],
          v = c ? y : a ? y[n] : (y[n] || {})[b];

      for (e in c && (r = n), r) (i = !u && v && void 0 !== v[e]) && m(h, e) || (o = i ? v[e] : r[e], h[e] = c && "function" != typeof v[e] ? r[e] : s && i ? d(o, y) : l && v[e] == o ? function (e) {
        var t = function (t, n, r) {
          if (this instanceof e) {
            switch (arguments.length) {
              case 0:
                return new e();

              case 1:
                return new e(t);

              case 2:
                return new e(t, n);
            }

            return new e(t, n, r);
          }

          return e.apply(this, arguments);
        };

        return t[b] = e[b], t;
      }(o) : f && "function" == typeof o ? d(Function.call, o) : o, f && ((h.virtual || (h.virtual = {}))[e] = o, t & S.R && p && !p[e] && x(p, e, o)));
    };

    S.F = 1, S.G = 2, S.S = 4, S.P = 8, S.B = 16, S.W = 32, S.U = 64, S.R = 128, n.exports = S;
  }, {
    18: 18,
    19: 19,
    24: 24,
    25: 25,
    26: 26
  }],
  23: [function (t, n, r) {
    n.exports = function (t) {
      try {
        return !!t();
      } catch (t) {
        return !0;
      }
    };
  }, {}],
  24: [function (t, n, r) {
    var e = n.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
    "number" == typeof __g && (__g = e);
  }, {}],
  25: [function (t, n, r) {
    var e = {}.hasOwnProperty;

    n.exports = function (t, n) {
      return e.call(t, n);
    };
  }, {}],
  26: [function (t, n, r) {
    var e = t(29),
        i = t(30);
    n.exports = t(20) ? function (t, n, r) {
      return e.f(t, n, i(1, r));
    } : function (t, n, r) {
      return t[n] = r, t;
    };
  }, {
    20: 20,
    29: 29,
    30: 30
  }],
  27: [function (t, n, r) {
    n.exports = !t(20) && !t(23)(function () {
      return 7 != Object.defineProperty(t(21)("div"), "a", {
        get: function () {
          return 7;
        }
      }).a;
    });
  }, {
    20: 20,
    21: 21,
    23: 23
  }],
  28: [function (t, n, r) {
    n.exports = function (t) {
      return "object" == typeof t ? null !== t : "function" == typeof t;
    };
  }, {}],
  29: [function (t, n, r) {
    var e = t(17),
        i = t(27),
        o = t(31),
        u = Object.defineProperty;
    r.f = t(20) ? Object.defineProperty : function defineProperty(t, n, r) {
      if (e(t), n = o(n, !0), e(r), i) try {
        return u(t, n, r);
      } catch (t) {}
      if ("get" in r || "set" in r) throw TypeError("Accessors not supported!");
      return "value" in r && (t[n] = r.value), t;
    };
  }, {
    17: 17,
    20: 20,
    27: 27,
    31: 31
  }],
  30: [function (t, n, r) {
    n.exports = function (t, n) {
      return {
        enumerable: !(1 & t),
        configurable: !(2 & t),
        writable: !(4 & t),
        value: n
      };
    };
  }, {}],
  31: [function (t, n, r) {
    var i = t(28);

    n.exports = function (t, n) {
      if (!i(t)) return t;
      var r, e;
      if (n && "function" == typeof (r = t.toString) && !i(e = r.call(t))) return e;
      if ("function" == typeof (r = t.valueOf) && !i(e = r.call(t))) return e;
      if (!n && "function" == typeof (r = t.toString) && !i(e = r.call(t))) return e;
      throw TypeError("Can't convert object to primitive value");
    };
  }, {
    28: 28
  }],
  32: [function (t, n, r) {
    var e = t(22);
    e(e.G, {
      global: t(24)
    });
  }, {
    22: 22,
    24: 24
  }],
  33: [function (t, n, r) {
    arguments[4][16][0].apply(r, arguments);
  }, {
    16: 16
  }],
  34: [function (t, n, r) {
    var e = t(48);

    n.exports = function (t, n) {
      if ("number" != typeof t && "Number" != e(t)) throw TypeError(n);
      return +t;
    };
  }, {
    48: 48
  }],
  35: [function (t, n, r) {
    var e = t(152)("unscopables"),
        i = Array.prototype;
    null == i[e] && t(72)(i, e, {}), n.exports = function (t) {
      i[e][t] = !0;
    };
  }, {
    152: 152,
    72: 72
  }],
  36: [function (t, n, r) {
    "use strict";

    var e = t(129)(!0);

    n.exports = function (t, n, r) {
      return n + (r ? e(t, n).length : 1);
    };
  }, {
    129: 129
  }],
  37: [function (t, n, r) {
    n.exports = function (t, n, r, e) {
      if (!(t instanceof n) || void 0 !== e && e in t) throw TypeError(r + ": incorrect invocation!");
      return t;
    };
  }, {}],
  38: [function (t, n, r) {
    arguments[4][17][0].apply(r, arguments);
  }, {
    17: 17,
    81: 81
  }],
  39: [function (t, n, r) {
    "use strict";

    var f = t(142),
        s = t(137),
        l = t(141);

    n.exports = [].copyWithin || function copyWithin(t, n) {
      var r = f(this),
          e = l(r.length),
          i = s(t, e),
          o = s(n, e),
          u = 2 < arguments.length ? arguments[2] : void 0,
          c = Math.min((void 0 === u ? e : s(u, e)) - o, e - i),
          a = 1;

      for (o < i && i < o + c && (a = -1, o += c - 1, i += c - 1); 0 < c--;) o in r ? r[i] = r[o] : delete r[i], i += a, o += a;

      return r;
    };
  }, {
    137: 137,
    141: 141,
    142: 142
  }],
  40: [function (t, n, r) {
    "use strict";

    var c = t(142),
        a = t(137),
        f = t(141);

    n.exports = function fill(t) {
      for (var n = c(this), r = f(n.length), e = arguments.length, i = a(1 < e ? arguments[1] : void 0, r), o = 2 < e ? arguments[2] : void 0, u = void 0 === o ? r : a(o, r); i < u;) n[i++] = t;

      return n;
    };
  }, {
    137: 137,
    141: 141,
    142: 142
  }],
  41: [function (t, n, r) {
    var a = t(140),
        f = t(141),
        s = t(137);

    n.exports = function (c) {
      return function (t, n, r) {
        var e,
            i = a(t),
            o = f(i.length),
            u = s(r, o);

        if (c && n != n) {
          for (; u < o;) if ((e = i[u++]) != e) return !0;
        } else for (; u < o; u++) if ((c || u in i) && i[u] === n) return c || u || 0;

        return !c && -1;
      };
    };
  }, {
    137: 137,
    140: 140,
    141: 141
  }],
  42: [function (t, n, r) {
    var m = t(54),
        b = t(77),
        S = t(142),
        w = t(141),
        e = t(45);

    n.exports = function (l, t) {
      var h = 1 == l,
          p = 2 == l,
          v = 3 == l,
          y = 4 == l,
          g = 6 == l,
          d = 5 == l || g,
          x = t || e;
      return function (t, n, r) {
        for (var e, i, o = S(t), u = b(o), c = m(n, r, 3), a = w(u.length), f = 0, s = h ? x(t, a) : p ? x(t, 0) : void 0; f < a; f++) if ((d || f in u) && (i = c(e = u[f], f, o), l)) if (h) s[f] = i;else if (i) switch (l) {
          case 3:
            return !0;

          case 5:
            return e;

          case 6:
            return f;

          case 2:
            s.push(e);
        } else if (y) return !1;

        return g ? -1 : v || y ? y : s;
      };
    };
  }, {
    141: 141,
    142: 142,
    45: 45,
    54: 54,
    77: 77
  }],
  43: [function (t, n, r) {
    var s = t(33),
        l = t(142),
        h = t(77),
        p = t(141);

    n.exports = function (t, n, r, e, i) {
      s(n);
      var o = l(t),
          u = h(o),
          c = p(o.length),
          a = i ? c - 1 : 0,
          f = i ? -1 : 1;
      if (r < 2) for (;;) {
        if (a in u) {
          e = u[a], a += f;
          break;
        }

        if (a += f, i ? a < 0 : c <= a) throw TypeError("Reduce of empty array with no initial value");
      }

      for (; i ? 0 <= a : a < c; a += f) a in u && (e = n(e, u[a], a, o));

      return e;
    };
  }, {
    141: 141,
    142: 142,
    33: 33,
    77: 77
  }],
  44: [function (t, n, r) {
    var e = t(81),
        i = t(79),
        o = t(152)("species");

    n.exports = function (t) {
      var n;
      return i(t) && ("function" != typeof (n = t.constructor) || n !== Array && !i(n.prototype) || (n = void 0), e(n) && null === (n = n[o]) && (n = void 0)), void 0 === n ? Array : n;
    };
  }, {
    152: 152,
    79: 79,
    81: 81
  }],
  45: [function (t, n, r) {
    var e = t(44);

    n.exports = function (t, n) {
      return new (e(t))(n);
    };
  }, {
    44: 44
  }],
  46: [function (t, n, r) {
    "use strict";

    var o = t(33),
        u = t(81),
        c = t(76),
        a = [].slice,
        f = {};

    n.exports = Function.bind || function bind(n) {
      var r = o(this),
          e = a.call(arguments, 1),
          i = function () {
        var t = e.concat(a.call(arguments));
        return this instanceof i ? function (t, n, r) {
          if (!(n in f)) {
            for (var e = [], i = 0; i < n; i++) e[i] = "a[" + i + "]";

            f[n] = Function("F,a", "return new F(" + e.join(",") + ")");
          }

          return f[n](t, r);
        }(r, t.length, t) : c(r, t, n);
      };

      return u(r.prototype) && (i.prototype = r.prototype), i;
    };
  }, {
    33: 33,
    76: 76,
    81: 81
  }],
  47: [function (t, n, r) {
    var i = t(48),
        o = t(152)("toStringTag"),
        u = "Arguments" == i(function () {
      return arguments;
    }());

    n.exports = function (t) {
      var n, r, e;
      return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (r = function (t, n) {
        try {
          return t[n];
        } catch (t) {}
      }(n = Object(t), o)) ? r : u ? i(n) : "Object" == (e = i(n)) && "function" == typeof n.callee ? "Arguments" : e;
    };
  }, {
    152: 152,
    48: 48
  }],
  48: [function (t, n, r) {
    var e = {}.toString;

    n.exports = function (t) {
      return e.call(t).slice(8, -1);
    };
  }, {}],
  49: [function (t, n, r) {
    "use strict";

    var u = t(99).f,
        c = t(98),
        a = t(117),
        f = t(54),
        s = t(37),
        l = t(68),
        e = t(85),
        i = t(87),
        o = t(123),
        h = t(58),
        p = t(94).fastKey,
        v = t(149),
        y = h ? "_s" : "size",
        g = function (t, n) {
      var r,
          e = p(n);
      if ("F" !== e) return t._i[e];

      for (r = t._f; r; r = r.n) if (r.k == n) return r;
    };

    n.exports = {
      getConstructor: function (t, o, r, e) {
        var i = t(function (t, n) {
          s(t, i, o, "_i"), t._t = o, t._i = c(null), t._f = void 0, t._l = void 0, t[y] = 0, null != n && l(n, r, t[e], t);
        });
        return a(i.prototype, {
          clear: function clear() {
            for (var t = v(this, o), n = t._i, r = t._f; r; r = r.n) r.r = !0, r.p && (r.p = r.p.n = void 0), delete n[r.i];

            t._f = t._l = void 0, t[y] = 0;
          },
          delete: function (t) {
            var n = v(this, o),
                r = g(n, t);

            if (r) {
              var e = r.n,
                  i = r.p;
              delete n._i[r.i], r.r = !0, i && (i.n = e), e && (e.p = i), n._f == r && (n._f = e), n._l == r && (n._l = i), n[y]--;
            }

            return !!r;
          },
          forEach: function forEach(t) {
            v(this, o);

            for (var n, r = f(t, 1 < arguments.length ? arguments[1] : void 0, 3); n = n ? n.n : this._f;) for (r(n.v, n.k, this); n && n.r;) n = n.p;
          },
          has: function has(t) {
            return !!g(v(this, o), t);
          }
        }), h && u(i.prototype, "size", {
          get: function () {
            return v(this, o)[y];
          }
        }), i;
      },
      def: function (t, n, r) {
        var e,
            i,
            o = g(t, n);
        return o ? o.v = r : (t._l = o = {
          i: i = p(n, !0),
          k: n,
          v: r,
          p: e = t._l,
          n: void 0,
          r: !1
        }, t._f || (t._f = o), e && (e.n = o), t[y]++, "F" !== i && (t._i[i] = o)), t;
      },
      getEntry: g,
      setStrong: function (t, r, n) {
        e(t, r, function (t, n) {
          this._t = v(t, r), this._k = n, this._l = void 0;
        }, function () {
          for (var t = this, n = t._k, r = t._l; r && r.r;) r = r.p;

          return t._t && (t._l = r = r ? r.n : t._t._f) ? i(0, "keys" == n ? r.k : "values" == n ? r.v : [r.k, r.v]) : (t._t = void 0, i(1));
        }, n ? "entries" : "values", !n, !0), o(r);
      }
    };
  }, {
    117: 117,
    123: 123,
    149: 149,
    37: 37,
    54: 54,
    58: 58,
    68: 68,
    85: 85,
    87: 87,
    94: 94,
    98: 98,
    99: 99
  }],
  50: [function (t, n, r) {
    "use strict";

    var u = t(117),
        c = t(94).getWeak,
        i = t(38),
        a = t(81),
        f = t(37),
        s = t(68),
        e = t(42),
        l = t(71),
        h = t(149),
        o = e(5),
        p = e(6),
        v = 0,
        y = function (t) {
      return t._l || (t._l = new g());
    },
        g = function () {
      this.a = [];
    },
        d = function (t, n) {
      return o(t.a, function (t) {
        return t[0] === n;
      });
    };

    g.prototype = {
      get: function (t) {
        var n = d(this, t);
        if (n) return n[1];
      },
      has: function (t) {
        return !!d(this, t);
      },
      set: function (t, n) {
        var r = d(this, t);
        r ? r[1] = n : this.a.push([t, n]);
      },
      delete: function (n) {
        var t = p(this.a, function (t) {
          return t[0] === n;
        });
        return ~t && this.a.splice(t, 1), !!~t;
      }
    }, n.exports = {
      getConstructor: function (t, r, e, i) {
        var o = t(function (t, n) {
          f(t, o, r, "_i"), t._t = r, t._i = v++, t._l = void 0, null != n && s(n, e, t[i], t);
        });
        return u(o.prototype, {
          delete: function (t) {
            if (!a(t)) return !1;
            var n = c(t);
            return !0 === n ? y(h(this, r)).delete(t) : n && l(n, this._i) && delete n[this._i];
          },
          has: function has(t) {
            if (!a(t)) return !1;
            var n = c(t);
            return !0 === n ? y(h(this, r)).has(t) : n && l(n, this._i);
          }
        }), o;
      },
      def: function (t, n, r) {
        var e = c(i(n), !0);
        return !0 === e ? y(t).set(n, r) : e[t._i] = r, t;
      },
      ufstore: y
    };
  }, {
    117: 117,
    149: 149,
    37: 37,
    38: 38,
    42: 42,
    68: 68,
    71: 71,
    81: 81,
    94: 94
  }],
  51: [function (t, n, r) {
    "use strict";

    var d = t(70),
        x = t(62),
        m = t(118),
        b = t(117),
        S = t(94),
        w = t(68),
        _ = t(37),
        E = t(81),
        F = t(64),
        I = t(86),
        O = t(124),
        P = t(75);

    n.exports = function (e, t, n, r, i, o) {
      var u = d[e],
          c = u,
          a = i ? "set" : "add",
          f = c && c.prototype,
          s = {},
          l = function (t) {
        var r = f[t];
        m(f, t, "delete" == t ? function (t) {
          return !(o && !E(t)) && r.call(this, 0 === t ? 0 : t);
        } : "has" == t ? function has(t) {
          return !(o && !E(t)) && r.call(this, 0 === t ? 0 : t);
        } : "get" == t ? function get(t) {
          return o && !E(t) ? void 0 : r.call(this, 0 === t ? 0 : t);
        } : "add" == t ? function add(t) {
          return r.call(this, 0 === t ? 0 : t), this;
        } : function set(t, n) {
          return r.call(this, 0 === t ? 0 : t, n), this;
        });
      };

      if ("function" == typeof c && (o || f.forEach && !F(function () {
        new c().entries().next();
      }))) {
        var h = new c(),
            p = h[a](o ? {} : -0, 1) != h,
            v = F(function () {
          h.has(1);
        }),
            y = I(function (t) {
          new c(t);
        }),
            g = !o && F(function () {
          for (var t = new c(), n = 5; n--;) t[a](n, n);

          return !t.has(-0);
        });
        y || (((c = t(function (t, n) {
          _(t, c, e);

          var r = P(new u(), t, c);
          return null != n && w(n, i, r[a], r), r;
        })).prototype = f).constructor = c), (v || g) && (l("delete"), l("has"), i && l("get")), (g || p) && l(a), o && f.clear && delete f.clear;
      } else c = r.getConstructor(t, e, i, a), b(c.prototype, n), S.NEED = !0;

      return O(c, e), s[e] = c, x(x.G + x.W + x.F * (c != u), s), o || r.setStrong(c, e, i), c;
    };
  }, {
    117: 117,
    118: 118,
    124: 124,
    37: 37,
    62: 62,
    64: 64,
    68: 68,
    70: 70,
    75: 75,
    81: 81,
    86: 86,
    94: 94
  }],
  52: [function (t, n, r) {
    arguments[4][18][0].apply(r, arguments);
  }, {
    18: 18
  }],
  53: [function (t, n, r) {
    "use strict";

    var e = t(99),
        i = t(116);

    n.exports = function (t, n, r) {
      n in t ? e.f(t, n, i(0, r)) : t[n] = r;
    };
  }, {
    116: 116,
    99: 99
  }],
  54: [function (t, n, r) {
    arguments[4][19][0].apply(r, arguments);
  }, {
    19: 19,
    33: 33
  }],
  55: [function (t, n, r) {
    "use strict";

    var e = t(64),
        i = Date.prototype.getTime,
        o = Date.prototype.toISOString,
        u = function (t) {
      return 9 < t ? t : "0" + t;
    };

    n.exports = e(function () {
      return "0385-07-25T07:06:39.999Z" != o.call(new Date(-5e13 - 1));
    }) || !e(function () {
      o.call(new Date(NaN));
    }) ? function toISOString() {
      if (!isFinite(i.call(this))) throw RangeError("Invalid time value");
      var t = this,
          n = t.getUTCFullYear(),
          r = t.getUTCMilliseconds(),
          e = n < 0 ? "-" : 9999 < n ? "+" : "";
      return e + ("00000" + Math.abs(n)).slice(e ? -6 : -4) + "-" + u(t.getUTCMonth() + 1) + "-" + u(t.getUTCDate()) + "T" + u(t.getUTCHours()) + ":" + u(t.getUTCMinutes()) + ":" + u(t.getUTCSeconds()) + "." + (99 < r ? r : "0" + u(r)) + "Z";
    } : o;
  }, {
    64: 64
  }],
  56: [function (t, n, r) {
    "use strict";

    var e = t(38),
        i = t(143);

    n.exports = function (t) {
      if ("string" !== t && "number" !== t && "default" !== t) throw TypeError("Incorrect hint");
      return i(e(this), "number" != t);
    };
  }, {
    143: 143,
    38: 38
  }],
  57: [function (t, n, r) {
    n.exports = function (t) {
      if (null == t) throw TypeError("Can't call method on  " + t);
      return t;
    };
  }, {}],
  58: [function (t, n, r) {
    arguments[4][20][0].apply(r, arguments);
  }, {
    20: 20,
    64: 64
  }],
  59: [function (t, n, r) {
    arguments[4][21][0].apply(r, arguments);
  }, {
    21: 21,
    70: 70,
    81: 81
  }],
  60: [function (t, n, r) {
    n.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
  }, {}],
  61: [function (t, n, r) {
    var c = t(107),
        a = t(104),
        f = t(108);

    n.exports = function (t) {
      var n = c(t),
          r = a.f;
      if (r) for (var e, i = r(t), o = f.f, u = 0; i.length > u;) o.call(t, e = i[u++]) && n.push(e);
      return n;
    };
  }, {
    104: 104,
    107: 107,
    108: 108
  }],
  62: [function (t, n, r) {
    var y = t(70),
        g = t(52),
        d = t(72),
        x = t(118),
        m = t(54),
        b = "prototype",
        S = function (t, n, r) {
      var e,
          i,
          o,
          u,
          c = t & S.F,
          a = t & S.G,
          f = t & S.S,
          s = t & S.P,
          l = t & S.B,
          h = a ? y : f ? y[n] || (y[n] = {}) : (y[n] || {})[b],
          p = a ? g : g[n] || (g[n] = {}),
          v = p[b] || (p[b] = {});

      for (e in a && (r = n), r) o = ((i = !c && h && void 0 !== h[e]) ? h : r)[e], u = l && i ? m(o, y) : s && "function" == typeof o ? m(Function.call, o) : o, h && x(h, e, o, t & S.U), p[e] != o && d(p, e, u), s && v[e] != o && (v[e] = o);
    };

    y.core = g, S.F = 1, S.G = 2, S.S = 4, S.P = 8, S.B = 16, S.W = 32, S.U = 64, S.R = 128, n.exports = S;
  }, {
    118: 118,
    52: 52,
    54: 54,
    70: 70,
    72: 72
  }],
  63: [function (t, n, r) {
    var e = t(152)("match");

    n.exports = function (n) {
      var r = /./;

      try {
        "/./"[n](r);
      } catch (t) {
        try {
          return r[e] = !1, !"/./"[n](r);
        } catch (t) {}
      }

      return !0;
    };
  }, {
    152: 152
  }],
  64: [function (t, n, r) {
    arguments[4][23][0].apply(r, arguments);
  }, {
    23: 23
  }],
  65: [function (t, n, r) {
    "use strict";

    t(248);

    var s = t(118),
        l = t(72),
        h = t(64),
        p = t(57),
        v = t(152),
        y = t(120),
        g = v("species"),
        d = !h(function () {
      var t = /./;
      return t.exec = function () {
        var t = [];
        return t.groups = {
          a: "7"
        }, t;
      }, "7" !== "".replace(t, "$<a>");
    }),
        x = function () {
      var t = /(?:)/,
          n = t.exec;

      t.exec = function () {
        return n.apply(this, arguments);
      };

      var r = "ab".split(t);
      return 2 === r.length && "a" === r[0] && "b" === r[1];
    }();

    n.exports = function (r, t, n) {
      var e = v(r),
          o = !h(function () {
        var t = {};
        return t[e] = function () {
          return 7;
        }, 7 != ""[r](t);
      }),
          i = o ? !h(function () {
        var t = !1,
            n = /a/;
        return n.exec = function () {
          return t = !0, null;
        }, "split" === r && (n.constructor = {}, n.constructor[g] = function () {
          return n;
        }), n[e](""), !t;
      }) : void 0;

      if (!o || !i || "replace" === r && !d || "split" === r && !x) {
        var u = /./[e],
            c = n(p, e, ""[r], function maybeCallNative(t, n, r, e, i) {
          return n.exec === y ? o && !i ? {
            done: !0,
            value: u.call(n, r, e)
          } : {
            done: !0,
            value: t.call(r, n, e)
          } : {
            done: !1
          };
        }),
            a = c[0],
            f = c[1];
        s(String.prototype, r, a), l(RegExp.prototype, e, 2 == t ? function (t, n) {
          return f.call(t, this, n);
        } : function (t) {
          return f.call(t, this);
        });
      }
    };
  }, {
    118: 118,
    120: 120,
    152: 152,
    248: 248,
    57: 57,
    64: 64,
    72: 72
  }],
  66: [function (t, n, r) {
    "use strict";

    var e = t(38);

    n.exports = function () {
      var t = e(this),
          n = "";
      return t.global && (n += "g"), t.ignoreCase && (n += "i"), t.multiline && (n += "m"), t.unicode && (n += "u"), t.sticky && (n += "y"), n;
    };
  }, {
    38: 38
  }],
  67: [function (t, n, r) {
    "use strict";

    var p = t(79),
        v = t(81),
        y = t(141),
        g = t(54),
        d = t(152)("isConcatSpreadable");

    n.exports = function flattenIntoArray(t, n, r, e, i, o, u, c) {
      for (var a, f, s = i, l = 0, h = !!u && g(u, c, 3); l < e;) {
        if (l in r) {
          if (a = h ? h(r[l], l, n) : r[l], f = !1, v(a) && (f = void 0 !== (f = a[d]) ? !!f : p(a)), f && 0 < o) s = flattenIntoArray(t, n, a, y(a.length), s, o - 1) - 1;else {
            if (9007199254740991 <= s) throw TypeError();
            t[s] = a;
          }
          s++;
        }

        l++;
      }

      return s;
    };
  }, {
    141: 141,
    152: 152,
    54: 54,
    79: 79,
    81: 81
  }],
  68: [function (t, n, r) {
    var h = t(54),
        p = t(83),
        v = t(78),
        y = t(38),
        g = t(141),
        d = t(153),
        x = {},
        m = {};
    (r = n.exports = function (t, n, r, e, i) {
      var o,
          u,
          c,
          a,
          f = i ? function () {
        return t;
      } : d(t),
          s = h(r, e, n ? 2 : 1),
          l = 0;
      if ("function" != typeof f) throw TypeError(t + " is not iterable!");

      if (v(f)) {
        for (o = g(t.length); l < o; l++) if ((a = n ? s(y(u = t[l])[0], u[1]) : s(t[l])) === x || a === m) return a;
      } else for (c = f.call(t); !(u = c.next()).done;) if ((a = p(c, s, u.value, n)) === x || a === m) return a;
    }).BREAK = x, r.RETURN = m;
  }, {
    141: 141,
    153: 153,
    38: 38,
    54: 54,
    78: 78,
    83: 83
  }],
  69: [function (t, n, r) {
    n.exports = t(126)("native-function-to-string", Function.toString);
  }, {
    126: 126
  }],
  70: [function (t, n, r) {
    arguments[4][24][0].apply(r, arguments);
  }, {
    24: 24
  }],
  71: [function (t, n, r) {
    arguments[4][25][0].apply(r, arguments);
  }, {
    25: 25
  }],
  72: [function (t, n, r) {
    arguments[4][26][0].apply(r, arguments);
  }, {
    116: 116,
    26: 26,
    58: 58,
    99: 99
  }],
  73: [function (t, n, r) {
    var e = t(70).document;
    n.exports = e && e.documentElement;
  }, {
    70: 70
  }],
  74: [function (t, n, r) {
    arguments[4][27][0].apply(r, arguments);
  }, {
    27: 27,
    58: 58,
    59: 59,
    64: 64
  }],
  75: [function (t, n, r) {
    var o = t(81),
        u = t(122).set;

    n.exports = function (t, n, r) {
      var e,
          i = n.constructor;
      return i !== r && "function" == typeof i && (e = i.prototype) !== r.prototype && o(e) && u && u(t, e), t;
    };
  }, {
    122: 122,
    81: 81
  }],
  76: [function (t, n, r) {
    n.exports = function (t, n, r) {
      var e = void 0 === r;

      switch (n.length) {
        case 0:
          return e ? t() : t.call(r);

        case 1:
          return e ? t(n[0]) : t.call(r, n[0]);

        case 2:
          return e ? t(n[0], n[1]) : t.call(r, n[0], n[1]);

        case 3:
          return e ? t(n[0], n[1], n[2]) : t.call(r, n[0], n[1], n[2]);

        case 4:
          return e ? t(n[0], n[1], n[2], n[3]) : t.call(r, n[0], n[1], n[2], n[3]);
      }

      return t.apply(r, n);
    };
  }, {}],
  77: [function (t, n, r) {
    var e = t(48);
    n.exports = Object("z").propertyIsEnumerable(0) ? Object : function (t) {
      return "String" == e(t) ? t.split("") : Object(t);
    };
  }, {
    48: 48
  }],
  78: [function (t, n, r) {
    var e = t(88),
        i = t(152)("iterator"),
        o = Array.prototype;

    n.exports = function (t) {
      return void 0 !== t && (e.Array === t || o[i] === t);
    };
  }, {
    152: 152,
    88: 88
  }],
  79: [function (t, n, r) {
    var e = t(48);

    n.exports = Array.isArray || function isArray(t) {
      return "Array" == e(t);
    };
  }, {
    48: 48
  }],
  80: [function (t, n, r) {
    var e = t(81),
        i = Math.floor;

    n.exports = function isInteger(t) {
      return !e(t) && isFinite(t) && i(t) === t;
    };
  }, {
    81: 81
  }],
  81: [function (t, n, r) {
    arguments[4][28][0].apply(r, arguments);
  }, {
    28: 28
  }],
  82: [function (t, n, r) {
    var e = t(81),
        i = t(48),
        o = t(152)("match");

    n.exports = function (t) {
      var n;
      return e(t) && (void 0 !== (n = t[o]) ? !!n : "RegExp" == i(t));
    };
  }, {
    152: 152,
    48: 48,
    81: 81
  }],
  83: [function (t, n, r) {
    var o = t(38);

    n.exports = function (n, t, r, e) {
      try {
        return e ? t(o(r)[0], r[1]) : t(r);
      } catch (t) {
        var i = n.return;
        throw void 0 !== i && o(i.call(n)), t;
      }
    };
  }, {
    38: 38
  }],
  84: [function (t, n, r) {
    "use strict";

    var e = t(98),
        i = t(116),
        o = t(124),
        u = {};
    t(72)(u, t(152)("iterator"), function () {
      return this;
    }), n.exports = function (t, n, r) {
      t.prototype = e(u, {
        next: i(1, r)
      }), o(t, n + " Iterator");
    };
  }, {
    116: 116,
    124: 124,
    152: 152,
    72: 72,
    98: 98
  }],
  85: [function (t, n, r) {
    "use strict";

    var m = t(89),
        b = t(62),
        S = t(118),
        w = t(72),
        _ = t(88),
        E = t(84),
        F = t(124),
        I = t(105),
        O = t(152)("iterator"),
        P = !([].keys && "next" in [].keys()),
        A = "values",
        M = function () {
      return this;
    };

    n.exports = function (t, n, r, e, i, o, u) {
      E(r, n, e);

      var c,
          a,
          f,
          s = function (t) {
        if (!P && t in v) return v[t];

        switch (t) {
          case "keys":
            return function keys() {
              return new r(this, t);
            };

          case A:
            return function values() {
              return new r(this, t);
            };
        }

        return function entries() {
          return new r(this, t);
        };
      },
          l = n + " Iterator",
          h = i == A,
          p = !1,
          v = t.prototype,
          y = v[O] || v["@@iterator"] || i && v[i],
          g = y || s(i),
          d = i ? h ? s("entries") : g : void 0,
          x = "Array" == n && v.entries || y;

      if (x && (f = I(x.call(new t()))) !== Object.prototype && f.next && (F(f, l, !0), m || "function" == typeof f[O] || w(f, O, M)), h && y && y.name !== A && (p = !0, g = function values() {
        return y.call(this);
      }), m && !u || !P && !p && v[O] || w(v, O, g), _[n] = g, _[l] = M, i) if (c = {
        values: h ? g : s(A),
        keys: o ? g : s("keys"),
        entries: d
      }, u) for (a in c) a in v || S(v, a, c[a]);else b(b.P + b.F * (P || p), n, c);
      return c;
    };
  }, {
    105: 105,
    118: 118,
    124: 124,
    152: 152,
    62: 62,
    72: 72,
    84: 84,
    88: 88,
    89: 89
  }],
  86: [function (t, n, r) {
    var o = t(152)("iterator"),
        u = !1;

    try {
      var e = [7][o]();
      e.return = function () {
        u = !0;
      }, Array.from(e, function () {
        throw 2;
      });
    } catch (t) {}

    n.exports = function (t, n) {
      if (!n && !u) return !1;
      var r = !1;

      try {
        var e = [7],
            i = e[o]();
        i.next = function () {
          return {
            done: r = !0
          };
        }, e[o] = function () {
          return i;
        }, t(e);
      } catch (t) {}

      return r;
    };
  }, {
    152: 152
  }],
  87: [function (t, n, r) {
    n.exports = function (t, n) {
      return {
        value: n,
        done: !!t
      };
    };
  }, {}],
  88: [function (t, n, r) {
    n.exports = {};
  }, {}],
  89: [function (t, n, r) {
    n.exports = !1;
  }, {}],
  90: [function (t, n, r) {
    var e = Math.expm1;
    n.exports = !e || 22025.465794806718 < e(10) || e(10) < 22025.465794806718 || -2e-17 != e(-2e-17) ? function expm1(t) {
      return 0 == (t = +t) ? t : -1e-6 < t && t < 1e-6 ? t + t * t / 2 : Math.exp(t) - 1;
    } : e;
  }, {}],
  91: [function (t, n, r) {
    var o = t(93),
        e = Math.pow,
        u = e(2, -52),
        c = e(2, -23),
        a = e(2, 127) * (2 - c),
        f = e(2, -126);

    n.exports = Math.fround || function fround(t) {
      var n,
          r,
          e = Math.abs(t),
          i = o(t);
      return e < f ? i * (e / f / c + 1 / u - 1 / u) * f * c : a < (r = (n = (1 + c / u) * e) - (n - e)) || r != r ? i * (1 / 0) : i * r;
    };
  }, {
    93: 93
  }],
  92: [function (t, n, r) {
    n.exports = Math.log1p || function log1p(t) {
      return -1e-8 < (t = +t) && t < 1e-8 ? t - t * t / 2 : Math.log(1 + t);
    };
  }, {}],
  93: [function (t, n, r) {
    n.exports = Math.sign || function sign(t) {
      return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1;
    };
  }, {}],
  94: [function (t, n, r) {
    var e = t(147)("meta"),
        i = t(81),
        o = t(71),
        u = t(99).f,
        c = 0,
        a = Object.isExtensible || function () {
      return !0;
    },
        f = !t(64)(function () {
      return a(Object.preventExtensions({}));
    }),
        s = function (t) {
      u(t, e, {
        value: {
          i: "O" + ++c,
          w: {}
        }
      });
    },
        l = n.exports = {
      KEY: e,
      NEED: !1,
      fastKey: function (t, n) {
        if (!i(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;

        if (!o(t, e)) {
          if (!a(t)) return "F";
          if (!n) return "E";
          s(t);
        }

        return t[e].i;
      },
      getWeak: function (t, n) {
        if (!o(t, e)) {
          if (!a(t)) return !0;
          if (!n) return !1;
          s(t);
        }

        return t[e].w;
      },
      onFreeze: function (t) {
        return f && l.NEED && a(t) && !o(t, e) && s(t), t;
      }
    };
  }, {
    147: 147,
    64: 64,
    71: 71,
    81: 81,
    99: 99
  }],
  95: [function (t, n, r) {
    var c = t(70),
        a = t(136).set,
        f = c.MutationObserver || c.WebKitMutationObserver,
        s = c.process,
        l = c.Promise,
        h = "process" == t(48)(s);

    n.exports = function () {
      var r,
          e,
          i,
          t = function () {
        var t, n;

        for (h && (t = s.domain) && t.exit(); r;) {
          n = r.fn, r = r.next;

          try {
            n();
          } catch (t) {
            throw r ? i() : e = void 0, t;
          }
        }

        e = void 0, t && t.enter();
      };

      if (h) i = function () {
        s.nextTick(t);
      };else if (!f || c.navigator && c.navigator.standalone) {
        if (l && l.resolve) {
          var n = l.resolve(void 0);

          i = function () {
            n.then(t);
          };
        } else i = function () {
          a.call(c, t);
        };
      } else {
        var o = !0,
            u = document.createTextNode("");
        new f(t).observe(u, {
          characterData: !0
        }), i = function () {
          u.data = o = !o;
        };
      }
      return function (t) {
        var n = {
          fn: t,
          next: void 0
        };
        e && (e.next = n), r || (r = n, i()), e = n;
      };
    };
  }, {
    136: 136,
    48: 48,
    70: 70
  }],
  96: [function (t, n, r) {
    "use strict";

    var i = t(33);

    function PromiseCapability(t) {
      var r, e;
      this.promise = new t(function (t, n) {
        if (void 0 !== r || void 0 !== e) throw TypeError("Bad Promise constructor");
        r = t, e = n;
      }), this.resolve = i(r), this.reject = i(e);
    }

    n.exports.f = function (t) {
      return new PromiseCapability(t);
    };
  }, {
    33: 33
  }],
  97: [function (t, n, r) {
    "use strict";

    var h = t(107),
        p = t(104),
        v = t(108),
        y = t(142),
        g = t(77),
        i = Object.assign;
    n.exports = !i || t(64)(function () {
      var t = {},
          n = {},
          r = Symbol(),
          e = "abcdefghijklmnopqrst";
      return t[r] = 7, e.split("").forEach(function (t) {
        n[t] = t;
      }), 7 != i({}, t)[r] || Object.keys(i({}, n)).join("") != e;
    }) ? function assign(t, n) {
      for (var r = y(t), e = arguments.length, i = 1, o = p.f, u = v.f; i < e;) for (var c, a = g(arguments[i++]), f = o ? h(a).concat(o(a)) : h(a), s = f.length, l = 0; l < s;) u.call(a, c = f[l++]) && (r[c] = a[c]);

      return r;
    } : i;
  }, {
    104: 104,
    107: 107,
    108: 108,
    142: 142,
    64: 64,
    77: 77
  }],
  98: [function (e, t, n) {
    var i = e(38),
        o = e(100),
        u = e(60),
        c = e(125)("IE_PROTO"),
        a = function () {},
        f = "prototype",
        s = function () {
      var t,
          n = e(59)("iframe"),
          r = u.length;

      for (n.style.display = "none", e(73).appendChild(n), n.src = "javascript:", (t = n.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), s = t.F; r--;) delete s[f][u[r]];

      return s();
    };

    t.exports = Object.create || function create(t, n) {
      var r;
      return null !== t ? (a[f] = i(t), r = new a(), a[f] = null, r[c] = t) : r = s(), void 0 === n ? r : o(r, n);
    };
  }, {
    100: 100,
    125: 125,
    38: 38,
    59: 59,
    60: 60,
    73: 73
  }],
  99: [function (t, n, r) {
    arguments[4][29][0].apply(r, arguments);
  }, {
    143: 143,
    29: 29,
    38: 38,
    58: 58,
    74: 74
  }],
  100: [function (t, n, r) {
    var u = t(99),
        c = t(38),
        a = t(107);
    n.exports = t(58) ? Object.defineProperties : function defineProperties(t, n) {
      c(t);

      for (var r, e = a(n), i = e.length, o = 0; o < i;) u.f(t, r = e[o++], n[r]);

      return t;
    };
  }, {
    107: 107,
    38: 38,
    58: 58,
    99: 99
  }],
  101: [function (t, n, r) {
    var e = t(108),
        i = t(116),
        o = t(140),
        u = t(143),
        c = t(71),
        a = t(74),
        f = Object.getOwnPropertyDescriptor;
    r.f = t(58) ? f : function getOwnPropertyDescriptor(t, n) {
      if (t = o(t), n = u(n, !0), a) try {
        return f(t, n);
      } catch (t) {}
      if (c(t, n)) return i(!e.f.call(t, n), t[n]);
    };
  }, {
    108: 108,
    116: 116,
    140: 140,
    143: 143,
    58: 58,
    71: 71,
    74: 74
  }],
  102: [function (t, n, r) {
    var e = t(140),
        i = t(103).f,
        o = {}.toString,
        u = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

    n.exports.f = function getOwnPropertyNames(t) {
      return u && "[object Window]" == o.call(t) ? function (t) {
        try {
          return i(t);
        } catch (t) {
          return u.slice();
        }
      }(t) : i(e(t));
    };
  }, {
    103: 103,
    140: 140
  }],
  103: [function (t, n, r) {
    var e = t(106),
        i = t(60).concat("length", "prototype");

    r.f = Object.getOwnPropertyNames || function getOwnPropertyNames(t) {
      return e(t, i);
    };
  }, {
    106: 106,
    60: 60
  }],
  104: [function (t, n, r) {
    r.f = Object.getOwnPropertySymbols;
  }, {}],
  105: [function (t, n, r) {
    var e = t(71),
        i = t(142),
        o = t(125)("IE_PROTO"),
        u = Object.prototype;

    n.exports = Object.getPrototypeOf || function (t) {
      return t = i(t), e(t, o) ? t[o] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? u : null;
    };
  }, {
    125: 125,
    142: 142,
    71: 71
  }],
  106: [function (t, n, r) {
    var u = t(71),
        c = t(140),
        a = t(41)(!1),
        f = t(125)("IE_PROTO");

    n.exports = function (t, n) {
      var r,
          e = c(t),
          i = 0,
          o = [];

      for (r in e) r != f && u(e, r) && o.push(r);

      for (; n.length > i;) u(e, r = n[i++]) && (~a(o, r) || o.push(r));

      return o;
    };
  }, {
    125: 125,
    140: 140,
    41: 41,
    71: 71
  }],
  107: [function (t, n, r) {
    var e = t(106),
        i = t(60);

    n.exports = Object.keys || function keys(t) {
      return e(t, i);
    };
  }, {
    106: 106,
    60: 60
  }],
  108: [function (t, n, r) {
    r.f = {}.propertyIsEnumerable;
  }, {}],
  109: [function (t, n, r) {
    var i = t(62),
        o = t(52),
        u = t(64);

    n.exports = function (t, n) {
      var r = (o.Object || {})[t] || Object[t],
          e = {};
      e[t] = n(r), i(i.S + i.F * u(function () {
        r(1);
      }), "Object", e);
    };
  }, {
    52: 52,
    62: 62,
    64: 64
  }],
  110: [function (t, n, r) {
    var a = t(107),
        f = t(140),
        s = t(108).f;

    n.exports = function (c) {
      return function (t) {
        for (var n, r = f(t), e = a(r), i = e.length, o = 0, u = []; o < i;) s.call(r, n = e[o++]) && u.push(c ? [n, r[n]] : r[n]);

        return u;
      };
    };
  }, {
    107: 107,
    108: 108,
    140: 140
  }],
  111: [function (t, n, r) {
    var e = t(103),
        i = t(104),
        o = t(38),
        u = t(70).Reflect;

    n.exports = u && u.ownKeys || function ownKeys(t) {
      var n = e.f(o(t)),
          r = i.f;
      return r ? n.concat(r(t)) : n;
    };
  }, {
    103: 103,
    104: 104,
    38: 38,
    70: 70
  }],
  112: [function (t, n, r) {
    var e = t(70).parseFloat,
        i = t(134).trim;
    n.exports = 1 / e(t(135) + "-0") != -1 / 0 ? function parseFloat(t) {
      var n = i(String(t), 3),
          r = e(n);
      return 0 === r && "-" == n.charAt(0) ? -0 : r;
    } : e;
  }, {
    134: 134,
    135: 135,
    70: 70
  }],
  113: [function (t, n, r) {
    var e = t(70).parseInt,
        i = t(134).trim,
        o = t(135),
        u = /^[-+]?0[xX]/;
    n.exports = 8 !== e(o + "08") || 22 !== e(o + "0x16") ? function parseInt(t, n) {
      var r = i(String(t), 3);
      return e(r, n >>> 0 || (u.test(r) ? 16 : 10));
    } : e;
  }, {
    134: 134,
    135: 135,
    70: 70
  }],
  114: [function (t, n, r) {
    n.exports = function (t) {
      try {
        return {
          e: !1,
          v: t()
        };
      } catch (t) {
        return {
          e: !0,
          v: t
        };
      }
    };
  }, {}],
  115: [function (t, n, r) {
    var e = t(38),
        i = t(81),
        o = t(96);

    n.exports = function (t, n) {
      if (e(t), i(n) && n.constructor === t) return n;
      var r = o.f(t);
      return (0, r.resolve)(n), r.promise;
    };
  }, {
    38: 38,
    81: 81,
    96: 96
  }],
  116: [function (t, n, r) {
    arguments[4][30][0].apply(r, arguments);
  }, {
    30: 30
  }],
  117: [function (t, n, r) {
    var i = t(118);

    n.exports = function (t, n, r) {
      for (var e in n) i(t, e, n[e], r);

      return t;
    };
  }, {
    118: 118
  }],
  118: [function (t, n, r) {
    var o = t(70),
        u = t(72),
        c = t(71),
        a = t(147)("src"),
        e = t(69),
        i = "toString",
        f = ("" + e).split(i);
    t(52).inspectSource = function (t) {
      return e.call(t);
    }, (n.exports = function (t, n, r, e) {
      var i = "function" == typeof r;
      i && (c(r, "name") || u(r, "name", n)), t[n] !== r && (i && (c(r, a) || u(r, a, t[n] ? "" + t[n] : f.join(String(n)))), t === o ? t[n] = r : e ? t[n] ? t[n] = r : u(t, n, r) : (delete t[n], u(t, n, r)));
    })(Function.prototype, i, function toString() {
      return "function" == typeof this && this[a] || e.call(this);
    });
  }, {
    147: 147,
    52: 52,
    69: 69,
    70: 70,
    71: 71,
    72: 72
  }],
  119: [function (t, n, r) {
    "use strict";

    var i = t(47),
        o = RegExp.prototype.exec;

    n.exports = function (t, n) {
      var r = t.exec;

      if ("function" == typeof r) {
        var e = r.call(t, n);
        if ("object" != typeof e) throw new TypeError("RegExp exec method returned something other than an Object or null");
        return e;
      }

      if ("RegExp" !== i(t)) throw new TypeError("RegExp#exec called on incompatible receiver");
      return o.call(t, n);
    };
  }, {
    47: 47
  }],
  120: [function (t, n, r) {
    "use strict";

    var e,
        i,
        u = t(66),
        c = RegExp.prototype.exec,
        a = String.prototype.replace,
        o = c,
        f = "lastIndex",
        s = (e = /a/, i = /b*/g, c.call(e, "a"), c.call(i, "a"), 0 !== e[f] || 0 !== i[f]),
        l = void 0 !== /()??/.exec("")[1];
    (s || l) && (o = function exec(t) {
      var n,
          r,
          e,
          i,
          o = this;
      return l && (r = new RegExp("^" + o.source + "$(?!\\s)", u.call(o))), s && (n = o[f]), e = c.call(o, t), s && e && (o[f] = o.global ? e.index + e[0].length : n), l && e && 1 < e.length && a.call(e[0], r, function () {
        for (i = 1; i < arguments.length - 2; i++) void 0 === arguments[i] && (e[i] = void 0);
      }), e;
    }), n.exports = o;
  }, {
    66: 66
  }],
  121: [function (t, n, r) {
    n.exports = Object.is || function is(t, n) {
      return t === n ? 0 !== t || 1 / t == 1 / n : t != t && n != n;
    };
  }, {}],
  122: [function (n, t, r) {
    var e = n(81),
        i = n(38),
        o = function (t, n) {
      if (i(t), !e(n) && null !== n) throw TypeError(n + ": can't set as prototype!");
    };

    t.exports = {
      set: Object.setPrototypeOf || ("__proto__" in {} ? function (t, r, e) {
        try {
          (e = n(54)(Function.call, n(101).f(Object.prototype, "__proto__").set, 2))(t, []), r = !(t instanceof Array);
        } catch (t) {
          r = !0;
        }

        return function setPrototypeOf(t, n) {
          return o(t, n), r ? t.__proto__ = n : e(t, n), t;
        };
      }({}, !1) : void 0),
      check: o
    };
  }, {
    101: 101,
    38: 38,
    54: 54,
    81: 81
  }],
  123: [function (t, n, r) {
    "use strict";

    var e = t(70),
        i = t(99),
        o = t(58),
        u = t(152)("species");

    n.exports = function (t) {
      var n = e[t];
      o && n && !n[u] && i.f(n, u, {
        configurable: !0,
        get: function () {
          return this;
        }
      });
    };
  }, {
    152: 152,
    58: 58,
    70: 70,
    99: 99
  }],
  124: [function (t, n, r) {
    var e = t(99).f,
        i = t(71),
        o = t(152)("toStringTag");

    n.exports = function (t, n, r) {
      t && !i(t = r ? t : t.prototype, o) && e(t, o, {
        configurable: !0,
        value: n
      });
    };
  }, {
    152: 152,
    71: 71,
    99: 99
  }],
  125: [function (t, n, r) {
    var e = t(126)("keys"),
        i = t(147);

    n.exports = function (t) {
      return e[t] || (e[t] = i(t));
    };
  }, {
    126: 126,
    147: 147
  }],
  126: [function (t, n, r) {
    var e = t(52),
        i = t(70),
        o = "__core-js_shared__",
        u = i[o] || (i[o] = {});
    (n.exports = function (t, n) {
      return u[t] || (u[t] = void 0 !== n ? n : {});
    })("versions", []).push({
      version: e.version,
      mode: t(89) ? "pure" : "global",
      copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
    });
  }, {
    52: 52,
    70: 70,
    89: 89
  }],
  127: [function (t, n, r) {
    var i = t(38),
        o = t(33),
        u = t(152)("species");

    n.exports = function (t, n) {
      var r,
          e = i(t).constructor;
      return void 0 === e || null == (r = i(e)[u]) ? n : o(r);
    };
  }, {
    152: 152,
    33: 33,
    38: 38
  }],
  128: [function (t, n, r) {
    "use strict";

    var e = t(64);

    n.exports = function (t, n) {
      return !!t && e(function () {
        n ? t.call(null, function () {}, 1) : t.call(null);
      });
    };
  }, {
    64: 64
  }],
  129: [function (t, n, r) {
    var a = t(139),
        f = t(57);

    n.exports = function (c) {
      return function (t, n) {
        var r,
            e,
            i = String(f(t)),
            o = a(n),
            u = i.length;
        return o < 0 || u <= o ? c ? "" : void 0 : (r = i.charCodeAt(o)) < 55296 || 56319 < r || o + 1 === u || (e = i.charCodeAt(o + 1)) < 56320 || 57343 < e ? c ? i.charAt(o) : r : c ? i.slice(o, o + 2) : e - 56320 + (r - 55296 << 10) + 65536;
      };
    };
  }, {
    139: 139,
    57: 57
  }],
  130: [function (t, n, r) {
    var e = t(82),
        i = t(57);

    n.exports = function (t, n, r) {
      if (e(n)) throw TypeError("String#" + r + " doesn't accept regex!");
      return String(i(t));
    };
  }, {
    57: 57,
    82: 82
  }],
  131: [function (t, n, r) {
    var e = t(62),
        i = t(64),
        u = t(57),
        c = /"/g,
        o = function (t, n, r, e) {
      var i = String(u(t)),
          o = "<" + n;
      return "" !== r && (o += " " + r + '="' + String(e).replace(c, "&quot;") + '"'), o + ">" + i + "</" + n + ">";
    };

    n.exports = function (n, t) {
      var r = {};
      r[n] = t(o), e(e.P + e.F * i(function () {
        var t = ""[n]('"');
        return t !== t.toLowerCase() || 3 < t.split('"').length;
      }), "String", r);
    };
  }, {
    57: 57,
    62: 62,
    64: 64
  }],
  132: [function (t, n, r) {
    var s = t(141),
        l = t(133),
        h = t(57);

    n.exports = function (t, n, r, e) {
      var i = String(h(t)),
          o = i.length,
          u = void 0 === r ? " " : String(r),
          c = s(n);
      if (c <= o || "" == u) return i;
      var a = c - o,
          f = l.call(u, Math.ceil(a / u.length));
      return f.length > a && (f = f.slice(0, a)), e ? f + i : i + f;
    };
  }, {
    133: 133,
    141: 141,
    57: 57
  }],
  133: [function (t, n, r) {
    "use strict";

    var i = t(139),
        o = t(57);

    n.exports = function repeat(t) {
      var n = String(o(this)),
          r = "",
          e = i(t);
      if (e < 0 || e == 1 / 0) throw RangeError("Count can't be negative");

      for (; 0 < e; (e >>>= 1) && (n += n)) 1 & e && (r += n);

      return r;
    };
  }, {
    139: 139,
    57: 57
  }],
  134: [function (t, n, r) {
    var u = t(62),
        e = t(57),
        c = t(64),
        a = t(135),
        i = "[" + a + "]",
        o = RegExp("^" + i + i + "*"),
        f = RegExp(i + i + "*$"),
        s = function (t, n, r) {
      var e = {},
          i = c(function () {
        return !!a[t]() || "​" != "​"[t]();
      }),
          o = e[t] = i ? n(l) : a[t];
      r && (e[r] = o), u(u.P + u.F * i, "String", e);
    },
        l = s.trim = function (t, n) {
      return t = String(e(t)), 1 & n && (t = t.replace(o, "")), 2 & n && (t = t.replace(f, "")), t;
    };

    n.exports = s;
  }, {
    135: 135,
    57: 57,
    62: 62,
    64: 64
  }],
  135: [function (t, n, r) {
    n.exports = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff";
  }, {}],
  136: [function (t, n, r) {
    var e,
        i,
        o,
        u = t(54),
        c = t(76),
        a = t(73),
        f = t(59),
        s = t(70),
        l = s.process,
        h = s.setImmediate,
        p = s.clearImmediate,
        v = s.MessageChannel,
        y = s.Dispatch,
        g = 0,
        d = {},
        x = "onreadystatechange",
        m = function () {
      var t = +this;

      if (d.hasOwnProperty(t)) {
        var n = d[t];
        delete d[t], n();
      }
    },
        b = function (t) {
      m.call(t.data);
    };

    h && p || (h = function setImmediate(t) {
      for (var n = [], r = 1; arguments.length > r;) n.push(arguments[r++]);

      return d[++g] = function () {
        c("function" == typeof t ? t : Function(t), n);
      }, e(g), g;
    }, p = function clearImmediate(t) {
      delete d[t];
    }, "process" == t(48)(l) ? e = function (t) {
      l.nextTick(u(m, t, 1));
    } : y && y.now ? e = function (t) {
      y.now(u(m, t, 1));
    } : v ? (o = (i = new v()).port2, i.port1.onmessage = b, e = u(o.postMessage, o, 1)) : s.addEventListener && "function" == typeof postMessage && !s.importScripts ? (e = function (t) {
      s.postMessage(t + "", "*");
    }, s.addEventListener("message", b, !1)) : e = x in f("script") ? function (t) {
      a.appendChild(f("script"))[x] = function () {
        a.removeChild(this), m.call(t);
      };
    } : function (t) {
      setTimeout(u(m, t, 1), 0);
    }), n.exports = {
      set: h,
      clear: p
    };
  }, {
    48: 48,
    54: 54,
    59: 59,
    70: 70,
    73: 73,
    76: 76
  }],
  137: [function (t, n, r) {
    var e = t(139),
        i = Math.max,
        o = Math.min;

    n.exports = function (t, n) {
      return (t = e(t)) < 0 ? i(t + n, 0) : o(t, n);
    };
  }, {
    139: 139
  }],
  138: [function (t, n, r) {
    var e = t(139),
        i = t(141);

    n.exports = function (t) {
      if (void 0 === t) return 0;
      var n = e(t),
          r = i(n);
      if (n !== r) throw RangeError("Wrong length!");
      return r;
    };
  }, {
    139: 139,
    141: 141
  }],
  139: [function (t, n, r) {
    var e = Math.ceil,
        i = Math.floor;

    n.exports = function (t) {
      return isNaN(t = +t) ? 0 : (0 < t ? i : e)(t);
    };
  }, {}],
  140: [function (t, n, r) {
    var e = t(77),
        i = t(57);

    n.exports = function (t) {
      return e(i(t));
    };
  }, {
    57: 57,
    77: 77
  }],
  141: [function (t, n, r) {
    var e = t(139),
        i = Math.min;

    n.exports = function (t) {
      return 0 < t ? i(e(t), 9007199254740991) : 0;
    };
  }, {
    139: 139
  }],
  142: [function (t, n, r) {
    var e = t(57);

    n.exports = function (t) {
      return Object(e(t));
    };
  }, {
    57: 57
  }],
  143: [function (t, n, r) {
    arguments[4][31][0].apply(r, arguments);
  }, {
    31: 31,
    81: 81
  }],
  144: [function (t, n, r) {
    "use strict";

    if (t(58)) {
      var d = t(89),
          x = t(70),
          m = t(64),
          b = t(62),
          S = t(146),
          e = t(145),
          h = t(54),
          w = t(37),
          i = t(116),
          _ = t(72),
          o = t(117),
          u = t(139),
          E = t(141),
          F = t(138),
          c = t(137),
          a = t(143),
          f = t(71),
          I = t(47),
          O = t(81),
          p = t(142),
          v = t(78),
          P = t(98),
          A = t(105),
          M = t(103).f,
          y = t(153),
          s = t(147),
          l = t(152),
          g = t(42),
          k = t(41),
          N = t(127),
          j = t(164),
          T = t(88),
          R = t(86),
          L = t(123),
          C = t(40),
          G = t(39),
          D = t(99),
          U = t(101),
          W = D.f,
          V = U.f,
          B = x.RangeError,
          z = x.TypeError,
          q = x.Uint8Array,
          Y = "ArrayBuffer",
          K = "Shared" + Y,
          $ = "BYTES_PER_ELEMENT",
          J = "prototype",
          X = Array[J],
          H = e.ArrayBuffer,
          Z = e.DataView,
          Q = g(0),
          tt = g(2),
          nt = g(3),
          rt = g(4),
          et = g(5),
          it = g(6),
          ot = k(!0),
          ut = k(!1),
          ct = j.values,
          at = j.keys,
          ft = j.entries,
          st = X.lastIndexOf,
          lt = X.reduce,
          ht = X.reduceRight,
          pt = X.join,
          vt = X.sort,
          yt = X.slice,
          gt = X.toString,
          dt = X.toLocaleString,
          xt = l("iterator"),
          mt = l("toStringTag"),
          bt = s("typed_constructor"),
          St = s("def_constructor"),
          wt = S.CONSTR,
          _t = S.TYPED,
          Et = S.VIEW,
          Ft = "Wrong length!",
          It = g(1, function (t, n) {
        return kt(N(t, t[St]), n);
      }),
          Ot = m(function () {
        return 1 === new q(new Uint16Array([1]).buffer)[0];
      }),
          Pt = !!q && !!q[J].set && m(function () {
        new q(1).set({});
      }),
          At = function (t, n) {
        var r = u(t);
        if (r < 0 || r % n) throw B("Wrong offset!");
        return r;
      },
          Mt = function (t) {
        if (O(t) && _t in t) return t;
        throw z(t + " is not a typed array!");
      },
          kt = function (t, n) {
        if (!(O(t) && bt in t)) throw z("It is not a typed array constructor!");
        return new t(n);
      },
          Nt = function (t, n) {
        return jt(N(t, t[St]), n);
      },
          jt = function (t, n) {
        for (var r = 0, e = n.length, i = kt(t, e); r < e;) i[r] = n[r++];

        return i;
      },
          Tt = function (t, n, r) {
        W(t, n, {
          get: function () {
            return this._d[r];
          }
        });
      },
          Rt = function from(t) {
        var n,
            r,
            e,
            i,
            o,
            u,
            c = p(t),
            a = arguments.length,
            f = 1 < a ? arguments[1] : void 0,
            s = void 0 !== f,
            l = y(c);

        if (null != l && !v(l)) {
          for (u = l.call(c), e = [], n = 0; !(o = u.next()).done; n++) e.push(o.value);

          c = e;
        }

        for (s && 2 < a && (f = h(f, arguments[2], 2)), n = 0, r = E(c.length), i = kt(this, r); n < r; n++) i[n] = s ? f(c[n], n) : c[n];

        return i;
      },
          Lt = function of() {
        for (var t = 0, n = arguments.length, r = kt(this, n); t < n;) r[t] = arguments[t++];

        return r;
      },
          Ct = !!q && m(function () {
        dt.call(new q(1));
      }),
          Gt = function toLocaleString() {
        return dt.apply(Ct ? yt.call(Mt(this)) : Mt(this), arguments);
      },
          Dt = {
        copyWithin: function copyWithin(t, n) {
          return G.call(Mt(this), t, n, 2 < arguments.length ? arguments[2] : void 0);
        },
        every: function every(t) {
          return rt(Mt(this), t, 1 < arguments.length ? arguments[1] : void 0);
        },
        fill: function fill(t) {
          return C.apply(Mt(this), arguments);
        },
        filter: function filter(t) {
          return Nt(this, tt(Mt(this), t, 1 < arguments.length ? arguments[1] : void 0));
        },
        find: function find(t) {
          return et(Mt(this), t, 1 < arguments.length ? arguments[1] : void 0);
        },
        findIndex: function findIndex(t) {
          return it(Mt(this), t, 1 < arguments.length ? arguments[1] : void 0);
        },
        forEach: function forEach(t) {
          Q(Mt(this), t, 1 < arguments.length ? arguments[1] : void 0);
        },
        indexOf: function indexOf(t) {
          return ut(Mt(this), t, 1 < arguments.length ? arguments[1] : void 0);
        },
        includes: function includes(t) {
          return ot(Mt(this), t, 1 < arguments.length ? arguments[1] : void 0);
        },
        join: function join(t) {
          return pt.apply(Mt(this), arguments);
        },
        lastIndexOf: function lastIndexOf(t) {
          return st.apply(Mt(this), arguments);
        },
        map: function map(t) {
          return It(Mt(this), t, 1 < arguments.length ? arguments[1] : void 0);
        },
        reduce: function reduce(t) {
          return lt.apply(Mt(this), arguments);
        },
        reduceRight: function reduceRight(t) {
          return ht.apply(Mt(this), arguments);
        },
        reverse: function reverse() {
          for (var t, n = this, r = Mt(n).length, e = Math.floor(r / 2), i = 0; i < e;) t = n[i], n[i++] = n[--r], n[r] = t;

          return n;
        },
        some: function some(t) {
          return nt(Mt(this), t, 1 < arguments.length ? arguments[1] : void 0);
        },
        sort: function sort(t) {
          return vt.call(Mt(this), t);
        },
        subarray: function subarray(t, n) {
          var r = Mt(this),
              e = r.length,
              i = c(t, e);
          return new (N(r, r[St]))(r.buffer, r.byteOffset + i * r.BYTES_PER_ELEMENT, E((void 0 === n ? e : c(n, e)) - i));
        }
      },
          Ut = function slice(t, n) {
        return Nt(this, yt.call(Mt(this), t, n));
      },
          Wt = function set(t) {
        Mt(this);
        var n = At(arguments[1], 1),
            r = this.length,
            e = p(t),
            i = E(e.length),
            o = 0;
        if (r < i + n) throw B(Ft);

        for (; o < i;) this[n + o] = e[o++];
      },
          Vt = {
        entries: function entries() {
          return ft.call(Mt(this));
        },
        keys: function keys() {
          return at.call(Mt(this));
        },
        values: function values() {
          return ct.call(Mt(this));
        }
      },
          Bt = function (t, n) {
        return O(t) && t[_t] && "symbol" != typeof n && n in t && String(+n) == String(n);
      },
          zt = function getOwnPropertyDescriptor(t, n) {
        return Bt(t, n = a(n, !0)) ? i(2, t[n]) : V(t, n);
      },
          qt = function defineProperty(t, n, r) {
        return !(Bt(t, n = a(n, !0)) && O(r) && f(r, "value")) || f(r, "get") || f(r, "set") || r.configurable || f(r, "writable") && !r.writable || f(r, "enumerable") && !r.enumerable ? W(t, n, r) : (t[n] = r.value, t);
      };

      wt || (U.f = zt, D.f = qt), b(b.S + b.F * !wt, "Object", {
        getOwnPropertyDescriptor: zt,
        defineProperty: qt
      }), m(function () {
        gt.call({});
      }) && (gt = dt = function toString() {
        return pt.call(this);
      });
      var Yt = o({}, Dt);
      o(Yt, Vt), _(Yt, xt, Vt.values), o(Yt, {
        slice: Ut,
        set: Wt,
        constructor: function () {},
        toString: gt,
        toLocaleString: Gt
      }), Tt(Yt, "buffer", "b"), Tt(Yt, "byteOffset", "o"), Tt(Yt, "byteLength", "l"), Tt(Yt, "length", "e"), W(Yt, mt, {
        get: function () {
          return this[_t];
        }
      }), n.exports = function (t, l, n, o) {
        var h = t + ((o = !!o) ? "Clamped" : "") + "Array",
            r = "get" + t,
            u = "set" + t,
            p = x[h],
            c = p || {},
            e = p && A(p),
            i = !p || !S.ABV,
            a = {},
            f = p && p[J],
            v = function (t, i) {
          W(t, i, {
            get: function () {
              return t = i, (n = this._d).v[r](t * l + n.o, Ot);
              var t, n;
            },
            set: function (t) {
              return n = i, r = t, e = this._d, o && (r = (r = Math.round(r)) < 0 ? 0 : 255 < r ? 255 : 255 & r), void e.v[u](n * l + e.o, r, Ot);
              var n, r, e;
            },
            enumerable: !0
          });
        };

        i ? (p = n(function (t, n, r, e) {
          w(t, p, h, "_d");
          var i,
              o,
              u,
              c,
              a = 0,
              f = 0;

          if (O(n)) {
            if (!(n instanceof H || (c = I(n)) == Y || c == K)) return _t in n ? jt(p, n) : Rt.call(p, n);
            i = n, f = At(r, l);
            var s = n.byteLength;

            if (void 0 === e) {
              if (s % l) throw B(Ft);
              if ((o = s - f) < 0) throw B(Ft);
            } else if (s < (o = E(e) * l) + f) throw B(Ft);

            u = o / l;
          } else u = F(n), i = new H(o = u * l);

          for (_(t, "_d", {
            b: i,
            o: f,
            l: o,
            e: u,
            v: new Z(i)
          }); a < u;) v(t, a++);
        }), f = p[J] = P(Yt), _(f, "constructor", p)) : m(function () {
          p(1);
        }) && m(function () {
          new p(-1);
        }) && R(function (t) {
          new p(), new p(null), new p(1.5), new p(t);
        }, !0) || (p = n(function (t, n, r, e) {
          var i;
          return w(t, p, h), O(n) ? n instanceof H || (i = I(n)) == Y || i == K ? void 0 !== e ? new c(n, At(r, l), e) : void 0 !== r ? new c(n, At(r, l)) : new c(n) : _t in n ? jt(p, n) : Rt.call(p, n) : new c(F(n));
        }), Q(e !== Function.prototype ? M(c).concat(M(e)) : M(c), function (t) {
          t in p || _(p, t, c[t]);
        }), p[J] = f, d || (f.constructor = p));
        var s = f[xt],
            y = !!s && ("values" == s.name || null == s.name),
            g = Vt.values;
        _(p, bt, !0), _(f, _t, h), _(f, Et, !0), _(f, St, p), (o ? new p(1)[mt] == h : mt in f) || W(f, mt, {
          get: function () {
            return h;
          }
        }), a[h] = p, b(b.G + b.W + b.F * (p != c), a), b(b.S, h, {
          BYTES_PER_ELEMENT: l
        }), b(b.S + b.F * m(function () {
          c.of.call(p, 1);
        }), h, {
          from: Rt,
          of: Lt
        }), $ in f || _(f, $, l), b(b.P, h, Dt), L(h), b(b.P + b.F * Pt, h, {
          set: Wt
        }), b(b.P + b.F * !y, h, Vt), d || f.toString == gt || (f.toString = gt), b(b.P + b.F * m(function () {
          new p(1).slice();
        }), h, {
          slice: Ut
        }), b(b.P + b.F * (m(function () {
          return [1, 2].toLocaleString() != new p([1, 2]).toLocaleString();
        }) || !m(function () {
          f.toLocaleString.call([1, 2]);
        })), h, {
          toLocaleString: Gt
        }), T[h] = y ? s : g, d || y || _(f, xt, g);
      };
    } else n.exports = function () {};
  }, {
    101: 101,
    103: 103,
    105: 105,
    116: 116,
    117: 117,
    123: 123,
    127: 127,
    137: 137,
    138: 138,
    139: 139,
    141: 141,
    142: 142,
    143: 143,
    145: 145,
    146: 146,
    147: 147,
    152: 152,
    153: 153,
    164: 164,
    37: 37,
    39: 39,
    40: 40,
    41: 41,
    42: 42,
    47: 47,
    54: 54,
    58: 58,
    62: 62,
    64: 64,
    70: 70,
    71: 71,
    72: 72,
    78: 78,
    81: 81,
    86: 86,
    88: 88,
    89: 89,
    98: 98,
    99: 99
  }],
  145: [function (t, n, r) {
    "use strict";

    var e = t(70),
        i = t(58),
        o = t(89),
        u = t(146),
        c = t(72),
        a = t(117),
        f = t(64),
        s = t(37),
        l = t(139),
        h = t(141),
        p = t(138),
        v = t(103).f,
        y = t(99).f,
        g = t(40),
        d = t(124),
        x = "ArrayBuffer",
        m = "DataView",
        b = "prototype",
        S = "Wrong index!",
        w = e[x],
        _ = e[m],
        E = e.Math,
        F = e.RangeError,
        I = e.Infinity,
        O = w,
        P = E.abs,
        A = E.pow,
        M = E.floor,
        k = E.log,
        N = E.LN2,
        j = "byteLength",
        T = "byteOffset",
        R = i ? "_b" : "buffer",
        L = i ? "_l" : j,
        C = i ? "_o" : T;

    function packIEEE754(t, n, r) {
      var e,
          i,
          o,
          u = new Array(r),
          c = 8 * r - n - 1,
          a = (1 << c) - 1,
          f = a >> 1,
          s = 23 === n ? A(2, -24) - A(2, -77) : 0,
          l = 0,
          h = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;

      for ((t = P(t)) != t || t === I ? (i = t != t ? 1 : 0, e = a) : (e = M(k(t) / N), t * (o = A(2, -e)) < 1 && (e--, o *= 2), 2 <= (t += 1 <= e + f ? s / o : s * A(2, 1 - f)) * o && (e++, o /= 2), a <= e + f ? (i = 0, e = a) : 1 <= e + f ? (i = (t * o - 1) * A(2, n), e += f) : (i = t * A(2, f - 1) * A(2, n), e = 0)); 8 <= n; u[l++] = 255 & i, i /= 256, n -= 8);

      for (e = e << n | i, c += n; 0 < c; u[l++] = 255 & e, e /= 256, c -= 8);

      return u[--l] |= 128 * h, u;
    }

    function unpackIEEE754(t, n, r) {
      var e,
          i = 8 * r - n - 1,
          o = (1 << i) - 1,
          u = o >> 1,
          c = i - 7,
          a = r - 1,
          f = t[a--],
          s = 127 & f;

      for (f >>= 7; 0 < c; s = 256 * s + t[a], a--, c -= 8);

      for (e = s & (1 << -c) - 1, s >>= -c, c += n; 0 < c; e = 256 * e + t[a], a--, c -= 8);

      if (0 === s) s = 1 - u;else {
        if (s === o) return e ? NaN : f ? -I : I;
        e += A(2, n), s -= u;
      }
      return (f ? -1 : 1) * e * A(2, s - n);
    }

    function unpackI32(t) {
      return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0];
    }

    function packI8(t) {
      return [255 & t];
    }

    function packI16(t) {
      return [255 & t, t >> 8 & 255];
    }

    function packI32(t) {
      return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255];
    }

    function packF64(t) {
      return packIEEE754(t, 52, 8);
    }

    function packF32(t) {
      return packIEEE754(t, 23, 4);
    }

    function addGetter(t, n, r) {
      y(t[b], n, {
        get: function () {
          return this[r];
        }
      });
    }

    function get(t, n, r, e) {
      var i = p(+r);
      if (i + n > t[L]) throw F(S);
      var o = t[R]._b,
          u = i + t[C],
          c = o.slice(u, u + n);
      return e ? c : c.reverse();
    }

    function set(t, n, r, e, i, o) {
      var u = p(+r);
      if (u + n > t[L]) throw F(S);

      for (var c = t[R]._b, a = u + t[C], f = e(+i), s = 0; s < n; s++) c[a + s] = f[o ? s : n - s - 1];
    }

    if (u.ABV) {
      if (!f(function () {
        w(1);
      }) || !f(function () {
        new w(-1);
      }) || f(function () {
        return new w(), new w(1.5), new w(NaN), w.name != x;
      })) {
        for (var G, D = (w = function ArrayBuffer(t) {
          return s(this, w), new O(p(t));
        })[b] = O[b], U = v(O), W = 0; U.length > W;) (G = U[W++]) in w || c(w, G, O[G]);

        o || (D.constructor = w);
      }

      var V = new _(new w(2)),
          B = _[b].setInt8;
      V.setInt8(0, 2147483648), V.setInt8(1, 2147483649), !V.getInt8(0) && V.getInt8(1) || a(_[b], {
        setInt8: function setInt8(t, n) {
          B.call(this, t, n << 24 >> 24);
        },
        setUint8: function setUint8(t, n) {
          B.call(this, t, n << 24 >> 24);
        }
      }, !0);
    } else w = function ArrayBuffer(t) {
      s(this, w, x);
      var n = p(t);
      this._b = g.call(new Array(n), 0), this[L] = n;
    }, _ = function DataView(t, n, r) {
      s(this, _, m), s(t, w, m);
      var e = t[L],
          i = l(n);
      if (i < 0 || e < i) throw F("Wrong offset!");
      if (e < i + (r = void 0 === r ? e - i : h(r))) throw F("Wrong length!");
      this[R] = t, this[C] = i, this[L] = r;
    }, i && (addGetter(w, j, "_l"), addGetter(_, "buffer", "_b"), addGetter(_, j, "_l"), addGetter(_, T, "_o")), a(_[b], {
      getInt8: function getInt8(t) {
        return get(this, 1, t)[0] << 24 >> 24;
      },
      getUint8: function getUint8(t) {
        return get(this, 1, t)[0];
      },
      getInt16: function getInt16(t) {
        var n = get(this, 2, t, arguments[1]);
        return (n[1] << 8 | n[0]) << 16 >> 16;
      },
      getUint16: function getUint16(t) {
        var n = get(this, 2, t, arguments[1]);
        return n[1] << 8 | n[0];
      },
      getInt32: function getInt32(t) {
        return unpackI32(get(this, 4, t, arguments[1]));
      },
      getUint32: function getUint32(t) {
        return unpackI32(get(this, 4, t, arguments[1])) >>> 0;
      },
      getFloat32: function getFloat32(t) {
        return unpackIEEE754(get(this, 4, t, arguments[1]), 23, 4);
      },
      getFloat64: function getFloat64(t) {
        return unpackIEEE754(get(this, 8, t, arguments[1]), 52, 8);
      },
      setInt8: function setInt8(t, n) {
        set(this, 1, t, packI8, n);
      },
      setUint8: function setUint8(t, n) {
        set(this, 1, t, packI8, n);
      },
      setInt16: function setInt16(t, n) {
        set(this, 2, t, packI16, n, arguments[2]);
      },
      setUint16: function setUint16(t, n) {
        set(this, 2, t, packI16, n, arguments[2]);
      },
      setInt32: function setInt32(t, n) {
        set(this, 4, t, packI32, n, arguments[2]);
      },
      setUint32: function setUint32(t, n) {
        set(this, 4, t, packI32, n, arguments[2]);
      },
      setFloat32: function setFloat32(t, n) {
        set(this, 4, t, packF32, n, arguments[2]);
      },
      setFloat64: function setFloat64(t, n) {
        set(this, 8, t, packF64, n, arguments[2]);
      }
    });

    d(w, x), d(_, m), c(_[b], u.VIEW, !0), r[x] = w, r[m] = _;
  }, {
    103: 103,
    117: 117,
    124: 124,
    138: 138,
    139: 139,
    141: 141,
    146: 146,
    37: 37,
    40: 40,
    58: 58,
    64: 64,
    70: 70,
    72: 72,
    89: 89,
    99: 99
  }],
  146: [function (t, n, r) {
    for (var e, i = t(70), o = t(72), u = t(147), c = u("typed_array"), a = u("view"), f = !(!i.ArrayBuffer || !i.DataView), s = f, l = 0, h = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); l < 9;) (e = i[h[l++]]) ? (o(e.prototype, c, !0), o(e.prototype, a, !0)) : s = !1;

    n.exports = {
      ABV: f,
      CONSTR: s,
      TYPED: c,
      VIEW: a
    };
  }, {
    147: 147,
    70: 70,
    72: 72
  }],
  147: [function (t, n, r) {
    var e = 0,
        i = Math.random();

    n.exports = function (t) {
      return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++e + i).toString(36));
    };
  }, {}],
  148: [function (t, n, r) {
    var e = t(70).navigator;
    n.exports = e && e.userAgent || "";
  }, {
    70: 70
  }],
  149: [function (t, n, r) {
    var e = t(81);

    n.exports = function (t, n) {
      if (!e(t) || t._t !== n) throw TypeError("Incompatible receiver, " + n + " required!");
      return t;
    };
  }, {
    81: 81
  }],
  150: [function (t, n, r) {
    var e = t(70),
        i = t(52),
        o = t(89),
        u = t(151),
        c = t(99).f;

    n.exports = function (t) {
      var n = i.Symbol || (i.Symbol = o ? {} : e.Symbol || {});
      "_" == t.charAt(0) || t in n || c(n, t, {
        value: u.f(t)
      });
    };
  }, {
    151: 151,
    52: 52,
    70: 70,
    89: 89,
    99: 99
  }],
  151: [function (t, n, r) {
    r.f = t(152);
  }, {
    152: 152
  }],
  152: [function (t, n, r) {
    var e = t(126)("wks"),
        i = t(147),
        o = t(70).Symbol,
        u = "function" == typeof o;
    (n.exports = function (t) {
      return e[t] || (e[t] = u && o[t] || (u ? o : i)("Symbol." + t));
    }).store = e;
  }, {
    126: 126,
    147: 147,
    70: 70
  }],
  153: [function (t, n, r) {
    var e = t(47),
        i = t(152)("iterator"),
        o = t(88);

    n.exports = t(52).getIteratorMethod = function (t) {
      if (null != t) return t[i] || t["@@iterator"] || o[e(t)];
    };
  }, {
    152: 152,
    47: 47,
    52: 52,
    88: 88
  }],
  154: [function (t, n, r) {
    var e = t(62);
    e(e.P, "Array", {
      copyWithin: t(39)
    }), t(35)("copyWithin");
  }, {
    35: 35,
    39: 39,
    62: 62
  }],
  155: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(42)(4);
    e(e.P + e.F * !t(128)([].every, !0), "Array", {
      every: function every(t) {
        return i(this, t, arguments[1]);
      }
    });
  }, {
    128: 128,
    42: 42,
    62: 62
  }],
  156: [function (t, n, r) {
    var e = t(62);
    e(e.P, "Array", {
      fill: t(40)
    }), t(35)("fill");
  }, {
    35: 35,
    40: 40,
    62: 62
  }],
  157: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(42)(2);
    e(e.P + e.F * !t(128)([].filter, !0), "Array", {
      filter: function filter(t) {
        return i(this, t, arguments[1]);
      }
    });
  }, {
    128: 128,
    42: 42,
    62: 62
  }],
  158: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(42)(6),
        o = "findIndex",
        u = !0;
    o in [] && Array(1)[o](function () {
      u = !1;
    }), e(e.P + e.F * u, "Array", {
      findIndex: function findIndex(t) {
        return i(this, t, 1 < arguments.length ? arguments[1] : void 0);
      }
    }), t(35)(o);
  }, {
    35: 35,
    42: 42,
    62: 62
  }],
  159: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(42)(5),
        o = "find",
        u = !0;
    o in [] && Array(1)[o](function () {
      u = !1;
    }), e(e.P + e.F * u, "Array", {
      find: function find(t) {
        return i(this, t, 1 < arguments.length ? arguments[1] : void 0);
      }
    }), t(35)(o);
  }, {
    35: 35,
    42: 42,
    62: 62
  }],
  160: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(42)(0),
        o = t(128)([].forEach, !0);
    e(e.P + e.F * !o, "Array", {
      forEach: function forEach(t) {
        return i(this, t, arguments[1]);
      }
    });
  }, {
    128: 128,
    42: 42,
    62: 62
  }],
  161: [function (t, n, r) {
    "use strict";

    var h = t(54),
        e = t(62),
        p = t(142),
        v = t(83),
        y = t(78),
        g = t(141),
        d = t(53),
        x = t(153);
    e(e.S + e.F * !t(86)(function (t) {
      Array.from(t);
    }), "Array", {
      from: function from(t) {
        var n,
            r,
            e,
            i,
            o = p(t),
            u = "function" == typeof this ? this : Array,
            c = arguments.length,
            a = 1 < c ? arguments[1] : void 0,
            f = void 0 !== a,
            s = 0,
            l = x(o);
        if (f && (a = h(a, 2 < c ? arguments[2] : void 0, 2)), null == l || u == Array && y(l)) for (r = new u(n = g(o.length)); s < n; s++) d(r, s, f ? a(o[s], s) : o[s]);else for (i = l.call(o), r = new u(); !(e = i.next()).done; s++) d(r, s, f ? v(i, a, [e.value, s], !0) : e.value);
        return r.length = s, r;
      }
    });
  }, {
    141: 141,
    142: 142,
    153: 153,
    53: 53,
    54: 54,
    62: 62,
    78: 78,
    83: 83,
    86: 86
  }],
  162: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(41)(!1),
        o = [].indexOf,
        u = !!o && 1 / [1].indexOf(1, -0) < 0;
    e(e.P + e.F * (u || !t(128)(o)), "Array", {
      indexOf: function indexOf(t) {
        return u ? o.apply(this, arguments) || 0 : i(this, t, arguments[1]);
      }
    });
  }, {
    128: 128,
    41: 41,
    62: 62
  }],
  163: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Array", {
      isArray: t(79)
    });
  }, {
    62: 62,
    79: 79
  }],
  164: [function (t, n, r) {
    "use strict";

    var e = t(35),
        i = t(87),
        o = t(88),
        u = t(140);
    n.exports = t(85)(Array, "Array", function (t, n) {
      this._t = u(t), this._i = 0, this._k = n;
    }, function () {
      var t = this._t,
          n = this._k,
          r = this._i++;
      return !t || r >= t.length ? (this._t = void 0, i(1)) : i(0, "keys" == n ? r : "values" == n ? t[r] : [r, t[r]]);
    }, "values"), o.Arguments = o.Array, e("keys"), e("values"), e("entries");
  }, {
    140: 140,
    35: 35,
    85: 85,
    87: 87,
    88: 88
  }],
  165: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(140),
        o = [].join;
    e(e.P + e.F * (t(77) != Object || !t(128)(o)), "Array", {
      join: function join(t) {
        return o.call(i(this), void 0 === t ? "," : t);
      }
    });
  }, {
    128: 128,
    140: 140,
    62: 62,
    77: 77
  }],
  166: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(140),
        o = t(139),
        u = t(141),
        c = [].lastIndexOf,
        a = !!c && 1 / [1].lastIndexOf(1, -0) < 0;
    e(e.P + e.F * (a || !t(128)(c)), "Array", {
      lastIndexOf: function lastIndexOf(t) {
        if (a) return c.apply(this, arguments) || 0;
        var n = i(this),
            r = u(n.length),
            e = r - 1;

        for (1 < arguments.length && (e = Math.min(e, o(arguments[1]))), e < 0 && (e = r + e); 0 <= e; e--) if (e in n && n[e] === t) return e || 0;

        return -1;
      }
    });
  }, {
    128: 128,
    139: 139,
    140: 140,
    141: 141,
    62: 62
  }],
  167: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(42)(1);
    e(e.P + e.F * !t(128)([].map, !0), "Array", {
      map: function map(t) {
        return i(this, t, arguments[1]);
      }
    });
  }, {
    128: 128,
    42: 42,
    62: 62
  }],
  168: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(53);
    e(e.S + e.F * t(64)(function () {
      function F() {}

      return !(Array.of.call(F) instanceof F);
    }), "Array", {
      of: function of() {
        for (var t = 0, n = arguments.length, r = new ("function" == typeof this ? this : Array)(n); t < n;) i(r, t, arguments[t++]);

        return r.length = n, r;
      }
    });
  }, {
    53: 53,
    62: 62,
    64: 64
  }],
  169: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(43);
    e(e.P + e.F * !t(128)([].reduceRight, !0), "Array", {
      reduceRight: function reduceRight(t) {
        return i(this, t, arguments.length, arguments[1], !0);
      }
    });
  }, {
    128: 128,
    43: 43,
    62: 62
  }],
  170: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(43);
    e(e.P + e.F * !t(128)([].reduce, !0), "Array", {
      reduce: function reduce(t) {
        return i(this, t, arguments.length, arguments[1], !1);
      }
    });
  }, {
    128: 128,
    43: 43,
    62: 62
  }],
  171: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(73),
        f = t(48),
        s = t(137),
        l = t(141),
        h = [].slice;
    e(e.P + e.F * t(64)(function () {
      i && h.call(i);
    }), "Array", {
      slice: function slice(t, n) {
        var r = l(this.length),
            e = f(this);
        if (n = void 0 === n ? r : n, "Array" == e) return h.call(this, t, n);

        for (var i = s(t, r), o = s(n, r), u = l(o - i), c = new Array(u), a = 0; a < u; a++) c[a] = "String" == e ? this.charAt(i + a) : this[i + a];

        return c;
      }
    });
  }, {
    137: 137,
    141: 141,
    48: 48,
    62: 62,
    64: 64,
    73: 73
  }],
  172: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(42)(3);
    e(e.P + e.F * !t(128)([].some, !0), "Array", {
      some: function some(t) {
        return i(this, t, arguments[1]);
      }
    });
  }, {
    128: 128,
    42: 42,
    62: 62
  }],
  173: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(33),
        o = t(142),
        u = t(64),
        c = [].sort,
        a = [1, 2, 3];
    e(e.P + e.F * (u(function () {
      a.sort(void 0);
    }) || !u(function () {
      a.sort(null);
    }) || !t(128)(c)), "Array", {
      sort: function sort(t) {
        return void 0 === t ? c.call(o(this)) : c.call(o(this), i(t));
      }
    });
  }, {
    128: 128,
    142: 142,
    33: 33,
    62: 62,
    64: 64
  }],
  174: [function (t, n, r) {
    t(123)("Array");
  }, {
    123: 123
  }],
  175: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Date", {
      now: function () {
        return new Date().getTime();
      }
    });
  }, {
    62: 62
  }],
  176: [function (t, n, r) {
    var e = t(62),
        i = t(55);
    e(e.P + e.F * (Date.prototype.toISOString !== i), "Date", {
      toISOString: i
    });
  }, {
    55: 55,
    62: 62
  }],
  177: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(142),
        o = t(143);
    e(e.P + e.F * t(64)(function () {
      return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
        toISOString: function () {
          return 1;
        }
      });
    }), "Date", {
      toJSON: function toJSON(t) {
        var n = i(this),
            r = o(n);
        return "number" != typeof r || isFinite(r) ? n.toISOString() : null;
      }
    });
  }, {
    142: 142,
    143: 143,
    62: 62,
    64: 64
  }],
  178: [function (t, n, r) {
    var e = t(152)("toPrimitive"),
        i = Date.prototype;
    e in i || t(72)(i, e, t(56));
  }, {
    152: 152,
    56: 56,
    72: 72
  }],
  179: [function (t, n, r) {
    var e = Date.prototype,
        i = "Invalid Date",
        o = "toString",
        u = e[o],
        c = e.getTime;
    new Date(NaN) + "" != i && t(118)(e, o, function toString() {
      var t = c.call(this);
      return t == t ? u.call(this) : i;
    });
  }, {
    118: 118
  }],
  180: [function (t, n, r) {
    var e = t(62);
    e(e.P, "Function", {
      bind: t(46)
    });
  }, {
    46: 46,
    62: 62
  }],
  181: [function (t, n, r) {
    "use strict";

    var e = t(81),
        i = t(105),
        o = t(152)("hasInstance"),
        u = Function.prototype;
    o in u || t(99).f(u, o, {
      value: function (t) {
        if ("function" != typeof this || !e(t)) return !1;
        if (!e(this.prototype)) return t instanceof this;

        for (; t = i(t);) if (this.prototype === t) return !0;

        return !1;
      }
    });
  }, {
    105: 105,
    152: 152,
    81: 81,
    99: 99
  }],
  182: [function (t, n, r) {
    var e = t(99).f,
        i = Function.prototype,
        o = /^\s*function ([^ (]*)/;
    "name" in i || t(58) && e(i, "name", {
      configurable: !0,
      get: function () {
        try {
          return ("" + this).match(o)[1];
        } catch (t) {
          return "";
        }
      }
    });
  }, {
    58: 58,
    99: 99
  }],
  183: [function (t, n, r) {
    "use strict";

    var e = t(49),
        i = t(149);
    n.exports = t(51)("Map", function (t) {
      return function Map() {
        return t(this, 0 < arguments.length ? arguments[0] : void 0);
      };
    }, {
      get: function get(t) {
        var n = e.getEntry(i(this, "Map"), t);
        return n && n.v;
      },
      set: function set(t, n) {
        return e.def(i(this, "Map"), 0 === t ? 0 : t, n);
      }
    }, e, !0);
  }, {
    149: 149,
    49: 49,
    51: 51
  }],
  184: [function (t, n, r) {
    var e = t(62),
        i = t(92),
        o = Math.sqrt,
        u = Math.acosh;
    e(e.S + e.F * !(u && 710 == Math.floor(u(Number.MAX_VALUE)) && u(1 / 0) == 1 / 0), "Math", {
      acosh: function acosh(t) {
        return (t = +t) < 1 ? NaN : 94906265.62425156 < t ? Math.log(t) + Math.LN2 : i(t - 1 + o(t - 1) * o(t + 1));
      }
    });
  }, {
    62: 62,
    92: 92
  }],
  185: [function (t, n, r) {
    var e = t(62),
        i = Math.asinh;
    e(e.S + e.F * !(i && 0 < 1 / i(0)), "Math", {
      asinh: function asinh(t) {
        return isFinite(t = +t) && 0 != t ? t < 0 ? -asinh(-t) : Math.log(t + Math.sqrt(t * t + 1)) : t;
      }
    });
  }, {
    62: 62
  }],
  186: [function (t, n, r) {
    var e = t(62),
        i = Math.atanh;
    e(e.S + e.F * !(i && 1 / i(-0) < 0), "Math", {
      atanh: function atanh(t) {
        return 0 == (t = +t) ? t : Math.log((1 + t) / (1 - t)) / 2;
      }
    });
  }, {
    62: 62
  }],
  187: [function (t, n, r) {
    var e = t(62),
        i = t(93);
    e(e.S, "Math", {
      cbrt: function cbrt(t) {
        return i(t = +t) * Math.pow(Math.abs(t), 1 / 3);
      }
    });
  }, {
    62: 62,
    93: 93
  }],
  188: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Math", {
      clz32: function clz32(t) {
        return (t >>>= 0) ? 31 - Math.floor(Math.log(t + .5) * Math.LOG2E) : 32;
      }
    });
  }, {
    62: 62
  }],
  189: [function (t, n, r) {
    var e = t(62),
        i = Math.exp;
    e(e.S, "Math", {
      cosh: function cosh(t) {
        return (i(t = +t) + i(-t)) / 2;
      }
    });
  }, {
    62: 62
  }],
  190: [function (t, n, r) {
    var e = t(62),
        i = t(90);
    e(e.S + e.F * (i != Math.expm1), "Math", {
      expm1: i
    });
  }, {
    62: 62,
    90: 90
  }],
  191: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Math", {
      fround: t(91)
    });
  }, {
    62: 62,
    91: 91
  }],
  192: [function (t, n, r) {
    var e = t(62),
        a = Math.abs;
    e(e.S, "Math", {
      hypot: function hypot(t, n) {
        for (var r, e, i = 0, o = 0, u = arguments.length, c = 0; o < u;) c < (r = a(arguments[o++])) ? (i = i * (e = c / r) * e + 1, c = r) : i += 0 < r ? (e = r / c) * e : r;

        return c === 1 / 0 ? 1 / 0 : c * Math.sqrt(i);
      }
    });
  }, {
    62: 62
  }],
  193: [function (t, n, r) {
    var e = t(62),
        i = Math.imul;
    e(e.S + e.F * t(64)(function () {
      return -5 != i(4294967295, 5) || 2 != i.length;
    }), "Math", {
      imul: function imul(t, n) {
        var r = 65535,
            e = +t,
            i = +n,
            o = r & e,
            u = r & i;
        return 0 | o * u + ((r & e >>> 16) * u + o * (r & i >>> 16) << 16 >>> 0);
      }
    });
  }, {
    62: 62,
    64: 64
  }],
  194: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Math", {
      log10: function log10(t) {
        return Math.log(t) * Math.LOG10E;
      }
    });
  }, {
    62: 62
  }],
  195: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Math", {
      log1p: t(92)
    });
  }, {
    62: 62,
    92: 92
  }],
  196: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Math", {
      log2: function log2(t) {
        return Math.log(t) / Math.LN2;
      }
    });
  }, {
    62: 62
  }],
  197: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Math", {
      sign: t(93)
    });
  }, {
    62: 62,
    93: 93
  }],
  198: [function (t, n, r) {
    var e = t(62),
        i = t(90),
        o = Math.exp;
    e(e.S + e.F * t(64)(function () {
      return -2e-17 != !Math.sinh(-2e-17);
    }), "Math", {
      sinh: function sinh(t) {
        return Math.abs(t = +t) < 1 ? (i(t) - i(-t)) / 2 : (o(t - 1) - o(-t - 1)) * (Math.E / 2);
      }
    });
  }, {
    62: 62,
    64: 64,
    90: 90
  }],
  199: [function (t, n, r) {
    var e = t(62),
        i = t(90),
        o = Math.exp;
    e(e.S, "Math", {
      tanh: function tanh(t) {
        var n = i(t = +t),
            r = i(-t);
        return n == 1 / 0 ? 1 : r == 1 / 0 ? -1 : (n - r) / (o(t) + o(-t));
      }
    });
  }, {
    62: 62,
    90: 90
  }],
  200: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Math", {
      trunc: function trunc(t) {
        return (0 < t ? Math.floor : Math.ceil)(t);
      }
    });
  }, {
    62: 62
  }],
  201: [function (t, n, r) {
    "use strict";

    var e = t(70),
        i = t(71),
        o = t(48),
        u = t(75),
        s = t(143),
        c = t(64),
        a = t(103).f,
        f = t(101).f,
        l = t(99).f,
        h = t(134).trim,
        p = "Number",
        v = e[p],
        y = v,
        g = v.prototype,
        d = o(t(98)(g)) == p,
        x = "trim" in String.prototype,
        m = function (t) {
      var n = s(t, !1);

      if ("string" == typeof n && 2 < n.length) {
        var r,
            e,
            i,
            o = (n = x ? n.trim() : h(n, 3)).charCodeAt(0);

        if (43 === o || 45 === o) {
          if (88 === (r = n.charCodeAt(2)) || 120 === r) return NaN;
        } else if (48 === o) {
          switch (n.charCodeAt(1)) {
            case 66:
            case 98:
              e = 2, i = 49;
              break;

            case 79:
            case 111:
              e = 8, i = 55;
              break;

            default:
              return +n;
          }

          for (var u, c = n.slice(2), a = 0, f = c.length; a < f; a++) if ((u = c.charCodeAt(a)) < 48 || i < u) return NaN;

          return parseInt(c, e);
        }
      }

      return +n;
    };

    if (!v(" 0o1") || !v("0b1") || v("+0x1")) {
      v = function Number(t) {
        var n = arguments.length < 1 ? 0 : t,
            r = this;
        return r instanceof v && (d ? c(function () {
          g.valueOf.call(r);
        }) : o(r) != p) ? u(new y(m(n)), r, v) : m(n);
      };

      for (var b, S = t(58) ? a(y) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), w = 0; S.length > w; w++) i(y, b = S[w]) && !i(v, b) && l(v, b, f(y, b));

      (v.prototype = g).constructor = v, t(118)(e, p, v);
    }
  }, {
    101: 101,
    103: 103,
    118: 118,
    134: 134,
    143: 143,
    48: 48,
    58: 58,
    64: 64,
    70: 70,
    71: 71,
    75: 75,
    98: 98,
    99: 99
  }],
  202: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Number", {
      EPSILON: Math.pow(2, -52)
    });
  }, {
    62: 62
  }],
  203: [function (t, n, r) {
    var e = t(62),
        i = t(70).isFinite;
    e(e.S, "Number", {
      isFinite: function isFinite(t) {
        return "number" == typeof t && i(t);
      }
    });
  }, {
    62: 62,
    70: 70
  }],
  204: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Number", {
      isInteger: t(80)
    });
  }, {
    62: 62,
    80: 80
  }],
  205: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Number", {
      isNaN: function isNaN(t) {
        return t != t;
      }
    });
  }, {
    62: 62
  }],
  206: [function (t, n, r) {
    var e = t(62),
        i = t(80),
        o = Math.abs;
    e(e.S, "Number", {
      isSafeInteger: function isSafeInteger(t) {
        return i(t) && o(t) <= 9007199254740991;
      }
    });
  }, {
    62: 62,
    80: 80
  }],
  207: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Number", {
      MAX_SAFE_INTEGER: 9007199254740991
    });
  }, {
    62: 62
  }],
  208: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Number", {
      MIN_SAFE_INTEGER: -9007199254740991
    });
  }, {
    62: 62
  }],
  209: [function (t, n, r) {
    var e = t(62),
        i = t(112);
    e(e.S + e.F * (Number.parseFloat != i), "Number", {
      parseFloat: i
    });
  }, {
    112: 112,
    62: 62
  }],
  210: [function (t, n, r) {
    var e = t(62),
        i = t(113);
    e(e.S + e.F * (Number.parseInt != i), "Number", {
      parseInt: i
    });
  }, {
    113: 113,
    62: 62
  }],
  211: [function (t, n, r) {
    "use strict";

    var e = t(62),
        f = t(139),
        s = t(34),
        l = t(133),
        i = 1..toFixed,
        o = Math.floor,
        u = [0, 0, 0, 0, 0, 0],
        h = "Number.toFixed: incorrect invocation!",
        p = function (t, n) {
      for (var r = -1, e = n; ++r < 6;) e += t * u[r], u[r] = e % 1e7, e = o(e / 1e7);
    },
        v = function (t) {
      for (var n = 6, r = 0; 0 <= --n;) r += u[n], u[n] = o(r / t), r = r % t * 1e7;
    },
        y = function () {
      for (var t = 6, n = ""; 0 <= --t;) if ("" !== n || 0 === t || 0 !== u[t]) {
        var r = String(u[t]);
        n = "" === n ? r : n + l.call("0", 7 - r.length) + r;
      }

      return n;
    },
        g = function (t, n, r) {
      return 0 === n ? r : n % 2 == 1 ? g(t, n - 1, r * t) : g(t * t, n / 2, r);
    };

    e(e.P + e.F * (!!i && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== 0xde0b6b3a7640080.toFixed(0)) || !t(64)(function () {
      i.call({});
    })), "Number", {
      toFixed: function toFixed(t) {
        var n,
            r,
            e,
            i,
            o = s(this, h),
            u = f(t),
            c = "",
            a = "0";
        if (u < 0 || 20 < u) throw RangeError(h);
        if (o != o) return "NaN";
        if (o <= -1e21 || 1e21 <= o) return String(o);
        if (o < 0 && (c = "-", o = -o), 1e-21 < o) if (r = (n = function (t) {
          for (var n = 0, r = t; 4096 <= r;) n += 12, r /= 4096;

          for (; 2 <= r;) n += 1, r /= 2;

          return n;
        }(o * g(2, 69, 1)) - 69) < 0 ? o * g(2, -n, 1) : o / g(2, n, 1), r *= 4503599627370496, 0 < (n = 52 - n)) {
          for (p(0, r), e = u; 7 <= e;) p(1e7, 0), e -= 7;

          for (p(g(10, e, 1), 0), e = n - 1; 23 <= e;) v(1 << 23), e -= 23;

          v(1 << e), p(1, 1), v(2), a = y();
        } else p(0, r), p(1 << -n, 0), a = y() + l.call("0", u);
        return a = 0 < u ? c + ((i = a.length) <= u ? "0." + l.call("0", u - i) + a : a.slice(0, i - u) + "." + a.slice(i - u)) : c + a;
      }
    });
  }, {
    133: 133,
    139: 139,
    34: 34,
    62: 62,
    64: 64
  }],
  212: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(64),
        o = t(34),
        u = 1..toPrecision;
    e(e.P + e.F * (i(function () {
      return "1" !== u.call(1, void 0);
    }) || !i(function () {
      u.call({});
    })), "Number", {
      toPrecision: function toPrecision(t) {
        var n = o(this, "Number#toPrecision: incorrect invocation!");
        return void 0 === t ? u.call(n) : u.call(n, t);
      }
    });
  }, {
    34: 34,
    62: 62,
    64: 64
  }],
  213: [function (t, n, r) {
    var e = t(62);
    e(e.S + e.F, "Object", {
      assign: t(97)
    });
  }, {
    62: 62,
    97: 97
  }],
  214: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Object", {
      create: t(98)
    });
  }, {
    62: 62,
    98: 98
  }],
  215: [function (t, n, r) {
    var e = t(62);
    e(e.S + e.F * !t(58), "Object", {
      defineProperties: t(100)
    });
  }, {
    100: 100,
    58: 58,
    62: 62
  }],
  216: [function (t, n, r) {
    var e = t(62);
    e(e.S + e.F * !t(58), "Object", {
      defineProperty: t(99).f
    });
  }, {
    58: 58,
    62: 62,
    99: 99
  }],
  217: [function (t, n, r) {
    var e = t(81),
        i = t(94).onFreeze;
    t(109)("freeze", function (n) {
      return function freeze(t) {
        return n && e(t) ? n(i(t)) : t;
      };
    });
  }, {
    109: 109,
    81: 81,
    94: 94
  }],
  218: [function (t, n, r) {
    var e = t(140),
        i = t(101).f;
    t(109)("getOwnPropertyDescriptor", function () {
      return function getOwnPropertyDescriptor(t, n) {
        return i(e(t), n);
      };
    });
  }, {
    101: 101,
    109: 109,
    140: 140
  }],
  219: [function (t, n, r) {
    t(109)("getOwnPropertyNames", function () {
      return t(102).f;
    });
  }, {
    102: 102,
    109: 109
  }],
  220: [function (t, n, r) {
    var e = t(142),
        i = t(105);
    t(109)("getPrototypeOf", function () {
      return function getPrototypeOf(t) {
        return i(e(t));
      };
    });
  }, {
    105: 105,
    109: 109,
    142: 142
  }],
  221: [function (t, n, r) {
    var e = t(81);
    t(109)("isExtensible", function (n) {
      return function isExtensible(t) {
        return !!e(t) && (!n || n(t));
      };
    });
  }, {
    109: 109,
    81: 81
  }],
  222: [function (t, n, r) {
    var e = t(81);
    t(109)("isFrozen", function (n) {
      return function isFrozen(t) {
        return !e(t) || !!n && n(t);
      };
    });
  }, {
    109: 109,
    81: 81
  }],
  223: [function (t, n, r) {
    var e = t(81);
    t(109)("isSealed", function (n) {
      return function isSealed(t) {
        return !e(t) || !!n && n(t);
      };
    });
  }, {
    109: 109,
    81: 81
  }],
  224: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Object", {
      is: t(121)
    });
  }, {
    121: 121,
    62: 62
  }],
  225: [function (t, n, r) {
    var e = t(142),
        i = t(107);
    t(109)("keys", function () {
      return function keys(t) {
        return i(e(t));
      };
    });
  }, {
    107: 107,
    109: 109,
    142: 142
  }],
  226: [function (t, n, r) {
    var e = t(81),
        i = t(94).onFreeze;
    t(109)("preventExtensions", function (n) {
      return function preventExtensions(t) {
        return n && e(t) ? n(i(t)) : t;
      };
    });
  }, {
    109: 109,
    81: 81,
    94: 94
  }],
  227: [function (t, n, r) {
    var e = t(81),
        i = t(94).onFreeze;
    t(109)("seal", function (n) {
      return function seal(t) {
        return n && e(t) ? n(i(t)) : t;
      };
    });
  }, {
    109: 109,
    81: 81,
    94: 94
  }],
  228: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Object", {
      setPrototypeOf: t(122).set
    });
  }, {
    122: 122,
    62: 62
  }],
  229: [function (t, n, r) {
    "use strict";

    var e = t(47),
        i = {};
    i[t(152)("toStringTag")] = "z", i + "" != "[object z]" && t(118)(Object.prototype, "toString", function toString() {
      return "[object " + e(this) + "]";
    }, !0);
  }, {
    118: 118,
    152: 152,
    47: 47
  }],
  230: [function (t, n, r) {
    var e = t(62),
        i = t(112);
    e(e.G + e.F * (parseFloat != i), {
      parseFloat: i
    });
  }, {
    112: 112,
    62: 62
  }],
  231: [function (t, n, r) {
    var e = t(62),
        i = t(113);
    e(e.G + e.F * (parseInt != i), {
      parseInt: i
    });
  }, {
    113: 113,
    62: 62
  }],
  232: [function (r, t, n) {
    "use strict";

    var e,
        i,
        o,
        u,
        c = r(89),
        a = r(70),
        f = r(54),
        s = r(47),
        l = r(62),
        h = r(81),
        p = r(33),
        v = r(37),
        y = r(68),
        g = r(127),
        d = r(136).set,
        x = r(95)(),
        m = r(96),
        b = r(114),
        S = r(148),
        w = r(115),
        _ = "Promise",
        E = a.TypeError,
        F = a.process,
        I = F && F.versions,
        O = I && I.v8 || "",
        P = a[_],
        A = "process" == s(F),
        M = function () {},
        k = i = m.f,
        N = !!function () {
      try {
        var t = P.resolve(1),
            n = (t.constructor = {})[r(152)("species")] = function (t) {
          t(M, M);
        };

        return (A || "function" == typeof PromiseRejectionEvent) && t.then(M) instanceof n && 0 !== O.indexOf("6.6") && -1 === S.indexOf("Chrome/66");
      } catch (t) {}
    }(),
        j = function (t) {
      var n;
      return !(!h(t) || "function" != typeof (n = t.then)) && n;
    },
        T = function (s, r) {
      if (!s._n) {
        s._n = !0;
        var e = s._c;
        x(function () {
          for (var a = s._v, f = 1 == s._s, t = 0, n = function (t) {
            var n,
                r,
                e,
                i = f ? t.ok : t.fail,
                o = t.resolve,
                u = t.reject,
                c = t.domain;

            try {
              i ? (f || (2 == s._h && C(s), s._h = 1), !0 === i ? n = a : (c && c.enter(), n = i(a), c && (c.exit(), e = !0)), n === t.promise ? u(E("Promise-chain cycle")) : (r = j(n)) ? r.call(n, o, u) : o(n)) : u(a);
            } catch (t) {
              c && !e && c.exit(), u(t);
            }
          }; e.length > t;) n(e[t++]);

          s._c = [], s._n = !1, r && !s._h && R(s);
        });
      }
    },
        R = function (o) {
      d.call(a, function () {
        var t,
            n,
            r,
            e = o._v,
            i = L(o);
        if (i && (t = b(function () {
          A ? F.emit("unhandledRejection", e, o) : (n = a.onunhandledrejection) ? n({
            promise: o,
            reason: e
          }) : (r = a.console) && r.error && r.error("Unhandled promise rejection", e);
        }), o._h = A || L(o) ? 2 : 1), o._a = void 0, i && t.e) throw t.v;
      });
    },
        L = function (t) {
      return 1 !== t._h && 0 === (t._a || t._c).length;
    },
        C = function (n) {
      d.call(a, function () {
        var t;
        A ? F.emit("rejectionHandled", n) : (t = a.onrejectionhandled) && t({
          promise: n,
          reason: n._v
        });
      });
    },
        G = function (t) {
      var n = this;
      n._d || (n._d = !0, (n = n._w || n)._v = t, n._s = 2, n._a || (n._a = n._c.slice()), T(n, !0));
    },
        D = function (t) {
      var r,
          e = this;

      if (!e._d) {
        e._d = !0, e = e._w || e;

        try {
          if (e === t) throw E("Promise can't be resolved itself");
          (r = j(t)) ? x(function () {
            var n = {
              _w: e,
              _d: !1
            };

            try {
              r.call(t, f(D, n, 1), f(G, n, 1));
            } catch (t) {
              G.call(n, t);
            }
          }) : (e._v = t, e._s = 1, T(e, !1));
        } catch (t) {
          G.call({
            _w: e,
            _d: !1
          }, t);
        }
      }
    };

    N || (P = function Promise(t) {
      v(this, P, _, "_h"), p(t), e.call(this);

      try {
        t(f(D, this, 1), f(G, this, 1));
      } catch (t) {
        G.call(this, t);
      }
    }, (e = function Promise(t) {
      this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1;
    }).prototype = r(117)(P.prototype, {
      then: function then(t, n) {
        var r = k(g(this, P));
        return r.ok = "function" != typeof t || t, r.fail = "function" == typeof n && n, r.domain = A ? F.domain : void 0, this._c.push(r), this._a && this._a.push(r), this._s && T(this, !1), r.promise;
      },
      catch: function (t) {
        return this.then(void 0, t);
      }
    }), o = function () {
      var t = new e();
      this.promise = t, this.resolve = f(D, t, 1), this.reject = f(G, t, 1);
    }, m.f = k = function (t) {
      return t === P || t === u ? new o(t) : i(t);
    }), l(l.G + l.W + l.F * !N, {
      Promise: P
    }), r(124)(P, _), r(123)(_), u = r(52)[_], l(l.S + l.F * !N, _, {
      reject: function reject(t) {
        var n = k(this);
        return (0, n.reject)(t), n.promise;
      }
    }), l(l.S + l.F * (c || !N), _, {
      resolve: function resolve(t) {
        return w(c && this === u ? P : this, t);
      }
    }), l(l.S + l.F * !(N && r(86)(function (t) {
      P.all(t).catch(M);
    })), _, {
      all: function all(t) {
        var u = this,
            n = k(u),
            c = n.resolve,
            a = n.reject,
            r = b(function () {
          var e = [],
              i = 0,
              o = 1;
          y(t, !1, function (t) {
            var n = i++,
                r = !1;
            e.push(void 0), o++, u.resolve(t).then(function (t) {
              r || (r = !0, e[n] = t, --o || c(e));
            }, a);
          }), --o || c(e);
        });
        return r.e && a(r.v), n.promise;
      },
      race: function race(t) {
        var n = this,
            r = k(n),
            e = r.reject,
            i = b(function () {
          y(t, !1, function (t) {
            n.resolve(t).then(r.resolve, e);
          });
        });
        return i.e && e(i.v), r.promise;
      }
    });
  }, {
    114: 114,
    115: 115,
    117: 117,
    123: 123,
    124: 124,
    127: 127,
    136: 136,
    148: 148,
    152: 152,
    33: 33,
    37: 37,
    47: 47,
    52: 52,
    54: 54,
    62: 62,
    68: 68,
    70: 70,
    81: 81,
    86: 86,
    89: 89,
    95: 95,
    96: 96
  }],
  233: [function (t, n, r) {
    var e = t(62),
        o = t(33),
        u = t(38),
        c = (t(70).Reflect || {}).apply,
        a = Function.apply;
    e(e.S + e.F * !t(64)(function () {
      c(function () {});
    }), "Reflect", {
      apply: function apply(t, n, r) {
        var e = o(t),
            i = u(r);
        return c ? c(e, n, i) : a.call(e, n, i);
      }
    });
  }, {
    33: 33,
    38: 38,
    62: 62,
    64: 64,
    70: 70
  }],
  234: [function (t, n, r) {
    var e = t(62),
        c = t(98),
        a = t(33),
        f = t(38),
        s = t(81),
        i = t(64),
        l = t(46),
        h = (t(70).Reflect || {}).construct,
        p = i(function () {
      function F() {}

      return !(h(function () {}, [], F) instanceof F);
    }),
        v = !i(function () {
      h(function () {});
    });
    e(e.S + e.F * (p || v), "Reflect", {
      construct: function construct(t, n) {
        a(t), f(n);
        var r = arguments.length < 3 ? t : a(arguments[2]);
        if (v && !p) return h(t, n, r);

        if (t == r) {
          switch (n.length) {
            case 0:
              return new t();

            case 1:
              return new t(n[0]);

            case 2:
              return new t(n[0], n[1]);

            case 3:
              return new t(n[0], n[1], n[2]);

            case 4:
              return new t(n[0], n[1], n[2], n[3]);
          }

          var e = [null];
          return e.push.apply(e, n), new (l.apply(t, e))();
        }

        var i = r.prototype,
            o = c(s(i) ? i : Object.prototype),
            u = Function.apply.call(t, o, n);
        return s(u) ? u : o;
      }
    });
  }, {
    33: 33,
    38: 38,
    46: 46,
    62: 62,
    64: 64,
    70: 70,
    81: 81,
    98: 98
  }],
  235: [function (t, n, r) {
    var e = t(99),
        i = t(62),
        o = t(38),
        u = t(143);
    i(i.S + i.F * t(64)(function () {
      Reflect.defineProperty(e.f({}, 1, {
        value: 1
      }), 1, {
        value: 2
      });
    }), "Reflect", {
      defineProperty: function defineProperty(t, n, r) {
        o(t), n = u(n, !0), o(r);

        try {
          return e.f(t, n, r), !0;
        } catch (t) {
          return !1;
        }
      }
    });
  }, {
    143: 143,
    38: 38,
    62: 62,
    64: 64,
    99: 99
  }],
  236: [function (t, n, r) {
    var e = t(62),
        i = t(101).f,
        o = t(38);
    e(e.S, "Reflect", {
      deleteProperty: function deleteProperty(t, n) {
        var r = i(o(t), n);
        return !(r && !r.configurable) && delete t[n];
      }
    });
  }, {
    101: 101,
    38: 38,
    62: 62
  }],
  237: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(38),
        o = function (t) {
      this._t = i(t), this._i = 0;
      var n,
          r = this._k = [];

      for (n in t) r.push(n);
    };

    t(84)(o, "Object", function () {
      var t,
          n = this._k;

      do {
        if (this._i >= n.length) return {
          value: void 0,
          done: !0
        };
      } while (!((t = n[this._i++]) in this._t));

      return {
        value: t,
        done: !1
      };
    }), e(e.S, "Reflect", {
      enumerate: function enumerate(t) {
        return new o(t);
      }
    });
  }, {
    38: 38,
    62: 62,
    84: 84
  }],
  238: [function (t, n, r) {
    var e = t(101),
        i = t(62),
        o = t(38);
    i(i.S, "Reflect", {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(t, n) {
        return e.f(o(t), n);
      }
    });
  }, {
    101: 101,
    38: 38,
    62: 62
  }],
  239: [function (t, n, r) {
    var e = t(62),
        i = t(105),
        o = t(38);
    e(e.S, "Reflect", {
      getPrototypeOf: function getPrototypeOf(t) {
        return i(o(t));
      }
    });
  }, {
    105: 105,
    38: 38,
    62: 62
  }],
  240: [function (t, n, r) {
    var o = t(101),
        u = t(105),
        c = t(71),
        e = t(62),
        a = t(81),
        f = t(38);
    e(e.S, "Reflect", {
      get: function get(t, n) {
        var r,
            e,
            i = arguments.length < 3 ? t : arguments[2];
        return f(t) === i ? t[n] : (r = o.f(t, n)) ? c(r, "value") ? r.value : void 0 !== r.get ? r.get.call(i) : void 0 : a(e = u(t)) ? get(e, n, i) : void 0;
      }
    });
  }, {
    101: 101,
    105: 105,
    38: 38,
    62: 62,
    71: 71,
    81: 81
  }],
  241: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Reflect", {
      has: function has(t, n) {
        return n in t;
      }
    });
  }, {
    62: 62
  }],
  242: [function (t, n, r) {
    var e = t(62),
        i = t(38),
        o = Object.isExtensible;
    e(e.S, "Reflect", {
      isExtensible: function isExtensible(t) {
        return i(t), !o || o(t);
      }
    });
  }, {
    38: 38,
    62: 62
  }],
  243: [function (t, n, r) {
    var e = t(62);
    e(e.S, "Reflect", {
      ownKeys: t(111)
    });
  }, {
    111: 111,
    62: 62
  }],
  244: [function (t, n, r) {
    var e = t(62),
        i = t(38),
        o = Object.preventExtensions;
    e(e.S, "Reflect", {
      preventExtensions: function preventExtensions(t) {
        i(t);

        try {
          return o && o(t), !0;
        } catch (t) {
          return !1;
        }
      }
    });
  }, {
    38: 38,
    62: 62
  }],
  245: [function (t, n, r) {
    var e = t(62),
        i = t(122);
    i && e(e.S, "Reflect", {
      setPrototypeOf: function setPrototypeOf(t, n) {
        i.check(t, n);

        try {
          return i.set(t, n), !0;
        } catch (t) {
          return !1;
        }
      }
    });
  }, {
    122: 122,
    62: 62
  }],
  246: [function (t, n, r) {
    var c = t(99),
        a = t(101),
        f = t(105),
        s = t(71),
        e = t(62),
        l = t(116),
        h = t(38),
        p = t(81);
    e(e.S, "Reflect", {
      set: function set(t, n, r) {
        var e,
            i,
            o = arguments.length < 4 ? t : arguments[3],
            u = a.f(h(t), n);

        if (!u) {
          if (p(i = f(t))) return set(i, n, r, o);
          u = l(0);
        }

        if (s(u, "value")) {
          if (!1 === u.writable || !p(o)) return !1;

          if (e = a.f(o, n)) {
            if (e.get || e.set || !1 === e.writable) return !1;
            e.value = r, c.f(o, n, e);
          } else c.f(o, n, l(0, r));

          return !0;
        }

        return void 0 !== u.set && (u.set.call(o, r), !0);
      }
    });
  }, {
    101: 101,
    105: 105,
    116: 116,
    38: 38,
    62: 62,
    71: 71,
    81: 81,
    99: 99
  }],
  247: [function (t, n, r) {
    var e = t(70),
        o = t(75),
        i = t(99).f,
        u = t(103).f,
        c = t(82),
        a = t(66),
        f = e.RegExp,
        s = f,
        l = f.prototype,
        h = /a/g,
        p = /a/g,
        v = new f(h) !== h;

    if (t(58) && (!v || t(64)(function () {
      return p[t(152)("match")] = !1, f(h) != h || f(p) == p || "/a/i" != f(h, "i");
    }))) {
      f = function RegExp(t, n) {
        var r = this instanceof f,
            e = c(t),
            i = void 0 === n;
        return !r && e && t.constructor === f && i ? t : o(v ? new s(e && !i ? t.source : t, n) : s((e = t instanceof f) ? t.source : t, e && i ? a.call(t) : n), r ? this : l, f);
      };

      for (var y = function (n) {
        (n in f) || i(f, n, {
          configurable: !0,
          get: function () {
            return s[n];
          },
          set: function (t) {
            s[n] = t;
          }
        });
      }, g = u(s), d = 0; g.length > d;) y(g[d++]);

      (l.constructor = f).prototype = l, t(118)(e, "RegExp", f);
    }

    t(123)("RegExp");
  }, {
    103: 103,
    118: 118,
    123: 123,
    152: 152,
    58: 58,
    64: 64,
    66: 66,
    70: 70,
    75: 75,
    82: 82,
    99: 99
  }],
  248: [function (t, n, r) {
    "use strict";

    var e = t(120);
    t(62)({
      target: "RegExp",
      proto: !0,
      forced: e !== /./.exec
    }, {
      exec: e
    });
  }, {
    120: 120,
    62: 62
  }],
  249: [function (t, n, r) {
    t(58) && "g" != /./g.flags && t(99).f(RegExp.prototype, "flags", {
      configurable: !0,
      get: t(66)
    });
  }, {
    58: 58,
    66: 66,
    99: 99
  }],
  250: [function (t, n, r) {
    "use strict";

    var l = t(38),
        h = t(141),
        p = t(36),
        v = t(119);
    t(65)("match", 1, function (e, i, f, s) {
      return [function match(t) {
        var n = e(this),
            r = null == t ? void 0 : t[i];
        return void 0 !== r ? r.call(t, n) : new RegExp(t)[i](String(n));
      }, function (t) {
        var n = s(f, t, this);
        if (n.done) return n.value;
        var r = l(t),
            e = String(this);
        if (!r.global) return v(r, e);

        for (var i, o = r.unicode, u = [], c = r.lastIndex = 0; null !== (i = v(r, e));) {
          var a = String(i[0]);
          "" === (u[c] = a) && (r.lastIndex = p(e, h(r.lastIndex), o)), c++;
        }

        return 0 === c ? null : u;
      }];
    });
  }, {
    119: 119,
    141: 141,
    36: 36,
    38: 38,
    65: 65
  }],
  251: [function (t, n, r) {
    "use strict";

    var _ = t(38),
        e = t(142),
        E = t(141),
        F = t(139),
        I = t(36),
        O = t(119),
        P = Math.max,
        A = Math.min,
        h = Math.floor,
        p = /\$([$&`']|\d\d?|<[^>]*>)/g,
        v = /\$([$&`']|\d\d?)/g;

    t(65)("replace", 2, function (i, o, S, w) {
      return [function replace(t, n) {
        var r = i(this),
            e = null == t ? void 0 : t[o];
        return void 0 !== e ? e.call(t, r, n) : S.call(String(r), t, n);
      }, function (t, n) {
        var r = w(S, t, this, n);
        if (r.done) return r.value;

        var e = _(t),
            i = String(this),
            o = "function" == typeof n;

        o || (n = String(n));
        var u = e.global;

        if (u) {
          var c = e.unicode;
          e.lastIndex = 0;
        }

        for (var a = [];;) {
          var f = O(e, i);
          if (null === f) break;
          if (a.push(f), !u) break;
          "" === String(f[0]) && (e.lastIndex = I(i, E(e.lastIndex), c));
        }

        for (var s, l = "", h = 0, p = 0; p < a.length; p++) {
          f = a[p];

          for (var v = String(f[0]), y = P(A(F(f.index), i.length), 0), g = [], d = 1; d < f.length; d++) g.push(void 0 === (s = f[d]) ? s : String(s));

          var x = f.groups;

          if (o) {
            var m = [v].concat(g, y, i);
            void 0 !== x && m.push(x);
            var b = String(n.apply(void 0, m));
          } else b = getSubstitution(v, i, y, g, x, n);

          h <= y && (l += i.slice(h, y) + b, h = y + v.length);
        }

        return l + i.slice(h);
      }];

      function getSubstitution(o, u, c, a, f, t) {
        var s = c + o.length,
            l = a.length,
            n = v;
        return void 0 !== f && (f = e(f), n = p), S.call(t, n, function (t, n) {
          var r;

          switch (n.charAt(0)) {
            case "$":
              return "$";

            case "&":
              return o;

            case "`":
              return u.slice(0, c);

            case "'":
              return u.slice(s);

            case "<":
              r = f[n.slice(1, -1)];
              break;

            default:
              var e = +n;
              if (0 === e) return t;

              if (l < e) {
                var i = h(e / 10);
                return 0 === i ? t : i <= l ? void 0 === a[i - 1] ? n.charAt(1) : a[i - 1] + n.charAt(1) : t;
              }

              r = a[e - 1];
          }

          return void 0 === r ? "" : r;
        });
      }
    });
  }, {
    119: 119,
    139: 139,
    141: 141,
    142: 142,
    36: 36,
    38: 38,
    65: 65
  }],
  252: [function (t, n, r) {
    "use strict";

    var a = t(38),
        f = t(121),
        s = t(119);
    t(65)("search", 1, function (e, i, u, c) {
      return [function search(t) {
        var n = e(this),
            r = null == t ? void 0 : t[i];
        return void 0 !== r ? r.call(t, n) : new RegExp(t)[i](String(n));
      }, function (t) {
        var n = c(u, t, this);
        if (n.done) return n.value;
        var r = a(t),
            e = String(this),
            i = r.lastIndex;
        f(i, 0) || (r.lastIndex = 0);
        var o = s(r, e);
        return f(r.lastIndex, i) || (r.lastIndex = i), null === o ? -1 : o.index;
      }];
    });
  }, {
    119: 119,
    121: 121,
    38: 38,
    65: 65
  }],
  253: [function (t, n, r) {
    "use strict";

    var l = t(82),
        m = t(38),
        b = t(127),
        S = t(36),
        w = t(141),
        _ = t(119),
        h = t(120),
        e = t(64),
        E = Math.min,
        p = [].push,
        u = "split",
        v = "length",
        y = "lastIndex",
        F = 4294967295,
        I = !e(function () {
      RegExp(F, "y");
    });

    t(65)("split", 2, function (i, o, g, d) {
      var x;
      return x = "c" == "abbc"[u](/(b)*/)[1] || 4 != "test"[u](/(?:)/, -1)[v] || 2 != "ab"[u](/(?:ab)*/)[v] || 4 != "."[u](/(.?)(.?)/)[v] || 1 < "."[u](/()()/)[v] || ""[u](/.?/)[v] ? function (t, n) {
        var r = String(this);
        if (void 0 === t && 0 === n) return [];
        if (!l(t)) return g.call(r, t, n);

        for (var e, i, o, u = [], c = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), a = 0, f = void 0 === n ? F : n >>> 0, s = new RegExp(t.source, c + "g"); (e = h.call(s, r)) && !(a < (i = s[y]) && (u.push(r.slice(a, e.index)), 1 < e[v] && e.index < r[v] && p.apply(u, e.slice(1)), o = e[0][v], a = i, u[v] >= f));) s[y] === e.index && s[y]++;

        return a === r[v] ? !o && s.test("") || u.push("") : u.push(r.slice(a)), u[v] > f ? u.slice(0, f) : u;
      } : "0"[u](void 0, 0)[v] ? function (t, n) {
        return void 0 === t && 0 === n ? [] : g.call(this, t, n);
      } : g, [function split(t, n) {
        var r = i(this),
            e = null == t ? void 0 : t[o];
        return void 0 !== e ? e.call(t, r, n) : x.call(String(r), t, n);
      }, function (t, n) {
        var r = d(x, t, this, n, x !== g);
        if (r.done) return r.value;
        var e = m(t),
            i = String(this),
            o = b(e, RegExp),
            u = e.unicode,
            c = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (I ? "y" : "g"),
            a = new o(I ? e : "^(?:" + e.source + ")", c),
            f = void 0 === n ? F : n >>> 0;
        if (0 === f) return [];
        if (0 === i.length) return null === _(a, i) ? [i] : [];

        for (var s = 0, l = 0, h = []; l < i.length;) {
          a.lastIndex = I ? l : 0;

          var p,
              v = _(a, I ? i : i.slice(l));

          if (null === v || (p = E(w(a.lastIndex + (I ? 0 : l)), i.length)) === s) l = S(i, l, u);else {
            if (h.push(i.slice(s, l)), h.length === f) return h;

            for (var y = 1; y <= v.length - 1; y++) if (h.push(v[y]), h.length === f) return h;

            l = s = p;
          }
        }

        return h.push(i.slice(s)), h;
      }];
    });
  }, {
    119: 119,
    120: 120,
    127: 127,
    141: 141,
    36: 36,
    38: 38,
    64: 64,
    65: 65,
    82: 82
  }],
  254: [function (n, t, r) {
    "use strict";

    n(249);

    var e = n(38),
        i = n(66),
        o = n(58),
        u = "toString",
        c = /./[u],
        a = function (t) {
      n(118)(RegExp.prototype, u, t, !0);
    };

    n(64)(function () {
      return "/a/b" != c.call({
        source: "a",
        flags: "b"
      });
    }) ? a(function toString() {
      var t = e(this);
      return "/".concat(t.source, "/", "flags" in t ? t.flags : !o && t instanceof RegExp ? i.call(t) : void 0);
    }) : c.name != u && a(function toString() {
      return c.call(this);
    });
  }, {
    118: 118,
    249: 249,
    38: 38,
    58: 58,
    64: 64,
    66: 66
  }],
  255: [function (t, n, r) {
    "use strict";

    var e = t(49),
        i = t(149);
    n.exports = t(51)("Set", function (t) {
      return function Set() {
        return t(this, 0 < arguments.length ? arguments[0] : void 0);
      };
    }, {
      add: function add(t) {
        return e.def(i(this, "Set"), t = 0 === t ? 0 : t, t);
      }
    }, e);
  }, {
    149: 149,
    49: 49,
    51: 51
  }],
  256: [function (t, n, r) {
    "use strict";

    t(131)("anchor", function (n) {
      return function anchor(t) {
        return n(this, "a", "name", t);
      };
    });
  }, {
    131: 131
  }],
  257: [function (t, n, r) {
    "use strict";

    t(131)("big", function (t) {
      return function big() {
        return t(this, "big", "", "");
      };
    });
  }, {
    131: 131
  }],
  258: [function (t, n, r) {
    "use strict";

    t(131)("blink", function (t) {
      return function blink() {
        return t(this, "blink", "", "");
      };
    });
  }, {
    131: 131
  }],
  259: [function (t, n, r) {
    "use strict";

    t(131)("bold", function (t) {
      return function bold() {
        return t(this, "b", "", "");
      };
    });
  }, {
    131: 131
  }],
  260: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(129)(!1);
    e(e.P, "String", {
      codePointAt: function codePointAt(t) {
        return i(this, t);
      }
    });
  }, {
    129: 129,
    62: 62
  }],
  261: [function (t, n, r) {
    "use strict";

    var e = t(62),
        u = t(141),
        c = t(130),
        a = "endsWith",
        f = ""[a];
    e(e.P + e.F * t(63)(a), "String", {
      endsWith: function endsWith(t) {
        var n = c(this, t, a),
            r = 1 < arguments.length ? arguments[1] : void 0,
            e = u(n.length),
            i = void 0 === r ? e : Math.min(u(r), e),
            o = String(t);
        return f ? f.call(n, o, i) : n.slice(i - o.length, i) === o;
      }
    });
  }, {
    130: 130,
    141: 141,
    62: 62,
    63: 63
  }],
  262: [function (t, n, r) {
    "use strict";

    t(131)("fixed", function (t) {
      return function fixed() {
        return t(this, "tt", "", "");
      };
    });
  }, {
    131: 131
  }],
  263: [function (t, n, r) {
    "use strict";

    t(131)("fontcolor", function (n) {
      return function fontcolor(t) {
        return n(this, "font", "color", t);
      };
    });
  }, {
    131: 131
  }],
  264: [function (t, n, r) {
    "use strict";

    t(131)("fontsize", function (n) {
      return function fontsize(t) {
        return n(this, "font", "size", t);
      };
    });
  }, {
    131: 131
  }],
  265: [function (t, n, r) {
    var e = t(62),
        o = t(137),
        u = String.fromCharCode,
        i = String.fromCodePoint;
    e(e.S + e.F * (!!i && 1 != i.length), "String", {
      fromCodePoint: function fromCodePoint(t) {
        for (var n, r = [], e = arguments.length, i = 0; i < e;) {
          if (n = +arguments[i++], o(n, 1114111) !== n) throw RangeError(n + " is not a valid code point");
          r.push(n < 65536 ? u(n) : u(55296 + ((n -= 65536) >> 10), n % 1024 + 56320));
        }

        return r.join("");
      }
    });
  }, {
    137: 137,
    62: 62
  }],
  266: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(130),
        o = "includes";
    e(e.P + e.F * t(63)(o), "String", {
      includes: function includes(t) {
        return !!~i(this, t, o).indexOf(t, 1 < arguments.length ? arguments[1] : void 0);
      }
    });
  }, {
    130: 130,
    62: 62,
    63: 63
  }],
  267: [function (t, n, r) {
    "use strict";

    t(131)("italics", function (t) {
      return function italics() {
        return t(this, "i", "", "");
      };
    });
  }, {
    131: 131
  }],
  268: [function (t, n, r) {
    "use strict";

    var e = t(129)(!0);
    t(85)(String, "String", function (t) {
      this._t = String(t), this._i = 0;
    }, function () {
      var t,
          n = this._t,
          r = this._i;
      return r >= n.length ? {
        value: void 0,
        done: !0
      } : (t = e(n, r), this._i += t.length, {
        value: t,
        done: !1
      });
    });
  }, {
    129: 129,
    85: 85
  }],
  269: [function (t, n, r) {
    "use strict";

    t(131)("link", function (n) {
      return function link(t) {
        return n(this, "a", "href", t);
      };
    });
  }, {
    131: 131
  }],
  270: [function (t, n, r) {
    var e = t(62),
        u = t(140),
        c = t(141);
    e(e.S, "String", {
      raw: function raw(t) {
        for (var n = u(t.raw), r = c(n.length), e = arguments.length, i = [], o = 0; o < r;) i.push(String(n[o++])), o < e && i.push(String(arguments[o]));

        return i.join("");
      }
    });
  }, {
    140: 140,
    141: 141,
    62: 62
  }],
  271: [function (t, n, r) {
    var e = t(62);
    e(e.P, "String", {
      repeat: t(133)
    });
  }, {
    133: 133,
    62: 62
  }],
  272: [function (t, n, r) {
    "use strict";

    t(131)("small", function (t) {
      return function small() {
        return t(this, "small", "", "");
      };
    });
  }, {
    131: 131
  }],
  273: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(141),
        o = t(130),
        u = "startsWith",
        c = ""[u];
    e(e.P + e.F * t(63)(u), "String", {
      startsWith: function startsWith(t) {
        var n = o(this, t, u),
            r = i(Math.min(1 < arguments.length ? arguments[1] : void 0, n.length)),
            e = String(t);
        return c ? c.call(n, e, r) : n.slice(r, r + e.length) === e;
      }
    });
  }, {
    130: 130,
    141: 141,
    62: 62,
    63: 63
  }],
  274: [function (t, n, r) {
    "use strict";

    t(131)("strike", function (t) {
      return function strike() {
        return t(this, "strike", "", "");
      };
    });
  }, {
    131: 131
  }],
  275: [function (t, n, r) {
    "use strict";

    t(131)("sub", function (t) {
      return function sub() {
        return t(this, "sub", "", "");
      };
    });
  }, {
    131: 131
  }],
  276: [function (t, n, r) {
    "use strict";

    t(131)("sup", function (t) {
      return function sup() {
        return t(this, "sup", "", "");
      };
    });
  }, {
    131: 131
  }],
  277: [function (t, n, r) {
    "use strict";

    t(134)("trim", function (t) {
      return function trim() {
        return t(this, 3);
      };
    });
  }, {
    134: 134
  }],
  278: [function (t, n, r) {
    "use strict";

    var e = t(70),
        u = t(71),
        i = t(58),
        o = t(62),
        c = t(118),
        a = t(94).KEY,
        f = t(64),
        s = t(126),
        l = t(124),
        h = t(147),
        p = t(152),
        v = t(151),
        y = t(150),
        g = t(61),
        d = t(79),
        x = t(38),
        m = t(81),
        b = t(140),
        S = t(143),
        w = t(116),
        _ = t(98),
        E = t(102),
        F = t(101),
        I = t(99),
        O = t(107),
        P = F.f,
        A = I.f,
        M = E.f,
        k = e.Symbol,
        N = e.JSON,
        j = N && N.stringify,
        T = "prototype",
        R = p("_hidden"),
        L = p("toPrimitive"),
        C = {}.propertyIsEnumerable,
        G = s("symbol-registry"),
        D = s("symbols"),
        U = s("op-symbols"),
        W = Object[T],
        V = "function" == typeof k,
        B = e.QObject,
        z = !B || !B[T] || !B[T].findChild,
        q = i && f(function () {
      return 7 != _(A({}, "a", {
        get: function () {
          return A(this, "a", {
            value: 7
          }).a;
        }
      })).a;
    }) ? function (t, n, r) {
      var e = P(W, n);
      e && delete W[n], A(t, n, r), e && t !== W && A(W, n, e);
    } : A,
        Y = function (t) {
      var n = D[t] = _(k[T]);

      return n._k = t, n;
    },
        K = V && "symbol" == typeof k.iterator ? function (t) {
      return "symbol" == typeof t;
    } : function (t) {
      return t instanceof k;
    },
        $ = function defineProperty(t, n, r) {
      return t === W && $(U, n, r), x(t), n = S(n, !0), x(r), u(D, n) ? (r.enumerable ? (u(t, R) && t[R][n] && (t[R][n] = !1), r = _(r, {
        enumerable: w(0, !1)
      })) : (u(t, R) || A(t, R, w(1, {})), t[R][n] = !0), q(t, n, r)) : A(t, n, r);
    },
        J = function defineProperties(t, n) {
      x(t);

      for (var r, e = g(n = b(n)), i = 0, o = e.length; i < o;) $(t, r = e[i++], n[r]);

      return t;
    },
        X = function propertyIsEnumerable(t) {
      var n = C.call(this, t = S(t, !0));
      return !(this === W && u(D, t) && !u(U, t)) && (!(n || !u(this, t) || !u(D, t) || u(this, R) && this[R][t]) || n);
    },
        H = function getOwnPropertyDescriptor(t, n) {
      if (t = b(t), n = S(n, !0), t !== W || !u(D, n) || u(U, n)) {
        var r = P(t, n);
        return !r || !u(D, n) || u(t, R) && t[R][n] || (r.enumerable = !0), r;
      }
    },
        Z = function getOwnPropertyNames(t) {
      for (var n, r = M(b(t)), e = [], i = 0; r.length > i;) u(D, n = r[i++]) || n == R || n == a || e.push(n);

      return e;
    },
        Q = function getOwnPropertySymbols(t) {
      for (var n, r = t === W, e = M(r ? U : b(t)), i = [], o = 0; e.length > o;) !u(D, n = e[o++]) || r && !u(W, n) || i.push(D[n]);

      return i;
    };

    V || (c((k = function Symbol() {
      if (this instanceof k) throw TypeError("Symbol is not a constructor!");

      var n = h(0 < arguments.length ? arguments[0] : void 0),
          r = function (t) {
        this === W && r.call(U, t), u(this, R) && u(this[R], n) && (this[R][n] = !1), q(this, n, w(1, t));
      };

      return i && z && q(W, n, {
        configurable: !0,
        set: r
      }), Y(n);
    })[T], "toString", function toString() {
      return this._k;
    }), F.f = H, I.f = $, t(103).f = E.f = Z, t(108).f = X, t(104).f = Q, i && !t(89) && c(W, "propertyIsEnumerable", X, !0), v.f = function (t) {
      return Y(p(t));
    }), o(o.G + o.W + o.F * !V, {
      Symbol: k
    });

    for (var tt = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), nt = 0; tt.length > nt;) p(tt[nt++]);

    for (var rt = O(p.store), et = 0; rt.length > et;) y(rt[et++]);

    o(o.S + o.F * !V, "Symbol", {
      for: function (t) {
        return u(G, t += "") ? G[t] : G[t] = k(t);
      },
      keyFor: function keyFor(t) {
        if (!K(t)) throw TypeError(t + " is not a symbol!");

        for (var n in G) if (G[n] === t) return n;
      },
      useSetter: function () {
        z = !0;
      },
      useSimple: function () {
        z = !1;
      }
    }), o(o.S + o.F * !V, "Object", {
      create: function create(t, n) {
        return void 0 === n ? _(t) : J(_(t), n);
      },
      defineProperty: $,
      defineProperties: J,
      getOwnPropertyDescriptor: H,
      getOwnPropertyNames: Z,
      getOwnPropertySymbols: Q
    }), N && o(o.S + o.F * (!V || f(function () {
      var t = k();
      return "[null]" != j([t]) || "{}" != j({
        a: t
      }) || "{}" != j(Object(t));
    })), "JSON", {
      stringify: function stringify(t) {
        for (var n, r, e = [t], i = 1; arguments.length > i;) e.push(arguments[i++]);

        if (r = n = e[1], (m(n) || void 0 !== t) && !K(t)) return d(n) || (n = function (t, n) {
          if ("function" == typeof r && (n = r.call(this, t, n)), !K(n)) return n;
        }), e[1] = n, j.apply(N, e);
      }
    }), k[T][L] || t(72)(k[T], L, k[T].valueOf), l(k, "Symbol"), l(Math, "Math", !0), l(e.JSON, "JSON", !0);
  }, {
    101: 101,
    102: 102,
    103: 103,
    104: 104,
    107: 107,
    108: 108,
    116: 116,
    118: 118,
    124: 124,
    126: 126,
    140: 140,
    143: 143,
    147: 147,
    150: 150,
    151: 151,
    152: 152,
    38: 38,
    58: 58,
    61: 61,
    62: 62,
    64: 64,
    70: 70,
    71: 71,
    72: 72,
    79: 79,
    81: 81,
    89: 89,
    94: 94,
    98: 98,
    99: 99
  }],
  279: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(146),
        o = t(145),
        f = t(38),
        s = t(137),
        l = t(141),
        u = t(81),
        c = t(70).ArrayBuffer,
        h = t(127),
        p = o.ArrayBuffer,
        v = o.DataView,
        a = i.ABV && c.isView,
        y = p.prototype.slice,
        g = i.VIEW,
        d = "ArrayBuffer";
    e(e.G + e.W + e.F * (c !== p), {
      ArrayBuffer: p
    }), e(e.S + e.F * !i.CONSTR, d, {
      isView: function isView(t) {
        return a && a(t) || u(t) && g in t;
      }
    }), e(e.P + e.U + e.F * t(64)(function () {
      return !new p(2).slice(1, void 0).byteLength;
    }), d, {
      slice: function slice(t, n) {
        if (void 0 !== y && void 0 === n) return y.call(f(this), t);

        for (var r = f(this).byteLength, e = s(t, r), i = s(void 0 === n ? r : n, r), o = new (h(this, p))(l(i - e)), u = new v(this), c = new v(o), a = 0; e < i;) c.setUint8(a++, u.getUint8(e++));

        return o;
      }
    }), t(123)(d);
  }, {
    123: 123,
    127: 127,
    137: 137,
    141: 141,
    145: 145,
    146: 146,
    38: 38,
    62: 62,
    64: 64,
    70: 70,
    81: 81
  }],
  280: [function (t, n, r) {
    var e = t(62);
    e(e.G + e.W + e.F * !t(146).ABV, {
      DataView: t(145).DataView
    });
  }, {
    145: 145,
    146: 146,
    62: 62
  }],
  281: [function (t, n, r) {
    t(144)("Float32", 4, function (e) {
      return function Float32Array(t, n, r) {
        return e(this, t, n, r);
      };
    });
  }, {
    144: 144
  }],
  282: [function (t, n, r) {
    t(144)("Float64", 8, function (e) {
      return function Float64Array(t, n, r) {
        return e(this, t, n, r);
      };
    });
  }, {
    144: 144
  }],
  283: [function (t, n, r) {
    t(144)("Int16", 2, function (e) {
      return function Int16Array(t, n, r) {
        return e(this, t, n, r);
      };
    });
  }, {
    144: 144
  }],
  284: [function (t, n, r) {
    t(144)("Int32", 4, function (e) {
      return function Int32Array(t, n, r) {
        return e(this, t, n, r);
      };
    });
  }, {
    144: 144
  }],
  285: [function (t, n, r) {
    t(144)("Int8", 1, function (e) {
      return function Int8Array(t, n, r) {
        return e(this, t, n, r);
      };
    });
  }, {
    144: 144
  }],
  286: [function (t, n, r) {
    t(144)("Uint16", 2, function (e) {
      return function Uint16Array(t, n, r) {
        return e(this, t, n, r);
      };
    });
  }, {
    144: 144
  }],
  287: [function (t, n, r) {
    t(144)("Uint32", 4, function (e) {
      return function Uint32Array(t, n, r) {
        return e(this, t, n, r);
      };
    });
  }, {
    144: 144
  }],
  288: [function (t, n, r) {
    t(144)("Uint8", 1, function (e) {
      return function Uint8Array(t, n, r) {
        return e(this, t, n, r);
      };
    });
  }, {
    144: 144
  }],
  289: [function (t, n, r) {
    t(144)("Uint8", 1, function (e) {
      return function Uint8ClampedArray(t, n, r) {
        return e(this, t, n, r);
      };
    }, !0);
  }, {
    144: 144
  }],
  290: [function (t, n, r) {
    "use strict";

    var o,
        e = t(70),
        i = t(42)(0),
        u = t(118),
        c = t(94),
        a = t(97),
        f = t(50),
        s = t(81),
        l = t(149),
        h = t(149),
        p = !e.ActiveXObject && "ActiveXObject" in e,
        v = "WeakMap",
        y = c.getWeak,
        g = Object.isExtensible,
        d = f.ufstore,
        x = function (t) {
      return function WeakMap() {
        return t(this, 0 < arguments.length ? arguments[0] : void 0);
      };
    },
        m = {
      get: function get(t) {
        if (s(t)) {
          var n = y(t);
          return !0 === n ? d(l(this, v)).get(t) : n ? n[this._i] : void 0;
        }
      },
      set: function set(t, n) {
        return f.def(l(this, v), t, n);
      }
    },
        b = n.exports = t(51)(v, x, m, f, !0, !0);

    h && p && (a((o = f.getConstructor(x, v)).prototype, m), c.NEED = !0, i(["delete", "has", "get", "set"], function (e) {
      var t = b.prototype,
          i = t[e];
      u(t, e, function (t, n) {
        if (!s(t) || g(t)) return i.call(this, t, n);
        this._f || (this._f = new o());

        var r = this._f[e](t, n);

        return "set" == e ? this : r;
      });
    }));
  }, {
    118: 118,
    149: 149,
    42: 42,
    50: 50,
    51: 51,
    70: 70,
    81: 81,
    94: 94,
    97: 97
  }],
  291: [function (t, n, r) {
    "use strict";

    var e = t(50),
        i = t(149),
        o = "WeakSet";
    t(51)(o, function (t) {
      return function WeakSet() {
        return t(this, 0 < arguments.length ? arguments[0] : void 0);
      };
    }, {
      add: function add(t) {
        return e.def(i(this, o), t, !0);
      }
    }, e, !1, !0);
  }, {
    149: 149,
    50: 50,
    51: 51
  }],
  292: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(67),
        o = t(142),
        u = t(141),
        c = t(33),
        a = t(45);
    e(e.P, "Array", {
      flatMap: function flatMap(t) {
        var n,
            r,
            e = o(this);
        return c(t), n = u(e.length), r = a(e, 0), i(r, e, e, n, 0, 1, t, arguments[1]), r;
      }
    }), t(35)("flatMap");
  }, {
    141: 141,
    142: 142,
    33: 33,
    35: 35,
    45: 45,
    62: 62,
    67: 67
  }],
  293: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(41)(!0);
    e(e.P, "Array", {
      includes: function includes(t) {
        return i(this, t, 1 < arguments.length ? arguments[1] : void 0);
      }
    }), t(35)("includes");
  }, {
    35: 35,
    41: 41,
    62: 62
  }],
  294: [function (t, n, r) {
    var e = t(62),
        i = t(110)(!0);
    e(e.S, "Object", {
      entries: function entries(t) {
        return i(t);
      }
    });
  }, {
    110: 110,
    62: 62
  }],
  295: [function (t, n, r) {
    var e = t(62),
        a = t(111),
        f = t(140),
        s = t(101),
        l = t(53);
    e(e.S, "Object", {
      getOwnPropertyDescriptors: function getOwnPropertyDescriptors(t) {
        for (var n, r, e = f(t), i = s.f, o = a(e), u = {}, c = 0; o.length > c;) void 0 !== (r = i(e, n = o[c++])) && l(u, n, r);

        return u;
      }
    });
  }, {
    101: 101,
    111: 111,
    140: 140,
    53: 53,
    62: 62
  }],
  296: [function (t, n, r) {
    var e = t(62),
        i = t(110)(!1);
    e(e.S, "Object", {
      values: function values(t) {
        return i(t);
      }
    });
  }, {
    110: 110,
    62: 62
  }],
  297: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(52),
        o = t(70),
        u = t(127),
        c = t(115);
    e(e.P + e.R, "Promise", {
      finally: function (n) {
        var r = u(this, i.Promise || o.Promise),
            t = "function" == typeof n;
        return this.then(t ? function (t) {
          return c(r, n()).then(function () {
            return t;
          });
        } : n, t ? function (t) {
          return c(r, n()).then(function () {
            throw t;
          });
        } : n);
      }
    });
  }, {
    115: 115,
    127: 127,
    52: 52,
    62: 62,
    70: 70
  }],
  298: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(132),
        o = t(148),
        u = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o);
    e(e.P + e.F * u, "String", {
      padEnd: function padEnd(t) {
        return i(this, t, 1 < arguments.length ? arguments[1] : void 0, !1);
      }
    });
  }, {
    132: 132,
    148: 148,
    62: 62
  }],
  299: [function (t, n, r) {
    "use strict";

    var e = t(62),
        i = t(132),
        o = t(148),
        u = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o);
    e(e.P + e.F * u, "String", {
      padStart: function padStart(t) {
        return i(this, t, 1 < arguments.length ? arguments[1] : void 0, !0);
      }
    });
  }, {
    132: 132,
    148: 148,
    62: 62
  }],
  300: [function (t, n, r) {
    "use strict";

    t(134)("trimLeft", function (t) {
      return function trimLeft() {
        return t(this, 1);
      };
    }, "trimStart");
  }, {
    134: 134
  }],
  301: [function (t, n, r) {
    "use strict";

    t(134)("trimRight", function (t) {
      return function trimRight() {
        return t(this, 2);
      };
    }, "trimEnd");
  }, {
    134: 134
  }],
  302: [function (t, n, r) {
    t(150)("asyncIterator");
  }, {
    150: 150
  }],
  303: [function (t, n, r) {
    for (var e = t(164), i = t(107), o = t(118), u = t(70), c = t(72), a = t(88), f = t(152), s = f("iterator"), l = f("toStringTag"), h = a.Array, p = {
      CSSRuleList: !0,
      CSSStyleDeclaration: !1,
      CSSValueList: !1,
      ClientRectList: !1,
      DOMRectList: !1,
      DOMStringList: !1,
      DOMTokenList: !0,
      DataTransferItemList: !1,
      FileList: !1,
      HTMLAllCollection: !1,
      HTMLCollection: !1,
      HTMLFormElement: !1,
      HTMLSelectElement: !1,
      MediaList: !0,
      MimeTypeArray: !1,
      NamedNodeMap: !1,
      NodeList: !0,
      PaintRequestList: !1,
      Plugin: !1,
      PluginArray: !1,
      SVGLengthList: !1,
      SVGNumberList: !1,
      SVGPathSegList: !1,
      SVGPointList: !1,
      SVGStringList: !1,
      SVGTransformList: !1,
      SourceBufferList: !1,
      StyleSheetList: !0,
      TextTrackCueList: !1,
      TextTrackList: !1,
      TouchList: !1
    }, v = i(p), y = 0; y < v.length; y++) {
      var g,
          d = v[y],
          x = p[d],
          m = u[d],
          b = m && m.prototype;
      if (b && (b[s] || c(b, s, h), b[l] || c(b, l, d), a[d] = h, x)) for (g in e) b[g] || o(b, g, e[g], !0);
    }
  }, {
    107: 107,
    118: 118,
    152: 152,
    164: 164,
    70: 70,
    72: 72,
    88: 88
  }],
  304: [function (t, n, r) {
    var e = t(62),
        i = t(136);
    e(e.G + e.B, {
      setImmediate: i.set,
      clearImmediate: i.clear
    });
  }, {
    136: 136,
    62: 62
  }],
  305: [function (t, n, r) {
    var e = t(70),
        i = t(62),
        o = t(148),
        u = [].slice,
        c = /MSIE .\./.test(o),
        a = function (i) {
      return function (t, n) {
        var r = 2 < arguments.length,
            e = !!r && u.call(arguments, 2);
        return i(r ? function () {
          ("function" == typeof t ? t : Function(t)).apply(this, e);
        } : t, n);
      };
    };

    i(i.G + i.B + i.F * c, {
      setTimeout: a(e.setTimeout),
      setInterval: a(e.setInterval)
    });
  }, {
    148: 148,
    62: 62,
    70: 70
  }],
  306: [function (t, n, r) {
    t(305), t(304), t(303), n.exports = t(52);
  }, {
    303: 303,
    304: 304,
    305: 305,
    52: 52
  }],
  307: [function (t, n, r) {
    var e = function (o) {
      "use strict";

      var c,
          t = Object.prototype,
          a = t.hasOwnProperty,
          n = "function" == typeof Symbol ? Symbol : {},
          i = n.iterator || "@@iterator",
          r = n.asyncIterator || "@@asyncIterator",
          e = n.toStringTag || "@@toStringTag";

      function wrap(t, n, r, e) {
        var i = n && n.prototype instanceof Generator ? n : Generator,
            o = Object.create(i.prototype),
            u = new Context(e || []);
        return o._invoke = function makeInvokeMethod(o, u, c) {
          var a = f;
          return function invoke(t, n) {
            if (a === l) throw new Error("Generator is already running");

            if (a === h) {
              if ("throw" === t) throw n;
              return doneResult();
            }

            for (c.method = t, c.arg = n;;) {
              var r = c.delegate;

              if (r) {
                var e = maybeInvokeDelegate(r, c);

                if (e) {
                  if (e === p) continue;
                  return e;
                }
              }

              if ("next" === c.method) c.sent = c._sent = c.arg;else if ("throw" === c.method) {
                if (a === f) throw a = h, c.arg;
                c.dispatchException(c.arg);
              } else "return" === c.method && c.abrupt("return", c.arg);
              a = l;
              var i = tryCatch(o, u, c);

              if ("normal" === i.type) {
                if (a = c.done ? h : s, i.arg === p) continue;
                return {
                  value: i.arg,
                  done: c.done
                };
              }

              "throw" === i.type && (a = h, c.method = "throw", c.arg = i.arg);
            }
          };
        }(t, r, u), o;
      }

      function tryCatch(t, n, r) {
        try {
          return {
            type: "normal",
            arg: t.call(n, r)
          };
        } catch (t) {
          return {
            type: "throw",
            arg: t
          };
        }
      }

      o.wrap = wrap;
      var f = "suspendedStart",
          s = "suspendedYield",
          l = "executing",
          h = "completed",
          p = {};

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {}

      var u = {};

      u[i] = function () {
        return this;
      };

      var v = Object.getPrototypeOf,
          y = v && v(v(values([])));
      y && y !== t && a.call(y, i) && (u = y);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(u);

      function defineIteratorMethods(t) {
        ["next", "throw", "return"].forEach(function (n) {
          t[n] = function (t) {
            return this._invoke(n, t);
          };
        });
      }

      function AsyncIterator(c) {
        var t;

        this._invoke = function enqueue(r, e) {
          function callInvokeWithMethodAndArg() {
            return new Promise(function (t, n) {
              !function invoke(t, n, r, e) {
                var i = tryCatch(c[t], c, n);

                if ("throw" !== i.type) {
                  var o = i.arg,
                      u = o.value;
                  return u && "object" == typeof u && a.call(u, "__await") ? Promise.resolve(u.__await).then(function (t) {
                    invoke("next", t, r, e);
                  }, function (t) {
                    invoke("throw", t, r, e);
                  }) : Promise.resolve(u).then(function (t) {
                    o.value = t, r(o);
                  }, function (t) {
                    return invoke("throw", t, r, e);
                  });
                }

                e(i.arg);
              }(r, e, t, n);
            });
          }

          return t = t ? t.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
      }

      function maybeInvokeDelegate(t, n) {
        var r = t.iterator[n.method];

        if (r === c) {
          if (n.delegate = null, "throw" === n.method) {
            if (t.iterator.return && (n.method = "return", n.arg = c, maybeInvokeDelegate(t, n), "throw" === n.method)) return p;
            n.method = "throw", n.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return p;
        }

        var e = tryCatch(r, t.iterator, n.arg);
        if ("throw" === e.type) return n.method = "throw", n.arg = e.arg, n.delegate = null, p;
        var i = e.arg;
        return i ? i.done ? (n[t.resultName] = i.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = c), n.delegate = null, p) : i : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, p);
      }

      function pushTryEntry(t) {
        var n = {
          tryLoc: t[0]
        };
        1 in t && (n.catchLoc = t[1]), 2 in t && (n.finallyLoc = t[2], n.afterLoc = t[3]), this.tryEntries.push(n);
      }

      function resetTryEntry(t) {
        var n = t.completion || {};
        n.type = "normal", delete n.arg, t.completion = n;
      }

      function Context(t) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t.forEach(pushTryEntry, this), this.reset(!0);
      }

      function values(t) {
        if (t) {
          var n = t[i];
          if (n) return n.call(t);
          if ("function" == typeof t.next) return t;

          if (!isNaN(t.length)) {
            var r = -1,
                e = function next() {
              for (; ++r < t.length;) if (a.call(t, r)) return next.value = t[r], next.done = !1, next;

              return next.value = c, next.done = !0, next;
            };

            return e.next = e;
          }
        }

        return {
          next: doneResult
        };
      }

      function doneResult() {
        return {
          value: c,
          done: !0
        };
      }

      return GeneratorFunction.prototype = g.constructor = GeneratorFunctionPrototype, GeneratorFunctionPrototype.constructor = GeneratorFunction, GeneratorFunctionPrototype[e] = GeneratorFunction.displayName = "GeneratorFunction", o.isGeneratorFunction = function (t) {
        var n = "function" == typeof t && t.constructor;
        return !!n && (n === GeneratorFunction || "GeneratorFunction" === (n.displayName || n.name));
      }, o.mark = function (t) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, e in t || (t[e] = "GeneratorFunction")), t.prototype = Object.create(g), t;
      }, o.awrap = function (t) {
        return {
          __await: t
        };
      }, defineIteratorMethods(AsyncIterator.prototype), AsyncIterator.prototype[r] = function () {
        return this;
      }, o.AsyncIterator = AsyncIterator, o.async = function (t, n, r, e) {
        var i = new AsyncIterator(wrap(t, n, r, e));
        return o.isGeneratorFunction(n) ? i : i.next().then(function (t) {
          return t.done ? t.value : i.next();
        });
      }, defineIteratorMethods(g), g[e] = "Generator", g[i] = function () {
        return this;
      }, g.toString = function () {
        return "[object Generator]";
      }, o.keys = function (n) {
        var r = [];

        for (var t in n) r.push(t);

        return r.reverse(), function next() {
          for (; r.length;) {
            var t = r.pop();
            if (t in n) return next.value = t, next.done = !1, next;
          }

          return next.done = !0, next;
        };
      }, o.values = values, Context.prototype = {
        constructor: Context,
        reset: function (t) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = c, this.done = !1, this.delegate = null, this.method = "next", this.arg = c, this.tryEntries.forEach(resetTryEntry), !t) for (var n in this) "t" === n.charAt(0) && a.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = c);
        },
        stop: function () {
          this.done = !0;
          var t = this.tryEntries[0].completion;
          if ("throw" === t.type) throw t.arg;
          return this.rval;
        },
        dispatchException: function (r) {
          if (this.done) throw r;
          var e = this;

          function handle(t, n) {
            return i.type = "throw", i.arg = r, e.next = t, n && (e.method = "next", e.arg = c), !!n;
          }

          for (var t = this.tryEntries.length - 1; 0 <= t; --t) {
            var n = this.tryEntries[t],
                i = n.completion;
            if ("root" === n.tryLoc) return handle("end");

            if (n.tryLoc <= this.prev) {
              var o = a.call(n, "catchLoc"),
                  u = a.call(n, "finallyLoc");

              if (o && u) {
                if (this.prev < n.catchLoc) return handle(n.catchLoc, !0);
                if (this.prev < n.finallyLoc) return handle(n.finallyLoc);
              } else if (o) {
                if (this.prev < n.catchLoc) return handle(n.catchLoc, !0);
              } else {
                if (!u) throw new Error("try statement without catch or finally");
                if (this.prev < n.finallyLoc) return handle(n.finallyLoc);
              }
            }
          }
        },
        abrupt: function (t, n) {
          for (var r = this.tryEntries.length - 1; 0 <= r; --r) {
            var e = this.tryEntries[r];

            if (e.tryLoc <= this.prev && a.call(e, "finallyLoc") && this.prev < e.finallyLoc) {
              var i = e;
              break;
            }
          }

          i && ("break" === t || "continue" === t) && i.tryLoc <= n && n <= i.finallyLoc && (i = null);
          var o = i ? i.completion : {};
          return o.type = t, o.arg = n, i ? (this.method = "next", this.next = i.finallyLoc, p) : this.complete(o);
        },
        complete: function (t, n) {
          if ("throw" === t.type) throw t.arg;
          return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && n && (this.next = n), p;
        },
        finish: function (t) {
          for (var n = this.tryEntries.length - 1; 0 <= n; --n) {
            var r = this.tryEntries[n];
            if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), p;
          }
        },
        catch: function (t) {
          for (var n = this.tryEntries.length - 1; 0 <= n; --n) {
            var r = this.tryEntries[n];

            if (r.tryLoc === t) {
              var e = r.completion;

              if ("throw" === e.type) {
                var i = e.arg;
                resetTryEntry(r);
              }

              return i;
            }
          }

          throw new Error("illegal catch attempt");
        },
        delegateYield: function (t, n, r) {
          return this.delegate = {
            iterator: values(t),
            resultName: n,
            nextLoc: r
          }, "next" === this.method && (this.arg = c), p;
        }
      }, o;
    }("object" == typeof n ? n.exports : {});

    try {
      regeneratorRuntime = e;
    } catch (t) {
      Function("r", "regeneratorRuntime = r")(e);
    }
  }, {}]
}, {}, [1]);
"use strict";

// Контроль за шириной экрана
var screenResolutions = {
  widescreenMax: '1980px',
  widescreenMin: '1441px',
  desktopMin: '1367px',
  laptopMin: '1025px',
  tabletMin: '769px',
  tabletMiniMin: '601px',
  mobileMax: '600px'
};
var isWidescreen = window.matchMedia("(min-width: " + screenResolutions.widescreenMin + ")").matches,
    isDesktop = window.matchMedia("(min-width: " + screenResolutions.desktopMin + ")").matches,
    isLaptop = window.matchMedia("(min-width: " + screenResolutions.laptopMin + ")").matches,
    isTablet = window.matchMedia("(min-width: " + screenResolutions.tabletMin + ")").matches,
    isTabletMini = window.matchMedia("(min-width: " + screenResolutions.tabletMiniMin + ")").matches,
    isMobile = window.matchMedia("(max-width: " + screenResolutions.mobileMax + ")").matches;
"use strict";

/*
    Контроль (отключение/включение) скроллинга на странице
*/
// left: 37, up: 38, right: 39, down: 40,
// spacebar: 32, pageup: 33, pagedown: 34, end: 35, home: 36
var keysToDisable = {
  37: 1,
  38: 1,
  39: 1,
  40: 1
};

function preventDefault(e) {
  e = e || window.event;

  if (e.preventDefault) {
    e.preventDefault();
  }

  e.returnValue = false;
}

function preventDefaultForScrollKeys(e) {
  if (keysToDisable[e.keyCode]) {
    preventDefault(e);
    return false;
  }
}

function disableScroll() {
  // Используется при открытии попапов (компонент popup)
  if (window.addEventListener) {
    window.addEventListener('DOMMouseScroll', preventDefault, false);
  }

  window.addEventListener('wheel', preventDefault, {
    passive: false
  });
  window.addEventListener('mousewheel', preventDefault, {
    passive: false
  }); // window.onmousewheel = document.onmousewheel = preventDefault;

  window.ontouchmove = preventDefault; // mobile

  document.onkeydown = preventDefaultForScrollKeys;
}

function enableScroll() {
  // Используется при закрытии попапов (компонент popup)
  if (window.removeEventListener) {
    window.removeEventListener('DOMMouseScroll', preventDefault, false);
  } // window.onmousewheel = document.onmousewheel = null;
  // window.onwheel = null;


  window.removeEventListener('wheel', preventDefault, {
    passive: false
  });
  window.removeEventListener('mousewheel', preventDefault, {
    passive: false
  });
  document.removeEventListener('mousewheel', preventDefault, {
    passive: false
  });
  window.ontouchmove = null;
  document.onkeydown = null;
}
"use strict";
"use strict";

$(function () {});
"use strict";

$(function () {});
"use strict";
"use strict";

/* Бургер */
document.addEventListener("DOMContentLoaded", function () {
  function burger(selector) {
    var classes = {
      burgerActive: 'burger--active',
      burgerActiveCollapse: 'burger--active-collapse',
      burgerActiveRotate: 'burger--active-rotate'
    };

    function bindFunctions(burgerObj) {
      // Привязка функций
      // Переключение бургера (активное/неактивное состояние)
      burgerObj.burgerToggle = function () {
        switch (burgerObj.state) {
          case 'inactive':
            burgerObj.burgerOpen();
            break;

          case 'active':
            burgerObj.burgerClose();
            break;

          default:
            break;
        }

        ;
      }; // Показ бургера (активное состояние)


      burgerObj.burgerOpen = function () {
        burgerObj.state = 'active';
        burgerObj.element.classList.add(classes.burgerActive);
        burgerObj.element.classList.add(classes.burgerActiveCollapse);
        setTimeout(function () {
          burgerObj.element.classList.add(classes.burgerActiveRotate);
        }, 200);
      }; // Скрытие бургера (неактивное состояние)


      burgerObj.burgerClose = function () {
        burgerObj.state = 'inactive';
        burgerObj.element.classList.remove(classes.burgerActive);
        burgerObj.element.classList.remove(classes.burgerActiveRotate);
        setTimeout(function () {
          burgerObj.element.classList.remove(classes.burgerActiveCollapse);
        }, 200);
      };
    }

    ;

    function bindTriggers(burgerObj) {
      // Триггеры события и т.п.
      var data = burgerObj.element.getAttribute('data-burger'),
          dataSelector = '[data-burger="' + data + '"]',
          burgerSelector = '.js--burger',
          triggerSelector = burgerSelector + '-trigger' + dataSelector,
          triggerElements = document.querySelectorAll(triggerSelector); // Триггер показа бургера

      triggerElements.forEach(function (element) {
        element.addEventListener('click', function () {
          burgerObj.burgerToggle();
        });
      });
    }

    ;

    function init(selector) {
      // Инициализация бургера
      var elements = document.querySelectorAll(selector);
      elements.forEach(function (element) {
        var burgerObj = {};
        burgerObj.state = 'inactive'; // 'active'/'inactive'

        burgerObj.element = element;
        bindFunctions(burgerObj);
        bindTriggers(burgerObj);
        element.burger = burgerObj; // Привязываем тултип к элементу
      });
    }

    ;
    init(selector);
  }

  ;
  burger('.js--burger');
});
/* Инциализация кастомного скролла у блока контента в попапе */

/* let customScroll = document.querySelectorAll('.js--burger-custom-scroll');
customScroll.forEach(function (item) {
    let ps = new PerfectScrollbar(item, {
        wheelSpeed: 0.3,
        swipeEasing: true
    });
    item.customScrollObj = ps;
}); */
"use strict";

$(function () {});
"use strict";

/* Корзина */
function cartInit() {
  // Ф-ция обработки стилизуемых опций
  // См. выбор диаметра пиццы, толщины теста и т.п.
  // Переключаемые классы для элементов выбираемых опций
  var optsItemsClasses = {
    form: {
      ip: 'form__label--opts-active',
      it: 'form__label-text--active'
    },
    delivery: {
      ip: 'delivery__opts-label--active',
      it: 'delivery__opts-text--active'
    },
    map: {
      ip: 'map__opts-label--active',
      it: 'map__opts-text--active'
    },
    'slider-network': {
      ip: 'slider-network__opts-label--active',
      it: 'slider-network__opts-text--active'
    },
    entries: {
      ip: 'entries__opts-label--active',
      it: 'entries__opts-text--active'
    },
    constructor: {
      ip: 'constructor__opts-label--active',
      it: 'constructor__opts-text--active'
    }
  };

  function setActiveOpt(optionsObj) {
    // ф-ция должна при загрузке (и при клике на чекбокс) проверять выделенный
    var overlay = optionsObj.overlay;
    optionsObj.optItems.forEach(function (item) {
      var itemParent = item.parentNode,
          itemText = itemParent.querySelector('.js--opts-text'),
          dataOptsKey = optionsObj.dataOptsKey,
          ipActive = optsItemsClasses[dataOptsKey].ip,
          itActive = optsItemsClasses[dataOptsKey].it;
      itemParent.classList.remove(ipActive);
      itemText.classList.remove(itActive);

      if (item.checked) {
        itemParent.classList.add(ipActive);
        itemText.classList.add(itActive);
        overlay.style.opacity = 1;
        overlay.style.top = itemParent.offsetTop + 'px';
        overlay.style.left = itemParent.offsetLeft + 'px';
        overlay.style.height = itemParent.offsetHeight + 'px';
        overlay.style.width = itemParent.offsetWidth + 'px';
      }
    });
  }

  var opts = document.querySelectorAll('.js--opts');

  if (opts) {
    opts.forEach(function (item) {
      var optItems = item.querySelectorAll('.js--opts-item'),
          overlay = item.querySelector('.js--opts-overlay'),
          dataOptsKey = item.getAttribute('data-opts-key'),
          optionsObj = {
        optItems: optItems,
        overlay: overlay,
        dataOptsKey: dataOptsKey
      };
      setActiveOpt(optionsObj);
      optItems.forEach(function (item) {
        item.addEventListener('click', function (e) {
          setActiveOpt(optionsObj);
        });
      });
    });
  }
  /* Объект корзины */


  function cartComponent(selector) {
    var timeFormOpen = 300;
    var timeScrollOnTop = 500;
    var classes = {
      formWrapperActive: 'cart__form-wrapper--active',
      orderBtnHidden: 'cart__order-btn--hidden',
      linkBackHidden: 'cart__order-btn--hidden'
    };

    function initElements(cartObj, element) {
      // Инициализация элементов компонента
      cartObj.element = element;
      cartObj.formBlock = element.querySelector('.js--cart-form-block');
      cartObj.formWrapper = element.querySelector('.js--cart-form-wrapper');
      cartObj.btnOrder = element.querySelector('.js--cart-btn-order');
      cartObj.linkBack = element.querySelector('.js--cart-link-back');
      cartObj.onTop = element.querySelector('.js--cart-on-top');
    }

    function bindFunctions(cartObj) {
      // Привязка функций
      // Показ тултипа (активное состояние)
      cartObj.openForm = function () {
        var $formBlock = $(cartObj.formBlock);
        $formBlock.slideDown(timeFormOpen);
        cartObj.formWrapper.classList.add(classes.formWrapperActive);
      };
    }

    function bindTriggers(cartObj) {
      // Триггеры события и т.п.
      // Нажатие на кнопку для раскрытия формы
      // cartObj.btnOrder.addEventListener('click', function () {
      // this.closest('.js--cart-order-btn-block').classList.add(classes.orderBtnHidden);
      cartObj.linkBack.classList.add(classes.linkBackHidden);
      cartObj.openForm(); // Обновляем состояние свитчеров

      var opts = cartObj.formBlock.querySelectorAll('.js--opts');

      if (opts) {
        opts.forEach(function (item) {
          var optItems = item.querySelectorAll('.js--opts-item'),
              overlay = item.querySelector('.js--opts-overlay'),
              dataOptsKey = item.getAttribute('data-opts-key'),
              optionsObj = {
            optItems: optItems,
            overlay: overlay,
            dataOptsKey: dataOptsKey
          };
          setActiveOpt(optionsObj);
        });
      } // }); // Нажатие на ссылку "Наверх в корзину"


      cartObj.onTop.addEventListener('click', function (e) {
        e.preventDefault();
        $('html, body').animate({
          scrollTop: 0
        }, timeScrollOnTop);
      });
    }

    function init(selector) {
      // Инициализация попапа
      var elements = document.querySelectorAll(selector);
      elements.forEach(function (element) {
        var cartObj = {};
        initElements(cartObj, element);
        bindFunctions(cartObj);
        bindTriggers(cartObj);
        element.cartObj = cartObj; // Привязываем тултип к элементу
      });
    }

    init(selector);
  }

  cartComponent('.js--cart');
}

document.addEventListener('DOMContentLoaded', function () {// Ф-ция обработки стилизуемых опций
  // См. выбор диаметра пиццы, толщины теста и т.п.
  // Переключаемые классы для элементов выбираемых опций
  // var optsItemsClasses = {
  //   form: {
  //     ip: 'form__label--opts-active',
  //     it: 'form__label-text--active'
  //   },
  //   delivery: {
  //     ip: 'delivery__opts-label--active',
  //     it: 'delivery__opts-text--active'
  //   },
  //   map: {
  //     ip: 'map__opts-label--active',
  //     it: 'map__opts-text--active'
  //   },
  //   'slider-network': {
  //     ip: 'slider-network__opts-label--active',
  //     it: 'slider-network__opts-text--active'
  //   },
  //   entries: {
  //     ip: 'entries__opts-label--active',
  //     it: 'entries__opts-text--active'
  //   },
  //   constructor: {
  //     ip: 'constructor__opts-label--active',
  //     it: 'constructor__opts-text--active'
  //   }
  // };
  //
  // function setActiveOpt(optionsObj) {
  //   // ф-ция должна при загрузке (и при клике на чекбокс) проверять выделенный
  //   var overlay = optionsObj.overlay;
  //   optionsObj.optItems.forEach(function (item) {
  //     var itemParent = item.parentNode,
  //         itemText = itemParent.querySelector('.js--opts-text'),
  //         dataOptsKey = optionsObj.dataOptsKey,
  //         ipActive = optsItemsClasses[dataOptsKey].ip,
  //         itActive = optsItemsClasses[dataOptsKey].it;
  //     itemParent.classList.remove(ipActive);
  //     itemText.classList.remove(itActive);
  //
  //     if (item.checked) {
  //       itemParent.classList.add(ipActive);
  //       itemText.classList.add(itActive);
  //       overlay.style.opacity = 1;
  //       overlay.style.top = itemParent.offsetTop + "px";
  //       overlay.style.left = itemParent.offsetLeft + "px";
  //       overlay.style.height = itemParent.offsetHeight + "px";
  //       overlay.style.width = itemParent.offsetWidth + "px";
  //     }
  //
  //     ;
  //   });
  // }
  //
  // var opts = document.querySelectorAll('.js--opts');
  //
  // if (opts) {
  //   opts.forEach(function (item) {
  //     var optItems = item.querySelectorAll('.js--opts-item'),
  //         overlay = item.querySelector('.js--opts-overlay'),
  //         dataOptsKey = item.getAttribute('data-opts-key'),
  //         optionsObj = {
  //       optItems: optItems,
  //       overlay: overlay,
  //       dataOptsKey: dataOptsKey
  //     };
  //     setActiveOpt(optionsObj);
  //     optItems.forEach(function (item) {
  //       item.addEventListener('click', function (e) {
  //         setActiveOpt(optionsObj);
  //       });
  //     });
  //   });
  // }
  //
  // ;
  // /* Объект корзины */
  //
  // function cartComponent(selector) {
  //   var timeFormOpen = 300;
  //   var timeScrollOnTop = 500;
  //   var classes = {
  //     formWrapperActive: 'cart__form-wrapper--active',
  //     orderBtnHidden: 'cart__order-btn--hidden',
  //     linkBackHidden: 'cart__order-btn--hidden'
  //   };
  //
  //   function initElements(cartObj, element) {
  //     // Инициализация элементов компонента
  //     cartObj.element = element;
  //     cartObj.formBlock = element.querySelector('.js--cart-form-block');
  //     cartObj.formWrapper = element.querySelector('.js--cart-form-wrapper');
  //     cartObj.btnOrder = element.querySelector('.js--cart-btn-order');
  //     cartObj.linkBack = element.querySelector('.js--cart-link-back');
  //     cartObj.onTop = element.querySelector('.js--cart-on-top');
  //   }
  //
  //   ;
  //
  //   function bindFunctions(cartObj) {
  //     // Привязка функций
  //     // Показ тултипа (активное состояние)
  //     cartObj.openForm = function () {
  //       var $formBlock = $(cartObj.formBlock);
  //       $formBlock.slideDown(timeFormOpen);
  //       cartObj.formWrapper.classList.add(classes.formWrapperActive);
  //     };
  //   }
  //
  //   ;
  //
  //   function bindTriggers(cartObj) {
  //     // Триггеры события и т.п.
  //     // Нажатие на кнопку для раскрытия формы
  //     cartObj.btnOrder.addEventListener('click', function () {
  //       this.closest('.js--cart-order-btn-block').classList.add(classes.orderBtnHidden);
  //       cartObj.linkBack.classList.add(classes.linkBackHidden);
  //       cartObj.openForm(); // Обновляем состояние свитчеров
  //
  //       var opts = cartObj.formBlock.querySelectorAll('.js--opts');
  //
  //       if (opts) {
  //         opts.forEach(function (item) {
  //           var optItems = item.querySelectorAll('.js--opts-item'),
  //               overlay = item.querySelector('.js--opts-overlay'),
  //               dataOptsKey = item.getAttribute('data-opts-key'),
  //               optionsObj = {
  //             optItems: optItems,
  //             overlay: overlay,
  //             dataOptsKey: dataOptsKey
  //           };
  //           setActiveOpt(optionsObj);
  //         });
  //       }
  //
  //       ;
  //     }); // Нажатие на ссылку "Наверх в корзину"
  //
  //     cartObj.onTop.addEventListener('click', function (e) {
  //       e.preventDefault();
  //       $("html, body").animate({
  //         scrollTop: 0
  //       }, timeScrollOnTop);
  //     });
  //   }
  //
  //   ;
  //
  //   function init(selector) {
  //     // Инициализация попапа
  //     var elements = document.querySelectorAll(selector);
  //     elements.forEach(function (element) {
  //       var cartObj = {};
  //       initElements(cartObj, element);
  //       bindFunctions(cartObj);
  //       bindTriggers(cartObj);
  //       element.cartObj = cartObj; // Привязываем тултип к элементу
  //     });
  //   }
  //
  //   ;
  //   init(selector);
  // }
  //
  // ;
  // cartComponent('.js--cart');
});

(function () {
  var cartMessagePrice = document.querySelector('.js--cart__message');

  if (!cartMessagePrice) {
    return;
  }

  cartMessagePrice.addEventListener('click', function () {
    if (isMobile) {
      $(cartMessagePrice).fadeOut(500);
    } else {
      cartMessagePrice.classList.add('cart__message--hidden');
    }
  });
})();
"use strict";

$(function () {});
"use strict";

$(function () {});
"use strict";
"use strict";

$(function () {});
"use strict";

var counters = document.querySelectorAll('.js--counter');

if (counters) {
  counters.forEach(function (counter) {
    var countEl = counter.querySelector('.js--counter__count'),
        input = counter.querySelector('.js--counter__input'),
        controlMinus = counter.querySelector('.js--counter__control--minus'),
        controlPlus = counter.querySelector('.js--counter__control--plus');

    function setInputVal(val) {
      input.value = val;
      input.setAttribute('value', val);
    }

    function updateCount(val) {
      countEl.innerHTML = val;
    }

    function countPlus() {
      var inputVal = parseInt(input.value);
      inputVal += 1;
      setInputVal(inputVal);
      updateCount(inputVal);
    }

    ;

    function countMinus() {
      var inputVal = parseInt(input.value);

      if (inputVal > 0) {
        inputVal -= 1;
        setInputVal(inputVal);
        updateCount(inputVal);
      }
    }

    ;

    if (controlMinus && controlPlus) {
      controlMinus.addEventListener('click', function () {
        countMinus();
      });
      controlPlus.addEventListener('click', function () {
        countPlus();
      });
    }
  });
}
"use strict";

// checkInputFilled - ф-ция из form.js (проверка поля на заполнение)
var deliverySearchInputs = document.querySelectorAll('.js--delivery-search-input'),
    inputDSСlassFilled = 'delivery__search-input--filled';
deliverySearchInputs.forEach(function (input) {
  input.addEventListener('keyup', function (e) {
    checkInputFilled(this, inputDSСlassFilled);
  });
});
var deliveryDistricts = document.querySelectorAll('.js--delivery__area-districts');

if (deliveryDistricts) {
  deliveryDistricts.forEach(function (districts) {
    var expandDistricts = districts.querySelector('.js--delivery__expand-districts'),
        areaDistricts = districts.querySelectorAll('.js--delivery__area-district');

    if (expandDistricts && areaDistricts) {
      expandDistricts.addEventListener('click', function () {
        var classExpandDistrictsHidden = 'delivery__expand-districts--hidden',
            classAreaDistrictsVisible = 'delivery__area-district--visible';
        this.classList.add(classExpandDistrictsHidden);
        areaDistricts.forEach(function (district) {
          district.classList.add(classAreaDistrictsVisible);
        });
      });
    }
  });
}
"use strict";

document.addEventListener("DOMContentLoaded", function () {
  // Слайдер с записями (см. home.html)
  var entriesGroupCells;

  if (isWidescreen) {
    entriesGroupCells = {
      'default': 4,
      'item-tiles': 4
    };
  } else if (isDesktop) {
    entriesGroupCells = {
      'default': 4,
      'item-tiles': 4
    };
  } else if (isLaptop) {
    entriesGroupCells = {
      'default': 3,
      'item-tiles': 3
    };
  } else if (isTablet) {
    entriesGroupCells = {
      'default': 3,
      'item-tiles': 3
    };
  } else if (isTabletMini) {
    entriesGroupCells = {
      'default': 2,
      'item-tiles': 2
    };
  } else if (isMobile) {
    entriesGroupCells = {
      'default': 1,
      'item-tiles': 2
    };
  }

  var $entriesItemsSlider = $('.js--entries__items--slider');

  if ($entriesItemsSlider.length > 0) {
    var showEntriesItemsSlider = function showEntriesItemsSlider($slider) {
      $slider.removeClass('entries__items--hidden'); // Вычислим максимальную высоту слайдов - по ней мы выстроим высоту слайдера после его инита (см. ниже)

      var $slides = $('.entries__item--slide', $slider);
      var itemsHeights = [];
      $slides.each(function () {
        itemsHeights.push(this.offsetHeight);
      });
      var maxHeight = Math.max.apply(Math, itemsHeights);
      $slider.css({
        'height': maxHeight + 'px'
      });
      $slider.find('.flickity-viewport').css({
        'height': maxHeight + 'px'
      });
      $slider.flickity('resize');
    };

    // Получим тип слайдера
    var sliderType = $entriesItemsSlider.data('slider-type');
    var entriesCurGroupCells;
    sliderType ? entriesCurGroupCells = entriesGroupCells[sliderType] : entriesCurGroupCells = entriesGroupCells['default'];
    var entriesItemsSliderOptions = {
      cellAlign: 'left',
      groupCells: entriesCurGroupCells,
      draggable: false,
      // wrapAround: true, // Отключается из-за бага с position: sticky на samsung internet browser v.6.n
      pageDots: false,
      arrowShape: {
        x0: 10,
        x1: 60,
        y1: 50,
        x2: 65,
        y2: 45,
        x3: 20 // 

      }
    };
    $entriesItemsSlider.flickity(entriesItemsSliderOptions);
    $entriesItemsSlider.on('ready.flickity', showEntriesItemsSlider($entriesItemsSlider));
  }
});
"use strict";

$(function () {});
"use strict";

$(function () {});
"use strict";

document.addEventListener("DOMContentLoaded", function () {
  var jsFilter = document.querySelectorAll('.js--filter');

  if (jsFilter) {
    var classFilterActive = 'filter--active';
    jsFilter.forEach(function (filter) {
      filter.classList.add(classFilterActive);
    });

    if (!isMobile) {
      // let filtersScrolled = document.querySelectorAll('.filter__wrapper.js--custom-scroll-x');
      var filtersScrolled = document.querySelectorAll('.js--filter-wrapper');
      filtersScrolled.forEach(function (filter) {
        var customScrollObj = new PerfectScrollbar(filter, {
          wheelSpeed: 0.3,
          swipeEasing: true
        });
      });
    } else {
      var pizzaFilter = function pizzaFilter(selector) {
        var classes = {
          filterWrapperActive: 'filter__wrapper--active'
        };

        function bindFunctions(pizzaFilterObj) {
          // Привязка функций
          // Переключение бургера (активное/неактивное состояние)
          pizzaFilterObj.filterToggle = function () {
            switch (pizzaFilterObj.state) {
              case 'inactive':
                pizzaFilterObj.filterOpen();
                break;

              case 'active':
                pizzaFilterObj.filterClose();
                break;

              default:
                break;
            }

            ;
          }; // Показ бургера (активное состояние)


          pizzaFilterObj.filterOpen = function () {
            pizzaFilterObj.state = 'active';
            pizzaFilterObj.wrapper.classList.add(classes.filterWrapperActive);
          }; // Скрытие бургера (неактивное состояние)


          pizzaFilterObj.filterClose = function () {
            pizzaFilterObj.state = 'inactive';
            pizzaFilterObj.wrapper.classList.remove(classes.filterWrapperActive);
          };
        }

        ;

        function bindTriggers(pizzaFilterObj) {
          // Триггеры события и т.п.
          var data = pizzaFilterObj.element.getAttribute('data-filter'),
              dataSelector = '[data-filter="' + data + '"]',
              burgerSelector = '.js--filter',
              triggerSelector = burgerSelector + '-toggle' + dataSelector,
              triggerElements = document.querySelectorAll(triggerSelector); // Триггер показа бургера

          triggerElements.forEach(function (element) {
            element.addEventListener('click', function () {
              pizzaFilterObj.filterToggle();
            });
          });
        }

        ;

        function init(selector) {
          // Инициализация бургера
          var elements = document.querySelectorAll(selector);
          elements.forEach(function (element) {
            var pizzaFilterObj = {};
            pizzaFilterObj.state = 'inactive'; // 'active'/'inactive'

            pizzaFilterObj.element = element;
            pizzaFilterObj.wrapper = element.querySelector('.js--filter-wrapper');
            bindFunctions(pizzaFilterObj);
            bindTriggers(pizzaFilterObj);
            element.pizzaFilterObj = pizzaFilterObj; // Привязываем тултип к элементу
          });
        }

        ;
        init(selector);
      };

      ;
      pizzaFilter('.js--filter');
    }
  }
});
"use strict";
"use strict";

// Реализовываем перпеключаемые поля ("табы")
document.addEventListener("DOMContentLoaded", function () {
  var formComponent = document.querySelectorAll('.js--form');
  formComponent.forEach(function (form) {
    var formTabs = form.querySelectorAll('.js--form-tab'),
        formTabCells = form.querySelectorAll('.js--form-tab-cell'),
        formTabWrappers = form.querySelectorAll('.js--form-tab-wrapper'),
        formAddrBtn = form.querySelectorAll('.js--addr-btn'),
        formAddrBlocks = form.querySelectorAll('.js--addr-block'),
        formTabsClasses = {
      cellActive: 'form__cell--tab-active',
      cellGroupHidden: 'form__cell-group--hidden',
      wrapperActive: 'form__wrapper--tab-active',
      tabActive: 'form__tab-title--active'
    };

    if (formTabs && formTabCells || formTabs && formTabWrappers) {
      formTabs.forEach(function (tab) {
        var dataBind = tab.getAttribute('data-bind'),
            dataTabsGroup = tab.getAttribute('data-tabs-group'),
            dataTarget = tab.getAttribute('data-target'),
            tabContentBlocks,
            classContentBlockActive;

        if (dataTarget) {
          switch (dataTarget) {
            case 'wrapper':
              tabContentBlocks = formTabWrappers;
              classContentBlockActive = formTabsClasses.wrapperActive;
              break;

            default:
              break;
          }
        } else {
          tabContentBlocks = formTabCells;
          classContentBlockActive = formTabsClasses.cellActive;
        }

        ;
        var tabContentBlocksGroup = Array.from(tabContentBlocks).filter(function (block) {
          return block.getAttribute('data-tabs-group') == dataTabsGroup;
        });
        tab.addEventListener('click', function () {
          Array.from(formTabs).forEach(function (tab) {
            tab.classList.remove(formTabsClasses.tabActive);
          });
          tab.classList.add(formTabsClasses.tabActive);
          Array.from(tabContentBlocksGroup).forEach(function (block) {
            block.classList.remove(classContentBlockActive);
          });
          var activeBlock = Array.from(tabContentBlocksGroup).filter(function (block) {
            return block.getAttribute('data-bind') == dataBind;
          })[0];

          if (activeBlock) {
            activeBlock.classList.add(classContentBlockActive);
            var inputToFocus = activeBlock.querySelector('.js--tab-input-to-focus');

            if (inputToFocus) {
              inputToFocus.focus();
            }
          }

          ;
        });
      });
    }

    if (formAddrBtn && formAddrBlocks) {
      formAddrBtn.forEach(function (btn) {
        btn.addEventListener('click', function () {
          formAddrBlocks.forEach(function (block) {
            block.classList.toggle(formTabsClasses.cellGroupHidden);
          });
        });
      });
    }
  });
  /* Обработка нажатия кнопки "В корзину" и кнопок счётчика */

  var formsTile = document.querySelectorAll('.js--form-item-tile');
  formsTile.forEach(function (form) {
    var counterMinus = form.querySelector('.js--form-counter-minus'),
        counter = form.querySelector('.js--form-tile-counter'),
        counterInput = form.querySelector('.js--form-counter-input'),
        btnToCart = form.querySelector('.js--form-btn-to-cart');

    if (counterMinus) {
      counterMinus.addEventListener('click', function () {
        if (counterInput.value <= 0) {
          counter.style.display = "none";
          btnToCart.style.display = "inline-block";
        }

        ;
      });
    }

    if (btnToCart) {
      btnToCart.addEventListener('click', function (event) {
        event.preventDefault();
        var count = counterInput.parentNode.querySelector('.js--counter__count');
        counterInput.value = 1;
        count.innerHTML = 1;
        btnToCart.style.display = "none";
        counter.style.display = "flex";
      });
    }
  });
});
"use strict";

// Временные ф-ции для анимаций
easingFunctions = {
  // t: current time, b: begInnIng value, c: change In value, d: duration
  easeOutCubic: function easeOutCubic(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t + 1) + b;
  }
};
document.addEventListener("DOMContentLoaded", function () {
  if (document.querySelector(".js--header")) {
    // Перемотка окна
    var windowScrolling = function windowScrolling(scrollTo, duration) {
      $("html, body").animate({
        scrollTop: scrollTo + "px"
      }, duration);
    }; // Подсвестка активных секционных ссылок


    var toggleActiveSectionsLink = function toggleActiveSectionsLink(linkActive, allLinks, activeClass) {
      Array.from(allLinks).forEach(function (link) {
        if (link == linkActive) {
          link.classList.add(activeClass);
        } else {
          link.classList.remove(activeClass);
        }

        ;
      });
    };

    var offsetPosition = function offsetPosition(element) {
      var offsetLeft = 0,
          offsetTop = 0;

      do {
        offsetLeft += element.offsetLeft;
        offsetTop += element.offsetTop;
      } while (element = element.offsetParent);

      return {
        left: offsetLeft,
        top: offsetTop
      };
    }; // Переходим к секциям по нажатию на ссылку в верхнем меню


    var fixingHeader = function fixingHeader() {
      var header = document.querySelector(".js--header"),
          headerLogo = document.querySelector('.js--header__logo'),
          headerLogoHeight = headerLogo.offsetHeight,
          headerTop = document.querySelector('.js--header-top'),
          headerTopPadTop = parseInt(window.getComputedStyle(headerTop).getPropertyValue("height")),
          headerTopHeight = headerTop.offsetHeight,
          classHeaderFixed = "header--fixed",
          headerOffset = headerTopPadTop;
      pageYOffset > headerOffset ? header.classList.add(classHeaderFixed) : header.classList.remove(classHeaderFixed);
    };

    var getWatchedSectionsObjs = function getWatchedSectionsObjs(selector) {
      // 
      var sectionsWatched = document.querySelectorAll(selector);
      sectionsWatched.forEach(function (section) {
        var obj = {};
        obj.el = section;
        obj.anchor = section.getAttribute('data-anchor');
        obj.top = section.offsetTop;
        obj.bottom = section.offsetHeight + obj.top;
        watchedSectionsOffsetsObjs.push(obj);
      });
    };

    // Отслеживаем секции
    var watchSections = function watchSections() {
      var headerHeight = getElementHeight(".js--header"),
          windowHeight = window.innerHeight,
          offset = pageYOffset + windowHeight / 2;
      watchedSectionsOffsetsObjs.forEach(function (obj) {
        if (obj.bottom >= offset && offset >= offsetPosition(obj.el).top) {
          var pathname = window.location.pathname,
              _currentLocation = pathname + '#' + obj.anchor;

          window.history.replaceState('', '', _currentLocation); // Подсвечиваем активную ссылку

          var linkActive = Array.from(watchedSectionsLinks).filter(function (link) {
            return link.getAttribute('href') == '/#' + obj.anchor;
          })[0];
          toggleActiveSectionsLink(linkActive, watchedSectionsLinks, 'menu__link--main-active');
        }
      });
    }; // Получаем высоту элемента


    var getElementHeight = function getElementHeight(selector) {
      var header = document.querySelector(selector);
      return header.offsetHeight;
    }; // фиксируем фильтр


    var fixingFilter = function fixingFilter(filterSelector, headerHeight, classFilterFixed) {
      var pageFilter = document.querySelector(filterSelector);
      classFilterFixed = classFilterFixed || "filter--fixed";

      if (pageFilter) {
        var filterBRect = pageFilter.getBoundingClientRect();

        if (window.matchMedia("(min-width: 769px)").matches) {
          filterBRect.top == headerHeight ? pageFilter.classList.add(classFilterFixed) : pageFilter.classList.remove(classFilterFixed);
        } else {
          filterBRect.top == parseInt(window.getComputedStyle(pageFilter).getPropertyValue("top")) ? pageFilter.classList.add(classFilterFixed) : pageFilter.classList.remove(classFilterFixed);
        }
      }
    }; // Отслеживаем ресайз экрана, высоту хэдера и устанавливаем отступ (padding) .page__main


    var watchHeaderHeight = function watchHeaderHeight() {
      var pageMain = document.querySelector(".page__main"),
          headerHeight = getElementHeight(".js--header"); // Устанавливаем фильтру отступ в соотв. с высотой хэдера

      fixingFilter('.js--page__filter', headerHeight);
    };

    // Находим на странице секцию с параметром, который указывает перемотку к ней
    // и перематываем страницу.
    var searchDefaultSectionToScroll = function searchDefaultSectionToScroll() {
      if (watchedSectionsOffsetsObjs) {
        var sections = document.querySelectorAll('.js--items-section-watched'),
            sectionsToScroll = Array.from(sections).filter(function (section) {
          return section.getAttribute('data-scroll-default');
        });

        if (sectionsToScroll) {
          var sectionToScroll = sectionsToScroll[0];
          watchedSectionsOffsetsObjs.forEach(function (obj) {
            if (obj.el == sectionToScroll) {
              windowScrolling(obj.top - getElementHeight(".js--header"), 300);
            }
          });
        }
      }
    };

    var watchedSectionsOffsetsObjs = [],
        currentLocation,
        currentWatchedSection,
        currentWindowScrollTop = 0;
    ;
    var watchedSectionsLinks = document.querySelectorAll('.js--section-watched-link');
    watchedSectionsLinks.forEach(function (link) {
      link.addEventListener('click', function (event) {
        if (watchedSectionsOffsetsObjs.length > 0) {
          event.preventDefault();
          var href = link.getAttribute('href'),
              sectionToScroll = watchedSectionsOffsetsObjs.filter(function (obj) {
            return obj.el.id == href.replace('/#', '');
          })[0];
          currentWindowScrollTop = sectionToScroll.top; // , currentWindowScrollTop, getElementHeight(".js--header")

          var offsetTop = offsetPosition(sectionToScroll.el).top; // let offsetTop = sectionToScroll.top;

          windowScrolling(offsetTop - getElementHeight(".js--header"), 300); // Подсвечиваем активную ссылку

          toggleActiveSectionsLink(link, watchedSectionsLinks, 'menu__link--main-active');
        }
      });
    });
    fixingHeader();
    window.addEventListener("scroll", function () {
      fixingHeader();
    });
    getWatchedSectionsObjs(".js--items-section-watched");
    watchSections();
    watchHeaderHeight();
    window.addEventListener("resize", function () {
      watchSections();
      watchHeaderHeight();
    });
    window.addEventListener("scroll", function () {
      watchSections();
      watchHeaderHeight();
    });
  }
}); //searchDefaultSectionToScroll();

document.addEventListener("DOMContentLoaded", function () {
  // Всплывающее меню на скрин-устройствах
  function mobileNav(selector) {
    var classes = {
      navActive: 'header__mobile--active',
      navWrapperActive: 'header__mobile-wrapper--active',
      headerMobileNavActive: 'header--mnav-active'
    };

    function bindFunctions(navObj) {
      // Привязка функций
      // Переключение бургера (активное/неактивное состояние)
      navObj.navToggle = function () {
        document.querySelector('.js--header-mobile-nav').classList.toggle(classes.headerMobileNavActive);

        switch (navObj.state) {
          case 'inactive':
            navObj.navOpen();
            break;

          case 'active':
            navObj.navClose();
            break;

          default:
            break;
        }

        ;
      }; // Показ бургера (активное состояние)


      navObj.navOpen = function () {
        navObj.state = 'active';
        navObj.element.classList.add(classes.navActive);
        navObj.element.querySelector('.js--mobile-nav-wrapper').classList.add(classes.navWrapperActive); // Отключаем скролл на странице

        disableScroll();
      }; // Скрытие бургера (неактивное состояние)


      navObj.navClose = function () {
        navObj.state = 'inactive';
        navObj.element.classList.remove(classes.navActive);
        navObj.element.querySelector('.js--mobile-nav-wrapper').classList.remove(classes.navWrapperActive); // Включаем скролл на странице

        enableScroll();
      };
    }

    ;

    function bindTriggers(navObj) {
      // Триггеры события и т.п.
      var data = navObj.element.getAttribute('data-mobile-nav'),
          dataSelector = '[data-mobile-nav="' + data + '"]',
          navSelector = '.js--mobile-nav',
          triggerSelector = navSelector + '-trigger' + dataSelector,
          triggerElements = document.querySelectorAll(triggerSelector); // Триггер показа бургера

      triggerElements.forEach(function (element) {
        element.addEventListener('click', function () {
          navObj.navToggle();
        });
      });
    }

    ;

    function init(selector) {
      // Инициализация бургера
      var elements = document.querySelectorAll(selector);
      elements.forEach(function (element) {
        var navObj = {};
        navObj.state = 'inactive'; // 'active'/'inactive'

        navObj.element = element;
        bindFunctions(navObj);
        bindTriggers(navObj);
        element.navMobileObj = navObj; // Привязываем тултип к элементу
      });
    }

    ;
    init(selector);
  }

  ;
  mobileNav('.js--mobile-nav');
  var mobileNavScrolled = document.querySelector('.js--mobile-nav-scrolled');

  if (mobileNavScrolled) {
    var mobileNavScrolledObj = new PerfectScrollbar(mobileNavScrolled, {
      wheelSpeed: 0.3,
      swipeEasing: true
    });
  }
});
/* if (window.matchMedia("(max-width: 600px)").matches) {
    let headerColScrolledMobile = document.querySelector('.js--header-col-scrolled-mobile');
    let headerColScrolledMobileObj = new PerfectScrollbar(headerColScrolledMobile, {
        wheelSpeed: 0.3,
        swipeEasing: true
    });
} */

document.addEventListener("DOMContentLoaded", function () {
  var header = document.querySelector('.js--header');

  if (header) {
    var headerTop = document.querySelector('.js--header-top');
    header.classList.add('header--ready');
    headerTop.classList.add('header--ready');
  }
});
"use strict";

$(function () {});
"use strict";

$(function () {});
"use strict";

$(function () {});
"use strict";

function styleFormElements() {
  // Функция проверки поля на заполненность (но не на валидное значение!)
  function checkInputFilled(textInput, inputClassFilled) {
    var val = textInput.value,
        itemClasses = textInput.classList;

    if (val) {
      itemClasses.add(inputClassFilled);
    } else {
      itemClasses.remove(inputClassFilled);
    }
  } // classes


  var inputClassFilled = 'input-ds__input--filled',
      inputClassError = 'input-ds__input--error',
      inputClassValid = 'input-ds__input--valid';

  function clearInput(inputWrapper) {
    var input = inputWrapper.querySelector('.js--input-ds__input');
    input.value = '';

    if (input.classList.contains('js--form-input-number')) {
      Inputmask.remove([input]);
    }

    if (input.classList.contains('js--form-input-email')) {
      Inputmask.remove([input]);
    }
  }

  function isTextType(input) {
    var inputTypeAttribute = input ? input.getAttribute('type') : '',
        inputTag = input ? input.tagName : '',
        textTypes = ['text', 'tel', 'email'];
    return textTypes.findIndex(function (textType) {
      return textType === inputTypeAttribute;
    }) !== -1 || inputTag === 'TEXTAREA';
  }

  var inputDs = document.querySelectorAll('.js--input-ds');
  inputDs.forEach(function (inputWrapper) {
    var parentCell = inputWrapper.parentNode,
        input = inputWrapper.querySelector('.js--input-ds__input'),
        inputClearButton = inputWrapper.querySelector('.js--input-ds__input-clear'),
        messageInfo = parentCell.querySelector('.js--form__message-info');

    if (input) {
      checkInputFilled(input, inputClassFilled);
      input.addEventListener('keyup', function () {
        checkInputFilled(input, inputClassFilled);
      }); // if (isTextType(input)) {
      //     clearInput(inputWrapper);
      // }

      input.addEventListener('blur', function () {}); // Очистка поля от введённого значения

      if (inputClearButton) {
        inputClearButton.addEventListener('click', function () {
          input.classList.remove(inputClassFilled, inputClassValid, inputClassError);
          clearInput(inputWrapper);
          var blurEvent = new Event('blur'); // для вуя

          input.dispatchEvent(new Event('input'));
          input.dispatchEvent(new Event('change'));
          input.dispatchEvent(blurEvent);
        });
      }

      if (messageInfo) {
        var miClassActive = 'form__message--active';
        input.addEventListener('focus', function () {
          messageInfo.classList.add(miClassActive);
        });
        input.addEventListener('blur', function () {
          messageInfo.classList.remove(miClassActive);
        });
      }
    }
  }); // Стилизуем select

  $('.js--input-ds__select').each(function () {
    var $select = $(this);
    $select.selectric({
      onChange: function onChange(elm) {
        $(elm).change();
        elm.dispatchEvent(new Event('change')); // для вуя
      },
      arrowButtonMarkup: '\n<div class="button">\n<div class="icon">\n\n</div>\n</div>\n',
      onInit: function onInit(element) {
        var $parent = $select.parents('.selectric-js--input-ds__select'),
            $parentInputWrapper = $select.parents('.js--input-ds--select');
        $parentInputWrapper.removeClass('input-ds--invisible'); // Делаем selectric-select заполненным только если у него не пустое значение

        if ($(element).val()) {
          $parent.addClass('selectric-filled');
        }
      }
    }).on('selectric-open', function () {
      // Добавляем кастомный скролл
      var $parent = $select.parents('.selectric-js--input-ds__select');
      var $items = $parent.find('.selectric-scroll');

      if (!$items[0].customScrollObj) {
        $items[0].customScrollObj = new PerfectScrollbar($items[0], {
          wheelSpeed: 0.3,
          swipeEasing: true
        });
      }
    }).on('selectric-select', function (event, element) {
      var $parent = $select.parents('.selectric-js--input-ds__select'); // Делаем selectric-select заполненным только если у него не пустое значение

      if ($(element).val()) {
        $parent.addClass('selectric-filled');
      }
    }).on('selectric-refresh', function (event, element) {
      var $parent = $select.parents('.selectric-js--input-ds__select'); // Делаем selectric-select заполненным только если у него не пустое значение

      if ($(element).val()) {
        $parent.addClass('selectric-filled');
      }
    });
  }); // Обработка загрузки файлов

  var inputDSFile = document.querySelectorAll('.js--input-ds__input--file');
  inputDSFile.forEach(function (inputFile) {
    var wrapper = inputFile.closest('.js--input-ds__wrapper--file');
    inputFile.addEventListener('change', function () {
      var loadedFiles = inputFile.files;

      if (loadedFiles) {
        var file = loadedFiles[0],
            fileName = file.name;
        var fileBlock = document.createElement('div');
        fileBlock.classList.add('input-ds__file', 'js--input-ds__file');
        fileBlock.innerHTML = '\n<a class=\'input-ds__file-delete js--input-ds__file-delete\'></a><span class="input-ds__file-name">' + fileName + '</span>';
        wrapper.appendChild(fileBlock);
        var inputFileDelete = wrapper.querySelector('.js--input-ds__file-delete');
        inputFileDelete.addEventListener('click', function () {
          fileBlock.remove();
          loadedFiles = {};
        });
      }
    });
  }); // Делаем маску ввода в поле емэйла на странице заказа

  /* function maskEmailInput($emailInput) {
      let blurEvent = new Event('blur');
      $emailInput.inputmask('*{1,20}[.*{1,20}][.*{1,20}][.*{1,20}]@*{1,20}[.*{2,6}][.*{1,2}]', {
          showMaskOnHover: false,
          'clearIncomplete': true,
          'onincomplete': function () {
              // js--input-ds
              let inputWrapper = $(this).closest('.js--input-ds')[0],
                  input = $emailInput[0];
              clearInput(inputWrapper);
              checkInputFilled(input, inputClassFilled);
              input.dispatchEvent(new Event('input'));
              input.dispatchEvent(new Event('change'));
              // input.dispatchEvent(blurEvent);
          },
          'oncomplete': function () {
              let input = $emailInput[0];
              input.dispatchEvent(new Event('input'));
              input.dispatchEvent(new Event('change'));
              input.dispatchEvent(blurEvent);
          },
      });
  }
  // маскируем поле ввода емэйла
  let $emailInput = $('.js--form-input-email');
  if ($emailInput.length) {
      $emailInput.focus(function () {
          if (!$(this)[0].inputmask) {
              maskEmailInput($(this));
          }
      });
      maskEmailInput($emailInput);
  } */
  // Делаем маску ввода в поле номера на странице заказа

  function maskNumberInput(numberInput) {
    // let blurEvent = new Event('blur');
    var im = new Inputmask({
      'mask': '+7 (999) 999-99-99',
      'showMaskOnHover': false,
      'clearIncomplete': true,
      'onincomplete': function onincomplete() {
        // js--input-ds
        var inputWrapper = $(this).closest('.js--input-ds')[0],
            input = numberInput;
        clearInput(inputWrapper);
        checkInputFilled(input, inputClassFilled);
        input.dispatchEvent(new Event('input'));
        input.dispatchEvent(new Event('change')); // input.dispatchEvent(blurEvent);
      },
      'oncomplete': function oncomplete() {
        var input = numberInput;
        input.dispatchEvent(new Event('input'));
        input.dispatchEvent(new Event('change'));
        input.dispatchEvent(new Event('blur'));
      }
    });
    im.mask(numberInput); // $numberInput.inputmask('+7 (999) 999-99-99', {
    //     showMaskOnHover: false,
    //     'clearIncomplete': true,
    //     'onincomplete': function () {
    //         // js--input-ds
    //         let inputWrapper = $(this).closest('.js--input-ds')[0],
    //             input = $numberInput[0];
    //         clearInput(inputWrapper);
    //         checkInputFilled(input, inputClassFilled);
    //         input.dispatchEvent(new Event('input'));
    //         input.dispatchEvent(new Event('change'));
    //         // input.dispatchEvent(blurEvent);
    //     },
    //     'oncomplete': function () {
    //         let input = $numberInput[0];
    //         input.dispatchEvent(new Event('input'));
    //         input.dispatchEvent(new Event('change'));
    //         input.dispatchEvent(blurEvent);
    //     },
    // });
  }

  var $flatInput = $('.js--form-input-flat');

  if ($flatInput.length) {
    // вводим только число (сниппет)
    $flatInput[0].addEventListener('paste', function (e) {
      e.preventDefault();
    });
    $flatInput.keydown(function (e) {
      // Allow: backspace, delete, tab, escape, enter and .
      if ($.inArray(e.keyCode, [46, 8, 9, 27, 13, 110, 189, 190]) !== -1 || // Allow: Ctrl/cmd+A
      e.keyCode === 65 && (e.ctrlKey === true || e.metaKey === true) || // Allow: Ctrl/cmd+C
      e.keyCode === 67 && (e.ctrlKey === true || e.metaKey === true) || // Allow: Ctrl/cmd+X
      e.keyCode === 88 && (e.ctrlKey === true || e.metaKey === true) || // Allow: home, end, left, right
      e.keyCode >= 35 && e.keyCode <= 39) {
        // let it happen, don't do anything
        if (e.keyCode === 189) {
          var reg = /([-]*[0-9]*[-]*)*/;
          var val = $flatInput[0].value;
          $flatInput[0].value = val.replace(reg, '');
        }

        return;
      }

      if ((e.keyCode >= 48 || e.keyCode <= 57) && (e.keyCode > 96 || e.keyCode <= 105)) {
        if ($flatInput[0].value.indexOf('-') !== -1) {
          var _reg = /[\d]*[\D]*/;
          var _val = $flatInput[0].value;
          $flatInput[0].value = _val.replace(_reg, '');
        }
      } // Ensure that it is a number and stop the keypress


      if (e.keyCode !== 32 && (e.shiftKey || e.keyCode < 48 || e.keyCode > 57) && (e.keyCode < 96 || e.keyCode > 105)) {
        e.preventDefault();
      }
    });
  } // обработка ввода значений в поля ввода на странице заказа


  var $numberInput = $('.js--form-input-number'); // Очистка вводимого номера от 8-ки

  function delete8(value) {
    var clearReg = /((\+7)*)((\D)+)/g,
        patch = '',
        clearVal = value.replace(clearReg, patch).replace(/^8/, patch);
    return parseInt(clearVal, 10);
  }

  if ($numberInput.length) {
    // Удаляем первую 8
    $numberInput[0].addEventListener('keyup', function (e) {
      var inputWrapper = $(this).closest('.js--input-ds')[0];

      if (e.target.value !== '') {
        var input = inputWrapper.querySelector('.js--input-ds__input');
        var patch = '';
        var alias = '+7 (999) 999-99-99'; // let unmaskedvalue = input.inputmask.unmaskedvalue();

        var unmaskedvalue = Inputmask.unmask(e.target.value, {
          alias: alias
        });
        unmaskedvalue = unmaskedvalue.replace(/^8/, patch); // console.log(unmaskedvalue);

        if (unmaskedvalue === '') {
          clearInput(inputWrapper);
          maskNumberInput($numberInput[0]);
        } else {
          e.target.value = unmaskedvalue;
        }
      }
    }); // вводим только число (сниппет)

    $numberInput.keydown(function (e) {
      // Allow: backspace, delete, tab, escape, enter and .
      if ($.inArray(e.keyCode, [46, 8, 9, 27, 13, 110, 190]) !== -1 || // Allow: Ctrl/cmd+A
      e.keyCode === 65 && (e.ctrlKey === true || e.metaKey === true) || // Allow: Ctrl/cmd+C
      e.keyCode === 67 && (e.ctrlKey === true || e.metaKey === true) || // Allow: Ctrl/cmd+X
      e.keyCode === 88 && (e.ctrlKey === true || e.metaKey === true) || // Allow: home, end, left, right
      e.keyCode >= 35 && e.keyCode <= 39) {
        // let it happen, don't do anything
        return;
      } // Ensure that it is a number and stop the keypress


      if (e.keyCode !== 32 && (e.shiftKey || e.keyCode < 48 || e.keyCode > 57) && (e.keyCode < 96 || e.keyCode > 105)) {
        e.preventDefault();
      }
    });
    $numberInput.focus(function () {
      if (!$(this)[0].inputmask) {
        maskNumberInput($(this)[0]);
      }
    });
    maskNumberInput($numberInput[0]); // Для доп. работ - обработка случая ввода городского (НЕмобильного) номера телефона

    /* $numberInput[0].addEventListener('keyup', function () {
        let value          = this.value,
            invalidPhones = [
                '+73952',
                '+7999',
            ];
        value = value.replace(/[() _-]/g, '');
        if (invalidPhones.some( phone => value.indexOf(phone) === 0 )) {
        }
    }) */
    // $numberInput.inputmask('+7 (999) 999-99-99', {"placeholder": "+7 (___) ___-__-__"})
    // $.mask.definitions.c = '[0-9 ]';
    // $numberInput.mask('+7 (ccc) ccc-cc-cc', { placeholder: '+7 (___) ___-__-__' });
  }
}

document.addEventListener('DOMContentLoaded', styleFormElements);
"use strict";

$(function () {});
"use strict";

if (isMobile) {
  var $itSpoilerMobile = $('.js--item-tile-spoiler-mobile');

  if ($itSpoilerMobile.length) {
    $itSpoilerMobile.each(function () {
      var $sm = $(this),
          $smTitle = $('.js--item-tile-spoiler-mobile-title', $sm),
          $smPointer = $('.js--item-tile-spoiler-mobile-pointer', $sm),
          $smItems = $('.js--item-tile-spoiler-mobile-items', $sm),
          classTitleActive = 'item-tile__additional-title--spoiler-active',
          classItemsActive = 'item-tile__additional-items--active',
          classPointerActive = 'item-tile__additional-pointer--active',
          time = 200;
      $smTitle.on('click', function () {
        $smItems.toggleClass(classItemsActive);
        $smPointer.toggleClass(classPointerActive);
        $smItems.slideToggle(time);
      });
    });
  }
}

$.fn.isInViewport = function () {
  var elementTop = $(this).offset().top;
  var elementBottom = elementTop + $(this).outerHeight();
  var viewportTop = $(window).scrollTop();
  var viewportBottom = viewportTop + $(window).height();
  return elementBottom > viewportTop && elementTop < viewportBottom;
};

function myLazyLoad() {
  $('.mylazyload:not(.mylazyload--loaded)').each(function () {
    if ($(this).isInViewport()) {
      var src = $(this).attr('lazyload-src');

      if ($(this).attr('lazyload-attr')) {
        $(this).attr($(this).attr('lazyload-attr'), src);
      } else {
        $(this).attr('src', src);
      }

      $(this).addClass('mylazyload--loaded');
    }
  });
}

$(window).on('resize scroll load', function () {
  myLazyLoad();
});
$(function () {
  myLazyLoad();
});
"use strict";

$(function () {});
"use strict";
"use strict";
"use strict";

/* Инциализация кастомного скролла у блока мест для карты пиццерий */
document.addEventListener("DOMContentLoaded", function () {
  var mapPlacesScroll = document.querySelectorAll('.js--map-places-scroll');
  mapPlacesScroll.forEach(function (item) {
    var ps = new PerfectScrollbar(item, {
      wheelSpeed: 0.3,
      swipeEasing: true
    });
    ps.update();
    item.customScrollObj = ps;
  });
});
"use strict";

$(function () {});
"use strict";
"use strict";
"use strict";

$(function () {});
"use strict";

$(function () {});
"use strict";

var orderAddresses = document.querySelectorAll('.js--order-address');
orderAddresses.forEach(function (orderAddress) {
  var classes = {
    itemDefaultActive: 'order-address__item-default--active',
    addressBlockActive: 'order-address__block--active'
  };
  var itemDefault = orderAddress.querySelectorAll('.js--order-address-item-default');
  itemDefault.forEach(function (link) {
    link.addEventListener('click', function () {
      itemDefault.forEach(function (item) {
        item == link ? item.classList.add(classes.itemDefaultActive) : item.classList.remove(classes.itemDefaultActive);
      });
    });
  });
  /* Переключение со списка адресов на добавление нового адреса и обратно */

  var adressBlocks = orderAddress.querySelectorAll('.js--order-address-block'),
      adressBlockSwitch = orderAddress.querySelectorAll('.js--order-address-block-switch');
  adressBlockSwitch.forEach(function (link) {
    var dataSwitch = link.getAttribute('data-address-block');
    link.addEventListener('click', function () {
      adressBlocks.forEach(function (block) {
        var dataBlock = block.getAttribute('data-address-block');
        dataBlock == dataSwitch ? block.classList.add(classes.addressBlockActive) : block.classList.remove(classes.addressBlockActive);
      });
    });
  });
});
"use strict";

$(function () {});
"use strict";

$(function () {});
"use strict";

// Переключение табов-псевдоссылок
var pageWrapperTabs = document.querySelectorAll('.js--page-wrapper-tabs');
pageWrapperTabs.forEach(function (wrapper) {
  var tabs = wrapper.querySelectorAll('.js--page-tab'),
      tabsSelects = wrapper.querySelectorAll('.js--page-tab-select'),
      classes = {
    tabActive: 'page__tabs-link--active',
    tabContentActive: 'page__tabs-content--active'
  };

  function setActiveTab(thisTab, dataGroup, dataBind) {
    contentsGroup = wrapper.querySelectorAll('.js--page-tab-content[data-group="' + dataGroup + '"]');
    contentsGroup.forEach(function (content) {
      var contentDataBind = content.getAttribute('data-bind');

      if (contentDataBind == dataBind) {
        content.classList.add(classes.tabContentActive);
      } else {
        content.classList.remove(classes.tabContentActive);
      }

      ;
    });
    tabs.forEach(function (tab) {
      if (tab == thisTab) {
        tab.classList.add(classes.tabActive);
      } else {
        tab.classList.remove(classes.tabActive);
      }
    });
  }

  tabs.forEach(function (tab) {
    var dataGroup = tab.getAttribute('data-group'),
        dataBind = tab.getAttribute('data-bind');
    tab.addEventListener('click', function () {
      setActiveTab(this, dataGroup, dataBind);
    });
  });
  tabsSelects.forEach(function (tabSelect) {
    var $select = $(tabSelect);
    $select.on('selectric-init', function (element) {
      var selectedOption = element.querySelector('option:checked');

      if (selectedOption) {
        var dataGroup = selectedOption.getAttribute('data-group'),
            dataBind = selectedOption.getAttribute('data-bind'),
            thisTab = Array.from(tabs).filter(function (tab) {
          return tab.getAttribute('data-bind') == dataBind;
        })[0];
        setActiveTab(this, dataGroup, dataBind);
      }
    }).on('selectric-select', function (event, element, selectric) {
      var selectedOption = element.querySelector('option:checked');
      var dataGroup = selectedOption.getAttribute('data-group'),
          dataBind = selectedOption.getAttribute('data-bind'),
          thisTab = Array.from(tabs).filter(function (tab) {
        return tab.getAttribute('data-bind') == dataBind;
      })[0];
      setActiveTab(this, dataGroup, dataBind);
    });
  });
});
"use strict";
"use strict";

/* Попап */
function popup(selector) {
  var classes = {
    popupActive: 'popup--active',
    popupOnTop: 'popup--on-top',
    popupContentActive: 'popup__content--active'
  };

  function bindFunctions(popupObj) {
    // Привязка функций
    // Показ попапа (активное состояние)
    popupObj.popupOpen = function () {
      popupObj.element.classList.add(classes.popupActive, classes.popupOnTop);
      popupObj.element.querySelector('.js--popup-content').classList.add(classes.popupContentActive); // Отключаем скролл на странице

      disableScroll();
    }; // Скрытие попапа (неактивное состояние)


    popupObj.popupClose = function () {
      popupObj.element.classList.remove(classes.popupActive);
      setTimeout(function () {
        popupObj.element.classList.remove(classes.popupOnTop);
      }, 200);
      popupObj.element.querySelector('.js--popup-content').classList.remove(classes.popupContentActive); // Включаем скролл на странице

      enableScroll();
    };
  }

  function bindTriggers(popupObj) {
    // Триггеры события и т.п.
    var data = popupObj.element.getAttribute('data-popup'),
        dataSelector = '[data-popup="' + data + '"]',
        popupSelector = '.js--popup',
        triggerOpenSelector = popupSelector + '-trigger' + dataSelector,
        triggerCloseSelector = popupSelector + '-close',
        triggerOpenElements = document.querySelectorAll(triggerOpenSelector),
        triggerCloseElements = document.querySelectorAll(triggerCloseSelector); // Триггер показа попапа

    triggerOpenElements.forEach(function (element) {
      element.addEventListener('click', function () {
        popupObj.popupOpen();
      });
    }); // Триггер скрытия попапа

    triggerCloseElements.forEach(function (element) {
      element.addEventListener('click', function () {
        popupObj.popupClose();
      });
    });
  }

  function isDefaultOpened(popupObj) {
    var dataDefaultOpened = popupObj.element.getAttribute('data-popup-default-opened');
    return dataDefaultOpened;
  }

  function init(selector) {
    // Инициализация попапа
    var elements = document.querySelectorAll(selector);
    elements.forEach(function (element) {
      var popup = {};
      popup.element = element;
      bindFunctions(popup);
      bindTriggers(popup);

      if (isDefaultOpened(popup)) {
        popup.popupOpen();
      }

      element.popup = popup; // Привязываем попап к элементу
    });
  }

  init(selector);
}

$(document).ready(function () {
  popup('.js--popup');
  /* Инциализация кастомного скролла у блока контента в попапе */

  if (!isMobile) {
    var customScroll = document.querySelectorAll('.js--popup-custom-scroll');
    customScroll.forEach(function (item) {
      var ps = new PerfectScrollbar(item, {
        wheelSpeed: 0.3,
        swipeEasing: true
      });
      item.customScrollObj = ps;
    });
  } else {
    var customScrollMobile = document.querySelectorAll('.js--popup-custom-scroll-mobile');
    customScrollMobile.forEach(function (item) {
      var ps = new PerfectScrollbar(item, {
        wheelSpeed: 0.3,
        swipeEasing: true
      });
      item.customScrollObj = ps;
    });
  }
  /* Инциализация кастомного скролла у блока контента в попапе на мобиле */

});
"use strict";

$(function () {});
"use strict";
"use strict";

$(function () {});
"use strict";

document.onreadystatechange = function () {
  if (document.readyState === 'complete') {
    var promocodes = document.querySelectorAll('.js--promocode');

    if (promocodes) {
      promocodes.forEach(function (promocode) {
        var code = promocode.querySelector('.js--promocode-code'),
            // dataCode = code.getAttribute('data-code'),
        btn = promocode.querySelector('.js--promocode-btn'),
            msg = promocode.querySelector('.js--promocode__msg');
        btn.addEventListener('click', function () {
          var range = document.createRange();
          range.selectNode(code);
          window.getSelection().addRange(range);

          try {
            document.execCommand('copy');
          } catch (err) {
            console.log('Промокод не копируется :(');
          }

          btn.classList.add('promocode__btn--out');
          msg.classList.add('promocode__msg--in');
          window.getSelection().removeAllRanges();
        });
      });
    }
  }
};
"use strict";

$(function () {});
"use strict";

$(function () {});
"use strict";
"use strict";

$(document).ready(function () {
  // Ф-ция обработки стилизуемых опций
  // См. выбор диаметра пиццы, толщины теста и т.п.
  // Переключаемые классы для элементов выбираемых опций
  var optsItemsClasses = {
    'slider-network': {
      ip: 'slider-network__opts-label--active',
      it: 'slider-network__opts-text--active'
    }
  };

  function setActiveOpt(optionsObj, itemActive) {
    // ф-ция должна при загрузке и клике проверять выделенный
    var overlay = optionsObj.overlay,
        overlayStyle = overlay.style;
    optionsObj.optItems.forEach(function (item) {
      var itemText = item.querySelector('.js--opts-text'),
          dataOptsKey = optionsObj.dataOptsKey,
          ipActive = optsItemsClasses[dataOptsKey].ip,
          itActive = optsItemsClasses[dataOptsKey].it;
      item.removeAttribute('data-checked');
      itemActive.setAttribute('data-checked', '');

      if (item.hasAttribute('data-checked')) {
        item.classList.add(ipActive);
        itemText.classList.add(itActive);
        overlayStyle.opacity = 1;
        overlayStyle.top = item.offsetTop + "px";
        overlayStyle.left = item.offsetLeft + "px";
        overlayStyle.height = item.offsetHeight + "px";
        overlayStyle.width = item.offsetWidth + "px";
      } else {
        item.classList.remove(ipActive);
        itemText.classList.remove(itActive);
      }

      ;
    });
  }

  var opts = document.querySelectorAll('.js--slider-network .js--opts');

  if (opts) {
    opts.forEach(function (item) {
      var optItems = item.querySelectorAll('.js--opts-item'),
          itemActive = Array.from(optItems).filter(function (item) {
        return item.hasAttribute('data-checked');
      })[0],
          overlay = item.querySelector('.js--opts-overlay'),
          dataOptsKey = item.getAttribute('data-opts-key'),
          optionsObj = {
        optItems: optItems,
        overlay: overlay,
        dataOptsKey: dataOptsKey
      };
      setActiveOpt(optionsObj, itemActive);
      optItems.forEach(function (item) {
        item.addEventListener('click', function (e) {
          setActiveOpt(optionsObj, item);
        });
      });
    });
  }

  ;
  var sliderNetworkContainer = document.querySelectorAll('.js--slider-network-container');
  sliderNetworkContainer.forEach(function (container) {
    var $container = $(container),
        $sliderNetwork = $container.closest('.js--slider-network'),
        $sliderDots = $('.js--slider-network-dots', $sliderNetwork),
        $sliderArowPrev = $('.js--slider-network-arrow-prev', $sliderNetwork),
        $sliderArowNext = $('.js--slider-network-arrow-next', $sliderNetwork);
    $container.on('init', function (event, slick) {
      $sliderNetwork.removeClass('slider-network--preparing');
    });
    var sliderOptions = {
      slidesToShow: 1,
      slidesToScroll: 1,
      dots: true,
      customPaging: function customPaging(slider, i) {
        return '';
      },
      appendDots: $sliderDots,
      prevArrow: $sliderArowPrev,
      nextArrow: $sliderArowNext,
      draggable: false,
      infinite: true
    };
    $container.slick(sliderOptions);
  });
  var sliderNetworkSlides = document.querySelectorAll('.js--slider-network-slide');
  sliderNetworkSlides.forEach(function (slide) {
    var opts = slide.querySelectorAll('.js--slider-network-opts'),
        mediaBlocks = slide.querySelectorAll('.js--slider-network-media-block'),
        classMediaBlockActive = 'slider-network__media-block--active';
    opts.forEach(function (opt) {
      opt.addEventListener('click', function () {
        var dataBind = opt.getAttribute('data-bind');
        mediaBlocks.forEach(function (block) {
          var blockBind = block.getAttribute('data-bind');
          blockBind == dataBind ? block.classList.add(classMediaBlockActive) : block.classList.remove(classMediaBlockActive);
        });
      });
    });
  });
});
"use strict";

// Промо-слайдер (см. home.html)
document.addEventListener("DOMContentLoaded", function () {
  var $sliderPromoItems = $('.js--slider-promo__items');

  if ($sliderPromoItems.length > 0) {
    // Сохраняем пропорции слайдера
    var resizeSlider = function resizeSlider($sliderPromoObj) {
      var ratioWidth = window.matchMedia("(max-width: 768px)").matches ? 768 : 1920,
          ratioHeight = 520,
          ratio = ratioHeight / ratioWidth,
          windowWidth = window.innerWidth,
          $flickViewport = $('.flickity-viewport', $sliderPromoObj);
      $flickViewport.css({
        'height': windowWidth * ratio + 'px'
      });
    };

    var showSliderPromo = function showSliderPromo($sliderPromoObj) {
      // Подгоняем слайдер под нужные нам пропорции
      resizeSlider($sliderPromoObj); // Показываем слайдер

      $sliderPromoObj.removeClass('slider-promo__items--preparing'); // Оборачиваем точки навигации в блок-обёртку для стилизации

      $sliderPromoObj.find('.flickity-page-dots').wrap('<div class="slider-promo__dots" />');
      playToggleVideo('play', 0, $sliderPromoItems);
    };

    var playToggleVideo = function playToggleVideo(action, index, $sliderItems) {
      // Функция для проигрывания/паузы видео
      index = index || 0;
      var $slideCur = $(".js--slider-promo__item", $sliderItems).eq(index);
      var video = $slideCur.find('.js--slider-promo__video')[0];

      if (video) {
        switch (action) {
          case 'play':
            video.play();
            break;

          case 'pause':
            video.pause();
            break;

          default:
            break;
        }
      }
    };

    var sliderPromoOptions = {
      prevNextButtons: false,
      draggable: true,
      bgLazyLoad: true,
      cellAlign: 'left',
      contain: true,
      wrapAround: true,
      autoPlay: 5000,
      pauseAutoPlayOnHover: false
    };
    $sliderPromoItems.flickity(sliderPromoOptions);
    ;
    $sliderPromoItems.on('ready.flickity', showSliderPromo($sliderPromoItems));
    $sliderPromoItems.on('settle.flickity', function (event, index) {
      // Запускаем видео
      playToggleVideo('play', index, $sliderPromoItems);
    });
    $sliderPromoItems.on('change.flickity', function (event, index) {
      // Ставим видео на паузу
      playToggleVideo('pause', index, $sliderPromoItems);
    });
    var $btnNext = $(".js--slider-promo__btn-next", $sliderPromoItems);
    $btnNext.on("click", function () {
      $sliderPromoItems.flickity('next');
    }); // Отслеживаем ресайз окна и контролируем пропорции слайдера 

    window.addEventListener('resize', function () {
      resizeSlider($sliderPromoItems);
    });
  }
});
"use strict";

$(document).ready(function () {
  var sliderSimpleContainer = document.querySelectorAll('.js--slider-simple-container');
  sliderSimpleContainer.forEach(function (container) {
    var $container = $(container),
        $sliderSimple = $container.closest('.js--slider-simple'),
        $sliderArowPrev = $('.js--slider-simple-arrow-prev', $sliderSimple),
        $sliderArowNext = $('.js--slider-simple-arrow-next', $sliderSimple);
    $container.on('init', function (event, slick) {
      $sliderSimple.removeClass('slider-simple--preparing');
    });
    var sliderOptions = {
      slidesToShow: 1,
      slidesToScroll: 1,
      dots: false,
      prevArrow: $sliderArowPrev,
      nextArrow: $sliderArowNext,
      draggable: false,
      infinite: true
    };
    $container.slick(sliderOptions);
  });
});
"use strict";
"use strict";

// Спойлер
function spoiler(selector) {
  var classes = {
    iconActive: 'spoiler__title-pointer--active',
    titleIcon: 'spoiler__title-icon',
    titleIconActive: 'spoiler__title-icon--active',
    titleTextActive: 'spoiler__title-text--active',
    active: 'spoiler--expanded',
    contentActive: 'spoiler__content--active',
    triggerBtnActive: 'btn--spoiler-triggered'
  };
  var slideTime = 250;
  var group = false;
  var spoilers = [];

  function bindFunctions(spoilerObj) {
    // Привязка функций
    // Разворачивание спойлера (активное состояние)
    spoilerObj.expandToggle = function ($trigger) {
      spoilerObj.$icon.toggleClass(classes.iconActive);
      spoilerObj.$titleText.toggleClass(classes.titleTextActive);
      spoilerObj.$this.toggleClass(classes.active);

      if ($trigger.hasClass(classes.titleIcon)) {
        $trigger.toggleClass(classes.titleIconActive);
      }

      ;

      if (!isMobile || spoilerObj.$content.hasClass('js--spoiler__content--show-m')) {
        spoilerObj.$content.stop().slideToggle(slideTime).toggleClass(classes.contentActive); // spoilerObj.$content.toggleClass(classes.contentActive);
      } else {
        spoilerObj.$content.stop().slideToggle(slideTime).toggleClass(classes.contentActive); // spoilerObj.$content.toggleClass(classes.contentActive);
      }
    }; // Однократное разворачивание спойлера


    spoilerObj.expandOnce = function ($triggerOnce) {
      var dataSpoilerTrigger = $triggerOnce.data('spoiler-trigger');

      switch (dataSpoilerTrigger) {
        case 'btn':
          $triggerOnce.addClass(classes.triggerBtnActive);
          break; // default:

          break;
      }

      ;
      spoilerObj.$content.stop().slideToggle(slideTime).toggleClass(classes.contentActive);
    };

    spoilerObj.collapse = function ($trigger) {
      spoilerObj.$icon.removeClass(classes.iconActive);
      spoilerObj.$titleText.removeClass(classes.titleTextActive);
      spoilerObj.$this.removeClass(classes.active);

      if ($trigger.hasClass(classes.titleIcon)) {
        $trigger.removeClass(classes.titleIconActive);
      }

      ;

      if (!isMobile || spoilerObj.$content.hasClass('js--spoiler__content--show-m')) {
        spoilerObj.$content.stop().slideUp(slideTime).removeClass(classes.contentActive);
      } else {
        spoilerObj.$content.stop().slideUp(slideTime).removeClass(classes.contentActive);
      }
    };
  }

  ;

  function bindTriggers(spoilerObj) {
    // Триггеры события и т.п.
    spoilerObj.$trigger.on('click', function () {
      if (spoilers) {
        var filteredSpoilers = Array.from(spoilers).filter(function (spoiler) {
          return spoiler != spoilerObj.$this[0];
        });
        filteredSpoilers.forEach(function (spoiler) {
          spoiler.spoilerObj.collapse(spoiler.spoilerObj.$trigger);
        });
      }

      spoilerObj.expandToggle(spoilerObj.$trigger);
    });
    spoilerObj.$triggerOnce.on('click', function () {
      spoilerObj.expandOnce(spoilerObj.$triggerOnce);
    });
  }

  ;

  function init(selector) {
    // Инициализация спойлера
    var elements = document.querySelectorAll(selector);
    elements.forEach(function (element) {
      var dataGroup = element.getAttribute('data-group'),
          dataSpoiler = element.getAttribute('data-spoiler');

      if (dataGroup) {
        group = true;
        spoilers = document.querySelectorAll(selector + '[data-group="' + dataGroup + '"]');
      }

      var spoilerObj = {},
          triggerSelector = '.js--spoiler-trigger',
          triggerOnceSelector = '.js--spoiler-trigger-once';
      spoilerObj.$this = $(element);
      spoilerObj.$icon = $('.js--spoiler__title-pointer', $(element));
      spoilerObj.$titleText = $('.js--spoiler__title-text', $(element));

      if (dataSpoiler) {
        spoilerObj.$trigger = $(triggerSelector + '[data-spoiler="' + dataSpoiler + '"]', $(document));
      } else {
        spoilerObj.$trigger = $(triggerSelector, $(element));
      }

      spoilerObj.$triggerOnce = $(triggerOnceSelector, $(element));
      spoilerObj.$content = $('.js--spoiler__content', $(element));
      bindFunctions(spoilerObj);
      bindTriggers(spoilerObj);
      element.spoilerObj = spoilerObj; // Привязываем спойлер к элементу
    });
  }

  ;
  init(selector);
}

;
$(document).ready(function () {
  spoiler('.js--spoiler');
});
"use strict";
"use strict";

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Ф-ция для установки cookie
function setCookie(name, value) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  options = _objectSpread({
    path: '/'
  }, options);

  if (options.expires) {
    if (options.expires.toUTCString) {
      options.expires = options.expires.toUTCString();
    }
  }

  var updatedCookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);

  for (var optionKey in options) {
    updatedCookie += "; " + optionKey;
    var optionValue = options[optionKey];

    if (optionValue !== true) {
      updatedCookie += "=" + optionValue;
    }
  }

  document.cookie = updatedCookie;
} // Ф-ция для получения cookie


function getCookie(name) {
  var matches = document.cookie.match(new RegExp("(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"));
  return matches ? decodeURIComponent(matches[1]) : undefined;
}

;

(function () {
  var themeSwitcherButton = document.querySelector('.js--theme-switcher__button');

  if (themeSwitcherButton) {
    themeSwitcherButton.data = {
      theme: 'day'
    };
    var page = document.querySelector('.page'),
        pageMain = document.querySelector('.page__main'),
        theme = themeSwitcherButton.data.theme,
        icons = themeSwitcherButton.querySelector('.js--theme-switcher__icons'),
        logoImgs = document.querySelectorAll('.logo__img:not(.logo__img--mobile-nav)'),
        logoImgSvg; // Нажатие кнопки

    themeSwitcherButton.addEventListener('click', function () {
      var cookieName = 'night-theme'; // Добавляем куки с флагом включенной ночной темы

      if (getCookie(cookieName)) {
        setCookie(cookieName, undefined, {
          'max-age': -1
        });
      } else {
        setCookie(cookieName, true, {
          'path': '/'
        });
      }

      var nightThemeEnabled = getCookie(cookieName),
          buttonClassToRemove,
          buttonClassToAdd,
          iconsClassToRemove,
          iconsClassToAdd;

      if (nightThemeEnabled) {
        buttonClassToRemove = 'theme-switcher__button--day';
        buttonClassToAdd = 'theme-switcher__button--night';
        iconsClassToRemove = 'theme-switcher__icons--rotated-full';
        iconsClassToAdd = 'theme-switcher__icons--rotated-half';
        logoImgSvg = 'logo-new-fixed-white.svg';
      } else {
        buttonClassToRemove = 'theme-switcher__button--night';
        buttonClassToAdd = 'theme-switcher__button--day';
        iconsClassToRemove = 'theme-switcher__icons--rotated-half';
        iconsClassToAdd = 'theme-switcher__icons--rotated-full';
        logoImgSvg = 'logo-new-fixed.svg';
      }

      themeSwitcherButton.classList.remove(buttonClassToRemove);
      themeSwitcherButton.classList.add(buttonClassToAdd);
      icons.classList.remove(iconsClassToRemove);
      icons.classList.add(iconsClassToAdd);
      page.classList.toggle('page--night'); // Меняем src лого

      var sep = '/';
      logoImgs.forEach(function (item) {
        var logoImgSrc = item.src,
            srcArr = logoImgSrc.split(sep);
        srcArr[srcArr.length - 1] = logoImgSvg;
        item.src = srcArr.join(sep);
      });
    }); // Отслеживаем перемотку страницы о низу, чтобы корректно позиционировать кнопку

    window.addEventListener('scroll', function () {
      if (pageMain.offsetHeight <= pageYOffset + document.documentElement.clientHeight) {
        themeSwitcherButton.classList.add('theme-switcher__button--lifted');
      } else {
        themeSwitcherButton.classList.remove('theme-switcher__button--lifted');
      }
    });
  } // TODO - dev! delete after development ends!
  // document.querySelector('.page').classList.add('page--night');

})();
"use strict";

/* Тултип */
document.addEventListener("DOMContentLoaded", function () {
  function tooltip(selector) {
    var classes = {
      tooltipActive: 'tooltip--active',
      itemTileActive: 'item-tile--operated'
    };

    function bindFunctions(tooltipObj) {
      // Привязка функций
      tooltipObj.toggleOpenElements = function (state) {
        tooltipObj.openElements.forEach(function (element) {
          if (element.classList.contains('menu__span--pseudo-link')) {
            var classActive = 'menu__span--pseudo-active';

            if (state === 'on') {
              element.classList.add(classActive);
            }

            if (state === 'off') {
              element.classList.remove(classActive);
            }
          }

          if (element.classList.contains('header__city-name')) {
            var _classActive = 'header__city-name--active';

            if (state === 'on') {
              element.classList.add(_classActive);
            }

            if (state === 'off') {
              element.classList.remove(_classActive);
            }
          }
        });
      }; // Показ тултипа (активное состояние)


      tooltipObj.tooltipOpen = function () {
        var itemTile = tooltipObj.element.closest('.item-tile');

        if (itemTile) {
          itemTile.classList.add(classes.itemTileActive);
        }

        tooltipObj.toggleOpenElements('on');
        tooltipObj.element.classList.add(classes.tooltipActive);
      }; // Скрытие тултипа (неактивное состояние)


      tooltipObj.tooltipClose = function () {
        var itemTile = tooltipObj.element.closest('.item-tile');
        tooltipObj.element.classList.remove(classes.tooltipActive);
        tooltipObj.toggleOpenElements('off');

        if (itemTile && itemTile.classList.contains(classes.itemTileActive)) {
          itemTile.classList.remove(classes.itemTileActive);
        }
      };
    }

    ;

    function bindTriggers(tooltipObj) {
      // Триггеры события и т.п.
      var data = tooltipObj.element.getAttribute('data-tooltip'),
          dataSelector = '[data-tooltip="' + data + '"]',
          tooltipSelector = '.js--tooltip',
          triggerOpenSelector = tooltipSelector + '-open' + dataSelector,
          triggerCloseSelector = tooltipSelector + '-close' + dataSelector,
          triggerOpenElements = document.querySelectorAll(triggerOpenSelector),
          triggerCloseElements = document.querySelectorAll(triggerCloseSelector);
      tooltipObj.openElements = triggerOpenElements; // Триггер показа тултипа

      triggerOpenElements.forEach(function (element) {
        element.addEventListener('click', function () {
          tooltipObj.tooltipOpen();
        });
      }); // Триггер скрытия тултипа

      triggerCloseElements.forEach(function (element) {
        element.addEventListener('click', function () {
          tooltipObj.tooltipClose();
        });
      });
    }

    ;

    function init(selector) {
      // Инициализация попапа
      var elements = document.querySelectorAll(selector);
      elements.forEach(function (element) {
        var tooltip = {};
        tooltip.element = element;
        bindFunctions(tooltip);
        bindTriggers(tooltip);
        element.tooltip = tooltip; // Привязываем тултип к элементу
      });
    }

    ;
    init(selector);
  }

  ;
  tooltip('.js--tooltip');
});
"use strict";

$(function () {});